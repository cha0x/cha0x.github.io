{"meta":{"title":"CVBlogs","subtitle":null,"description":"developing..","author":"Zhong Qin","url":"http://www.cvblogs.cn"},"pages":[{"title":"","date":"2017-08-13T09:23:33.000Z","updated":"2017-08-13T19:11:55.000Z","comments":true,"path":"about/index.html","permalink":"http://www.cvblogs.cn/about/index.html","excerpt":"","text":"Talk is cheap.Show me the code. Linus Torvaldsdeveloper of the Linux kernel"},{"title":"categories","date":"2017-08-13T09:19:54.000Z","updated":"2017-08-13T09:20:30.000Z","comments":false,"path":"categories/index.html","permalink":"http://www.cvblogs.cn/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-08-13T09:16:20.000Z","updated":"2017-08-13T09:18:58.000Z","comments":true,"path":"tags/index.html","permalink":"http://www.cvblogs.cn/tags/index.html","excerpt":"","text":""},{"title":"","date":"2017-08-13T18:52:05.000Z","updated":"2017-08-13T18:52:05.000Z","comments":false,"path":"about/index/amazingdots.html","permalink":"http://www.cvblogs.cn/about/index/amazingdots.html","excerpt":"","text":"CVBlogs html, body { background: #fff; margin: 0; padding:0;} canvas { width: 100%; height: 100%; position: absolute; } $(function(){ var canvas = document.querySelector('canvas'), ctx = canvas.getContext('2d') canvas.width = window.innerWidth; canvas.height = window.innerHeight; ctx.lineWidth = .3; ctx.strokeStyle = (new Color(150)).style; var mousePosition = { x: 30 * canvas.width / 100, y: 30 * canvas.height / 100 }; var dots = { nb: 150, distance: 50, d_radius: 100, array: [] }; function colorValue(min) { return Math.floor(Math.random() * 255 + min); } function createColorStyle(r,g,b) { return 'rgba(' + r + ',' + g + ',' + b + ', 0.8)'; } function mixComponents(comp1, weight1, comp2, weight2) { return (comp1 * weight1 + comp2 * weight2) / (weight1 + weight2); } function averageColorStyles(dot1, dot2) { var color1 = dot1.color, color2 = dot2.color; var r = mixComponents(color1.r, dot1.radius, color2.r, dot2.radius), g = mixComponents(color1.g, dot1.radius, color2.g, dot2.radius), b = mixComponents(color1.b, dot1.radius, color2.b, dot2.radius); return createColorStyle(Math.floor(r), Math.floor(g), Math.floor(b)); } function Color(min) { min = min || 0; this.r = colorValue(min); this.g = colorValue(min); this.b = colorValue(min); this.style = createColorStyle(this.r, this.g, this.b); } function Dot(){ this.x = Math.random() * canvas.width; this.y = Math.random() * canvas.height; this.vx = -.5 + Math.random(); this.vy = -.5 + Math.random(); this.radius = Math.random() * 2; this.color = new Color(); console.log(this); } Dot.prototype = { draw: function(){ ctx.beginPath(); ctx.fillStyle = this.color.style; ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2, false); ctx.fill(); } }; function createDots(){ for(i = 0; i < dots.nb; i++){ dots.array.push(new Dot()); } } function moveDots() { for(i = 0; i < dots.nb; i++){ var dot = dots.array[i]; if(dot.y < 0 || dot.y > canvas.height){ dot.vx = dot.vx; dot.vy = - dot.vy; } else if(dot.x < 0 || dot.x > canvas.width){ dot.vx = - dot.vx; dot.vy = dot.vy; } dot.x += dot.vx; dot.y += dot.vy; } } function connectDots() { for(i = 0; i < dots.nb; i++){ for(j = 0; j < dots.nb; j++){ i_dot = dots.array[i]; j_dot = dots.array[j]; if((i_dot.x - j_dot.x) < dots.distance && (i_dot.y - j_dot.y) < dots.distance && (i_dot.x - j_dot.x) > - dots.distance && (i_dot.y - j_dot.y) > - dots.distance){ if((i_dot.x - mousePosition.x) < dots.d_radius && (i_dot.y - mousePosition.y) < dots.d_radius && (i_dot.x - mousePosition.x) > - dots.d_radius && (i_dot.y - mousePosition.y) > - dots.d_radius){ ctx.beginPath(); ctx.strokeStyle = averageColorStyles(i_dot, j_dot); ctx.moveTo(i_dot.x, i_dot.y); ctx.lineTo(j_dot.x, j_dot.y); ctx.stroke(); ctx.closePath(); } } } } } function drawDots() { for(i = 0; i < dots.nb; i++){ var dot = dots.array[i]; dot.draw(); } } function animateDots() { ctx.clearRect(0, 0, canvas.width, canvas.height); moveDots(); connectDots(); drawDots(); requestAnimationFrame(animateDots); } $('canvas').on('mousemove', function(e){ mousePosition.x = e.pageX; mousePosition.y = e.pageY; }); $('canvas').on('mouseleave', function(e){ mousePosition.x = canvas.width / 2; mousePosition.y = canvas.height / 2; }); createDots(); requestAnimationFrame(animateDots); });"}],"posts":[{"title":"UCF计算机视觉课程总结1","slug":"UCF-CVClass-Summary","date":"2017-09-01T09:20:40.000Z","updated":"2017-09-01T11:27:00.000Z","comments":true,"path":"2017/09/01/UCF-CVClass-Summary/","link":"","permalink":"http://www.cvblogs.cn/2017/09/01/UCF-CVClass-Summary/","excerpt":"前言&emsp;&emsp;从八月开始，断断续续学习这门课程。从一开始Coursera上乔治亚理工的CV课和CP课继而到UCF的CV课。算是入门了这门课程，为以后的研究工作打下了一些基础。虽然，我的数学基础在很大程度上限制着我的吸收消化。但是，始终相信，有志者事竟成这个道理。&emsp;&emsp;课程资源地址：UCF-CAP 5415 - Computer Vision学习过程中，可以参照课程日程表安排学习时间。适当的加强强度。(由于时间问题，本人只完成了小部分实验…最好还是要做做实验的。)&emsp;&emsp;虽然在onenote上针对每节课都已经做了笔记，但是发现，自己只是将教授PPT中的内容摘抄了出来。这里借助博客简单梳理一下这门课中学习到的内容(事实上，其中的每一课都值得另起一篇去详细介绍)，顺便提升自己的写作能力总结能力。&emsp;&emsp;我发现，本文的长度大大超过了预期。因此，基于”2-8准则”(实则我实在无法做到一小时完成这个工作)，计划每篇此类总结文章以两课为一篇文章去总结内容。","text":"前言&emsp;&emsp;从八月开始，断断续续学习这门课程。从一开始Coursera上乔治亚理工的CV课和CP课继而到UCF的CV课。算是入门了这门课程，为以后的研究工作打下了一些基础。虽然，我的数学基础在很大程度上限制着我的吸收消化。但是，始终相信，有志者事竟成这个道理。&emsp;&emsp;课程资源地址：UCF-CAP 5415 - Computer Vision学习过程中，可以参照课程日程表安排学习时间。适当的加强强度。(由于时间问题，本人只完成了小部分实验…最好还是要做做实验的。)&emsp;&emsp;虽然在onenote上针对每节课都已经做了笔记，但是发现，自己只是将教授PPT中的内容摘抄了出来。这里借助博客简单梳理一下这门课中学习到的内容(事实上，其中的每一课都值得另起一篇去详细介绍)，顺便提升自己的写作能力总结能力。&emsp;&emsp;我发现，本文的长度大大超过了预期。因此，基于”2-8准则”(实则我实在无法做到一小时完成这个工作)，计划每篇此类总结文章以两课为一篇文章去总结内容。 课程内容&emsp;&emsp;整门课内容设计较为合理，作为重实现轻理论(少数学细节推导，乔治亚理工的课程较侧重于数学细节)大军中的一员，接受度良好。在课程主页上还有参考资料(免费，开放下载)以及CV领域的顶刊顶会的官网链接等信息。 Lecture1 CVIntroduction&emsp;&emsp;第一课是关于计算机视觉中基础知识的介绍以及整个课程会接触到的内容的学习。了解计算机视觉所研究的是从二维图像中得到三维世界的语意信息。&emsp;&emsp;在这个过程中，常常将图像当作一个函数$f(x,y)$,它是一个离散的关于像素点的函数。常用一个矩阵表示一张图像，其元素是0(黑)～255(白)的灰度值。分辨率则是由图像的像素长宽确定(屏幕的分辨率通常是固定的，但是可以向下调整，分辨率越高图像越细腻)。还介绍了图片的格式(不同的格式只是压缩编码的方式不同)。也介绍了视频的基本属性。依照人眼的构造，视频帧数每秒30帧就可以达到流畅的基本要求。&emsp;&emsp;现今的射影设备都是基于孔洞模型(Pin Hole)进行射影变换。&emsp;&emsp;三维空间中的点$(x,y,z)$通过镜片投影到图像平面上的点$(x,y)$&emsp;&emsp;由以上这个模型，我们就很容易想到：应该如何通过二维图像恢复被摄物体在三维世界中的几何信息呢？&emsp;&emsp;这里不再细展开。以及，CV的应用有哪些：&emsp;&emsp;作为基础知识的简单入门，第一节课还是很不错的。至少罗列的那些应用光是看那些演示视频，想到自己也有机会去实现。光想想就能振奋人心。 Lecture2 Filtering&emsp;&emsp;第二节课是CV领域最最基础的一个概念–滤波(Filtering)。我的第一篇博文整理的就是关于滤波操作的知识(虽然大部分是copy的别人的总结…)。&emsp;&emsp;首先，当你拿到一张图像，一定要区分清楚它究竟是:1.二值的(Binary)、2.灰度的(Gray Scale)还是3.彩色的(Color)。&emsp;&emsp;1.二值图像矩阵元素要么是0要么是1&emsp;&emsp;2.灰度图像，Scale范围通常(0~255)&emsp;&emsp;3.彩色图像较为复杂，通常在RGB空间下分为3个通道(R-Red、G-Green、B-Blue)&emsp;&emsp;因为这些值元素的存在，引入一个图像直方图去直观描述它的比重信息。&emsp;&emsp;&emsp;&emsp;由于各种内外界不稳定因素的干扰，图像并不总是”干净”的,总是有这样那样的噪声(通常高频信息是噪声-变化明显，变现的特征就是高频信息)。噪声叠加原图像得到被污染后的图像。(高斯噪声即噪声的分布符合高斯分布！)&emsp;&emsp;&emsp;&emsp;接着为引入滤波的概念，介绍了基本的数学运算：求导(Derivative，包括连续的和离散的即查分：向前、向后、中心，接着从一维引申到二维（图像是一个二维矩阵），接着提到了相关(Correlation)以及卷积(Convolution))以及求均值(Average/Mean)。&emsp;&emsp;并且，还提到了掩膜(Mask)的概念。&emsp;&emsp;高斯分布的重要意义：&emsp;&emsp;&emsp;&emsp;由于之前的文章已经梳理过，这里不再赘述。第二节结束。目前，我们已经了解了一些基本知识和基本运算(Matlab由库函数实现，推荐使用。) 结束语&emsp;&emsp;写博客真是一项锻炼能力的活，花了一个半小时才写完两节课的简单梳理总结。这进度我也是醉了！看来，以后应该利用碎片化的闲暇时间一点点完成。否则太占用学习时间了！","categories":[{"name":"计算机视觉","slug":"计算机视觉","permalink":"http://www.cvblogs.cn/categories/计算机视觉/"}],"tags":[{"name":"课程知识总结","slug":"课程知识总结","permalink":"http://www.cvblogs.cn/tags/课程知识总结/"}]},{"title":"图像处理基础-滤波(filtering)","slug":"image-processing-operation1","date":"2017-08-11T11:39:53.000Z","updated":"2017-09-01T09:11:25.000Z","comments":true,"path":"2017/08/11/image-processing-operation1/","link":"","permalink":"http://www.cvblogs.cn/2017/08/11/image-processing-operation1/","excerpt":"","text":"前言&emsp;&emsp;本文介绍图像处理基础知识滤波(filtering)相关知识。在图像处理中，你经常能够看到它的身影。对于学习图像处理，理解滤波背后的数学知识非常重要。 &emsp;&emsp;滤波分为基于空间域滤波(spatial filtering)与基于频率域滤波(frequency filtering)。二者的目的都是为了改善图像质量。篇幅有限，此篇文章先介绍空间滤波。 空间滤波(Spatial Filtering)&emsp;&emsp;空间滤波操作有时候也被叫做卷积滤波，或者干脆叫卷积(convolution)(离散的卷积，不是微积分里连续的卷积);常常需要用一个滤波器(filter)做空间滤波操作;滤波器也有很多名字:卷积模版(template)、卷积核(kernel)、掩模(mask)、窗口(window)等。 &emsp;&emsp;空间滤波可以分为线性滤波(linear filter)和非线性滤波(non-linear filter)。非线性滤波常见的有中值滤波、最大值滤波等，相当于自定义一个函数，在数学上由于不满足线性变换因此叫做非线性滤波。这里不细研究它。 &emsp;&emsp;线性滤波通常是：将模版覆盖区域内的元素，以模版中对应位置元素为权值，进行累加。与卷积操作类似的，还有一种数学操作叫做协相关(cross-correlatioin)，它们都可以看作是基于矩阵内积的操作。具有平移不变性(shift-invariant)。 &emsp;&emsp;二者的区别：卷积和协相关的差别是，卷积需要先对滤波矩阵进行180度的翻转，但如果矩阵是对称的，那么两者就没有什么差别了。实际上，在信号处理领域，卷积有广泛的意义，而且有其严格的数学定义，但在这里不关注这个。2D卷积需要4个嵌套循环(4-double loop)，所以它并不快，除非我们使用很小的卷积核。这里一般使用3x3或者5x5。而且，对于滤波器，也有一定的规则要求： 1）滤波器的大小应该是奇数，这样它才有一个中心，例如3x3，5x5或者7x7。有中心了，也有了半径的称呼，例如5x5大小的核的半径就是2。 2）滤波器矩阵所有的元素之和应该要等于1，这是为了保证滤波前后图像的亮度保持不变。当然了，这不是硬性要求了。 3）如果滤波器矩阵所有元素之和大于1，那么滤波后的图像就会比原图像更亮，反之，如果小于1，那么得到的图像就会变暗。如果和为0，图像不会变黑，但也会非常暗。 4）对于滤波后的结构，可能会出现负数或者大于255的数值。对这种情况，我们将他们直接截断到0和255之间即可。对于负数，也可以取绝对值。 卷积核(Convolution Kernel)&emsp;&emsp;定义不同的卷积核与原图像做卷积操作，可以产生不同的效果。滤波与模糊的概念区分。模糊是人为感受到的现象，通过滤波操作可以呈现。 什么都不做&emsp;&emsp;滤波器矩阵所有元素之和为1，保证滤波前后图像的亮度保持不变。这个滤波器啥也没有做，得到的图像和原图是一样的。因为只有中心点的值是1。邻域点的权值都是0，对滤波后的取值没有任何影响。 图像锐化滤波器(Sharpness Filter)&emsp;&emsp;图像的锐化和边缘检测很像，首先找到边缘，然后把边缘加到原来的图像上面，这样就强化了图像的边缘，使图像看起来更加锐利了。这两者操作统一起来就是锐化滤波器了，也就是在边缘检测滤波器的基础上，再在中心的位置加1，这样滤波后的图像就会和原始的图像具有同样的亮度了，但是会更加锐利。 &emsp;&emsp;我们把核加大，就可以得到更加精细的锐化效果 &emsp;&emsp;下面的滤波器会更强调边缘。 &emsp;&emsp;主要是强调图像的细节。最简单的3x3的锐化滤波器如下： &emsp;&emsp;实际上是计算当前点和周围点的差别，然后将这个差别加到原来的位置上。另外，中间点的权值要比所有的权值和大于1，意味着这个像素要保持原来的值。 边缘检测(Edge Detection)&emsp;&emsp;我们要找水平的边缘：需要注意的是，这里矩阵的元素和是0，所以滤波后的图像会很暗，只有边缘的地方是有亮度的。 &emsp;&emsp;相当于做差分(differencing)，求导的离散版本，有向前差分(forward differencing)，向后差分(backward differencing)，中心差分(central differencing)。 &emsp;&emsp;下面的滤波器可以找到垂直方向的边缘，这里像素上和下的像素值都使用 &emsp;&emsp;再下面这个滤波器可以找到45度的边缘：取-2不为了什么，只是为了让矩阵的元素和为0而已。 &emsp;&emsp;那下面这个滤波器就可以检测所有方向的边缘。 &emsp;&emsp;为了检测边缘，我们需要在图像对应的方向计算梯度。用下面的卷积核来卷积图像，就可以了。但在实际中，这种简单的方法会把噪声也放大了。另外，需要注意的是，矩阵所有的值加起来要是0。 浮雕(Embossing Filter)&emsp;&emsp;浮雕滤波器可以给图像一种3D阴影的效果。只要将中心一边的像素减去另一边的像素就可以了。这时候，像素值有可能是负数，我们将负数当成阴影，将正数当成光，然后我们对结果图像加上128的偏移。这时候，图像大部分就变成灰色了。 &emsp;&emsp;下面是45度的浮雕滤波器 &emsp;&emsp;只要加大滤波器，就可以得到更加夸张的效果了 均值模糊(Box Filter/Averaging)&emsp;&emsp;我们可以将当前像素和它的四邻域的像素一起取平均，然后再除以5，或者直接在滤波器的5个地方取0.2的值即可，如下图 &emsp;&emsp;可以看到，这个模糊还是比较温柔的，我们可以把滤波器变大，这样就会变得粗暴了：注意要将和再除以13. &emsp;&emsp;如果你想要更模糊的效果，加大滤波器的大小即可。或者对图像应用多次模糊也可以。 高斯模糊(Gaussian Filter)&emsp;&emsp;均值模糊很简单，但不是很平滑。高斯模糊就有这个优点，所以被广泛用在图像降噪上。特别是在边缘检测之前，都会用来移除细节。高斯滤波器是一个低通滤波器。 运动模糊(Motion Blur)&emsp;&emsp;运动模糊可以通过只在一个方向模糊达到，例如下面9x9的运动模糊滤波器。注意，求和结果要除以9。 &emsp;&emsp;这个效果就好像，摄像机是从左上角移动的右下角。 自己手写的卷积函数虽然Matlab已经封装了一个函数con2()作卷积操作，但是还是要自己手写一下加深理解。下面是UCF计算机视觉网课的作业。4层循环。因为边缘效应通常情况下需要补0。还是Matlab新手，代码一点都不elegant，没有借鉴意义。 function [] = pa1() m_img = imread(&apos;PA1/balloon.jpg&apos;); m_kernel = rand(5,5); [r1, c1, cc1] = size(m_img); [r2, c2] = size(m_kernel); for i = r2+1:r1 for j = c2+1:c1 sump = 0; for k = 1:r2 for l = 1:c2 sump = m_img(i-k, j-l) * m_kernel(k,l); end; end; outQ(i,j) = sump; end; end imshow(outQ);wait(0); Matlab中用imfilter()实现线性空间滤波&emsp;&emsp;最常用的是这句： imfilter(f, w, &apos;replicate&apos;) %相关滤波，默认边界外围填充0，造成黑边，使用&apos;replicate&apos;复制边缘像素，消除边缘效应，输出大小与输入图像f相同. &emsp;&emsp;imfilter()默认是相关算子，在做真正的卷积之前可以先将核旋转180°(除非你指定了滤波模式为’conv’)，rotated_filter=flipud(fliplr(filter)) imfilter(f, w, filtering_mode, boundary_options, size_options) f:图像 w:滤波模版 filtering_mode:滤波模式 &apos;corr&apos;:相关滤波。[默认值] &apos;conv&apos;:卷积滤波。 boundary_options:边界选项 P:(没有引号)边界外围补充0。[默认值] &apos;replicate&apos;:边界外围复制边界值 &apos;symmetric&apos;:边界外围使用边界镜像 &apos;circular&apos;:图像的大小通过讲图像处理为二维周期函数的一个周期来扩展（这是什么？） size_options:大小选项 &apos;same&apos;:输出大小与输入图像f大小相同。[默认值] &apos;full&apos;:输出与扩展（填充）后的图像大小相同。 总结 规范用语，在滑窗操作、计算图像梯度等场合，不要使用“卷积”，而要使用“滤波”或者“协相关”。因为，我们通常讲的卷积，在这几个操作中其实是协相关，那就不要用卷积这个词以避免引起混淆。 不同的滤波器产生的效果不同，滤波器的定义有讲究。经常会看到一些人名命名的算子。比如用作边缘检测，拉普拉斯(Laplacian)算子、Canny算子。观察它们的算子内容，结合卷积核的定义规则。你会发现其实就那么回事。不要被复杂的学术名词给弄懵逼了。 GPU实现代替CPU实现，CPU实现需要四重循环，时间代价太大，性能不好。GPU使用特定的数据结构直接进行计算降低时间代价。 这是我的第一篇博文，本来是想好好写的，发现写博文真的是一项技术活。话到嘴边，憋不出一个字。 参考引用 图像卷积与滤波的一些知识点 图像卷积、相关以及在MATLAB中的操作","categories":[{"name":"图像处理","slug":"图像处理","permalink":"http://www.cvblogs.cn/categories/图像处理/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://www.cvblogs.cn/tags/数学/"}]},{"title":"开发测试","slug":"hello-world","date":"2017-08-05T11:11:50.000Z","updated":"2017-08-13T19:08:00.000Z","comments":true,"path":"2017/08/05/hello-world/","link":"","permalink":"http://www.cvblogs.cn/2017/08/05/hello-world/","excerpt":"","text":"博客正在完善中&emsp;&emsp;稍安勿躁","categories":[{"name":"网页开发","slug":"网页开发","permalink":"http://www.cvblogs.cn/categories/网页开发/"}],"tags":[{"name":"测试","slug":"测试","permalink":"http://www.cvblogs.cn/tags/测试/"}]}]}