{"meta":{"title":"CVBlogs","subtitle":null,"description":"developing..","author":"Zhong Qin","url":"http://www.cvblogs.cn"},"pages":[{"title":"","date":"2017-08-13T09:23:33.000Z","updated":"2017-08-13T19:11:55.000Z","comments":true,"path":"about/index.html","permalink":"http://www.cvblogs.cn/about/index.html","excerpt":"","text":"Talk is cheap.Show me the code. Linus Torvaldsdeveloper of the Linux kernel"},{"title":"categories","date":"2017-08-13T09:19:54.000Z","updated":"2017-08-13T09:20:30.000Z","comments":false,"path":"categories/index.html","permalink":"http://www.cvblogs.cn/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-08-13T09:16:20.000Z","updated":"2017-08-13T09:18:58.000Z","comments":true,"path":"tags/index.html","permalink":"http://www.cvblogs.cn/tags/index.html","excerpt":"","text":""},{"title":"","date":"2017-08-13T18:52:05.000Z","updated":"2017-08-13T18:52:05.000Z","comments":false,"path":"about/index/amazingdots.html","permalink":"http://www.cvblogs.cn/about/index/amazingdots.html","excerpt":"","text":"CVBlogs html, body { background: #fff; margin: 0; padding:0;} canvas { width: 100%; height: 100%; position: absolute; } $(function(){ var canvas = document.querySelector('canvas'), ctx = canvas.getContext('2d') canvas.width = window.innerWidth; canvas.height = window.innerHeight; ctx.lineWidth = .3; ctx.strokeStyle = (new Color(150)).style; var mousePosition = { x: 30 * canvas.width / 100, y: 30 * canvas.height / 100 }; var dots = { nb: 150, distance: 50, d_radius: 100, array: [] }; function colorValue(min) { return Math.floor(Math.random() * 255 + min); } function createColorStyle(r,g,b) { return 'rgba(' + r + ',' + g + ',' + b + ', 0.8)'; } function mixComponents(comp1, weight1, comp2, weight2) { return (comp1 * weight1 + comp2 * weight2) / (weight1 + weight2); } function averageColorStyles(dot1, dot2) { var color1 = dot1.color, color2 = dot2.color; var r = mixComponents(color1.r, dot1.radius, color2.r, dot2.radius), g = mixComponents(color1.g, dot1.radius, color2.g, dot2.radius), b = mixComponents(color1.b, dot1.radius, color2.b, dot2.radius); return createColorStyle(Math.floor(r), Math.floor(g), Math.floor(b)); } function Color(min) { min = min || 0; this.r = colorValue(min); this.g = colorValue(min); this.b = colorValue(min); this.style = createColorStyle(this.r, this.g, this.b); } function Dot(){ this.x = Math.random() * canvas.width; this.y = Math.random() * canvas.height; this.vx = -.5 + Math.random(); this.vy = -.5 + Math.random(); this.radius = Math.random() * 2; this.color = new Color(); console.log(this); } Dot.prototype = { draw: function(){ ctx.beginPath(); ctx.fillStyle = this.color.style; ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2, false); ctx.fill(); } }; function createDots(){ for(i = 0; i < dots.nb; i++){ dots.array.push(new Dot()); } } function moveDots() { for(i = 0; i < dots.nb; i++){ var dot = dots.array[i]; if(dot.y < 0 || dot.y > canvas.height){ dot.vx = dot.vx; dot.vy = - dot.vy; } else if(dot.x < 0 || dot.x > canvas.width){ dot.vx = - dot.vx; dot.vy = dot.vy; } dot.x += dot.vx; dot.y += dot.vy; } } function connectDots() { for(i = 0; i < dots.nb; i++){ for(j = 0; j < dots.nb; j++){ i_dot = dots.array[i]; j_dot = dots.array[j]; if((i_dot.x - j_dot.x) < dots.distance && (i_dot.y - j_dot.y) < dots.distance && (i_dot.x - j_dot.x) > - dots.distance && (i_dot.y - j_dot.y) > - dots.distance){ if((i_dot.x - mousePosition.x) < dots.d_radius && (i_dot.y - mousePosition.y) < dots.d_radius && (i_dot.x - mousePosition.x) > - dots.d_radius && (i_dot.y - mousePosition.y) > - dots.d_radius){ ctx.beginPath(); ctx.strokeStyle = averageColorStyles(i_dot, j_dot); ctx.moveTo(i_dot.x, i_dot.y); ctx.lineTo(j_dot.x, j_dot.y); ctx.stroke(); ctx.closePath(); } } } } } function drawDots() { for(i = 0; i < dots.nb; i++){ var dot = dots.array[i]; dot.draw(); } } function animateDots() { ctx.clearRect(0, 0, canvas.width, canvas.height); moveDots(); connectDots(); drawDots(); requestAnimationFrame(animateDots); } $('canvas').on('mousemove', function(e){ mousePosition.x = e.pageX; mousePosition.y = e.pageY; }); $('canvas').on('mouseleave', function(e){ mousePosition.x = canvas.width / 2; mousePosition.y = canvas.height / 2; }); createDots(); requestAnimationFrame(animateDots); });"}],"posts":[{"title":"数学基础：矩阵范数及latex公式编辑","slug":"basic-math","date":"2017-09-25T08:22:10.000Z","updated":"2017-09-25T12:21:30.000Z","comments":true,"path":"2017/09/25/basic-math/","link":"","permalink":"http://www.cvblogs.cn/2017/09/25/basic-math/","excerpt":"前言&emsp;&emsp;在学习过程中，发现似乎在最优化问题上常常通过范数进行计算。于是，这里简单梳理一下关于范数的基础知识。范数是数学中的一个基本概念(经常能看到它的身影，只不过它利用$\\parallel \\cdot \\parallel $符号进行表示，使我们不易认出它。举个例子：我们常使用的，一维世界中，衡量两点间的距离就是使用的1范数)，范数属于线性代数、泛函分析中的内容。掌握范数的基础知识对于以后的研究工作很有必要。&emsp;&emsp;其常常被用来度量某个向量空间（或矩阵）中的每个向量的长度或大小。这里，我们将只讨论矩阵范数相关的内容。","text":"前言&emsp;&emsp;在学习过程中，发现似乎在最优化问题上常常通过范数进行计算。于是，这里简单梳理一下关于范数的基础知识。范数是数学中的一个基本概念(经常能看到它的身影，只不过它利用$\\parallel \\cdot \\parallel $符号进行表示，使我们不易认出它。举个例子：我们常使用的，一维世界中，衡量两点间的距离就是使用的1范数)，范数属于线性代数、泛函分析中的内容。掌握范数的基础知识对于以后的研究工作很有必要。&emsp;&emsp;其常常被用来度量某个向量空间（或矩阵）中的每个向量的长度或大小。这里，我们将只讨论矩阵范数相关的内容。 范数的基本性质&emsp;&emsp;任何范数都必须满足以下三个性质: 非负性 齐次性 三角不等式&emsp;&emsp;矩阵范数还需满足相容性：$\\parallel {XY} \\parallel $$\\leq $$\\parallel X \\parallel $$\\parallel Y \\parallel$。因此也称其为相容范数。 常用的三种$p$范数推导出的矩阵范数1-范数&emsp;&emsp;也叫列和范数，A每一列元素绝对值之和的最大值。&emsp;&emsp;其中，&emsp;&emsp;其余类似. 2-范数&emsp;&emsp;谱范数，即$A^H$ * $A$特征值$\\lambda_i$中最大者$\\lambda_1$的平方根，其中$A^H$为$A$的转置共轭矩阵. ∞-范数：&emsp;&emsp;（行和范数，A每一行元素绝对值之和的最大值） (其中$\\sum \\parallel a_{1j} \\parallel $ 为第一行元素绝对值的和，其余类似); 其它的p-范数&emsp;&emsp;没有很简单的表达式。对于$p$-范数而言，可以证明:&emsp;&emsp;其中p和q是共轭指标。简单的情形可以直接验证：&emsp;&emsp;一般情形则需要利用: 引用 百度百科 CSDN Markdown简明教程3-表格和公式 机器学习中常见的字母解析及MarkDown代码 结束语&emsp;&emsp;才发现不总结真的不行，又把之前学过的知识忘记了。总之，在图像处理中，矩阵范数这个概念真的非常重要。&emsp;&emsp;另外针对markdown中数学公式的书写真的是一大硬伤。需要花时间好好学习一下$latex$的语法。才发现百度百科里的公式都不是正规的$latex$书写的。&emsp;&emsp;从四点开始写总结，八点才写完…$latex$公式真可怕。生产力杀手啊…最后还是靠的在线编辑器…","categories":[{"name":"图像处理","slug":"图像处理","permalink":"http://www.cvblogs.cn/categories/图像处理/"}],"tags":[{"name":"数学基础","slug":"数学基础","permalink":"http://www.cvblogs.cn/tags/数学基础/"}]},{"title":"孟宁《软件工程C实战》实验报告2","slug":"software-engineering-exp2","date":"2017-09-23T16:45:35.000Z","updated":"2017-09-23T16:59:44.000Z","comments":true,"path":"2017/09/24/software-engineering-exp2/","link":"","permalink":"http://www.cvblogs.cn/2017/09/24/software-engineering-exp2/","excerpt":"前言&emsp;&emsp;本篇博文是孟宁老师的Mooc网课的实验报告内容。实验主要是关于字符串的处理，需要对字符串函数熟悉，可以减少自己造轮子。非常有意义的实验！","text":"前言&emsp;&emsp;本篇博文是孟宁老师的Mooc网课的实验报告内容。实验主要是关于字符串的处理，需要对字符串函数熟悉，可以减少自己造轮子。非常有意义的实验！ 实验内容&emsp;&emsp;设计实现一个迷你命令行解析小程序。 实验代码&emsp;&emsp;重新看自己的代码，发现写的还是很糟糕的。例如，函数没有采用驼峰式等。等到下回有机会改进把。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/************************************************************************* &gt; File Name: MiniCmd.c &gt; Author: Qin Zhong &gt; Mail: zhongqin0820@163.com &gt; Created Time: 2017年09月16日 星期六 16时01分33秒 ************************************************************************/#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#define MAXN 128void PrintHelp()&#123; printf(\"help cmd list\\n\"); printf(\"------------------------------------------------------\\n\"); printf(\"help for help list\\n\"); printf(\"quit for exit this program\\n\\n\");&#125;void ErrorCmdPrint()&#123; printf(\"error cmd\\n\\n\"); PrintHelp();&#125;int main()&#123; char cmd[MAXN]; memset(cmd,0,sizeof(char)*MAXN); while(1) &#123; gets(cmd); if(strcmp(cmd,\"help\") == 0) &#123; PrintHelp(); &#125; else if(strcmp(cmd,\"quit\") == 0) &#123; printf(\"bye~\\n\"); exit(0); &#125; else if(strcmp(cmd,\"clear\") == 0) &#123; system(\"cls\"); &#125; else if(strstr(cmd,\"hello\") != NULL) &#123; printf(\"你好,%s\\n\",cmd); &#125; else if(strcmp(cmd,\"null\") == 0) &#123; printf(\"null\\n\"); &#125; else if(strstr(cmd,\"whois\") != NULL) &#123; printf(\"me\\n\"); &#125; else &#123; ErrorCmdPrint(); &#125; &#125; return 0;&#125; 课程链接软件工程（C编码实践篇） 结束语&emsp;&emsp;其实上周就开始做了，但是还是太懒了..最近又忙，看了第三课老师的讲解，发现自己还是想简单了。另外，代码到底用tab还是空格对于程序美观真的很重要..","categories":[{"name":"软件工程","slug":"软件工程","permalink":"http://www.cvblogs.cn/categories/软件工程/"}],"tags":[{"name":"实验报告","slug":"实验报告","permalink":"http://www.cvblogs.cn/tags/实验报告/"}]},{"title":"假期工作总结","slug":"summer-summary","date":"2017-09-19T17:11:25.000Z","updated":"2017-09-19T17:11:25.000Z","comments":true,"path":"2017/09/20/summer-summary/","link":"","permalink":"http://www.cvblogs.cn/2017/09/20/summer-summary/","excerpt":"前言&emsp;&emsp;假期主要分为两部分。7月在学校作生产实习。8月自主学习一些机器学习、计算机视觉相关的基础知识。絮絮叨叨，发现总结真的是一项耗费时间的事情。","text":"前言&emsp;&emsp;假期主要分为两部分。7月在学校作生产实习。8月自主学习一些机器学习、计算机视觉相关的基础知识。絮絮叨叨，发现总结真的是一项耗费时间的事情。 生产实习&emsp;&emsp;课程班级：机器学习班。主要内容为： python 语言的学习及相关科学计算包的基础使用 机器学习部分：图像的特征提取(颜色直方图、共生矩阵、HoG、SIFT等）、监督学习算法(二分类、线性回归、逻辑回归、SVM)的API调用、无监督学习算法(K-means、神经网络的训练) 图像处理部分：显著特征提取、生成掩膜进行显著抠图(这部分主要由我负责，使用的是grabcut…) 最后进行图像分类challenge：我们组用的神经网络的方法 &emsp;&emsp;由于我上课中间出去中大夏令营一周，导致没有赶上机器学习部分的课程。 自主学习理论部分&emsp;&emsp;这部分，自己主要一开始看的是udacity上乔治亚理工的视觉MOOC，当时数学基础还没复习。导致没看懂相关讲解的内容。现在回想起来，老师的确上的很好。能够从数学的角度去分析算法。可惜只跟到了Lesson13(印象中)。期间也看了udacity上其他的视觉或者图像处理相关的MOOC。觉得自己吸收有点困难。遂放弃。&emsp;&emsp;转而学习了UCF的课程，老师的口音很有趣。缓缓道来的感觉。但是，精力有限，直到现在依旧没能接着做它的PA。总结也只很水的做了两篇。通过这门课程，发现，自己之前尝试学习视觉相关的知识一直很困难的主要原因：1、手头没有很好的资源以及合理的先导知识和时间分配 2、对于一些东西，感觉自己容易陷入其中。无法站在框架之上去架构自己的知识。最后导致自己只听了个炮响。又由于我们没有开设相关课程，没有考试，没有实验代码或者甚至项目留下印证。等到回过头来，发现自己什么也不会。&emsp;&emsp;在结束生产实习后，凑巧在翻阅博客的过程中，了解到台大李宏毅老师的机器学习课程，跟着学了几课。又觉得《线性代数》非常重要，于是学习了李的另一门公开课《线性代数》。李采用中英文结合的方式授课，我感觉这种授课方式非常的好，正是我所欠缺的，借助这门课补充复习了一下一些线性代数的英文专有名词等。&emsp;&emsp;学习这些，让我越来越觉得数学的重要性。于是找到了吴福朝老师的《计算机视觉中的数学方法》。这本书，虽然只读了前两篇的内容。但是却收获很多。&emsp;&emsp;期间，经同学介绍，看周志华的《机器学习》。这本书，我卡在了第二章就没有接着读了。因为我当时觉得自己得先上点课有了视听基础之后，去读这本书才能事半功倍。于是，就开始看吴恩达老师的《机器学习》MOOC。&emsp;&emsp;关于吴恩达老师的《机器学习》系列教程，我觉得上的很好。而且我觉得自己至少对一些内容有了了解。前段时间恰好他的系列教程和网易合作发布。于是就看了以下他关于《深度学习》的几课。然后，我了解到李飞飞教授和她实验室下的ImageNet以及她也在今年上的一门公开课《视觉检测中的卷积神经网络》(不知这里翻译是否有错，还请斧正)。然后现在主要就是空闲时候会安排学习这门课的内容。&emsp;&emsp;又根据吴的访谈视频知道了Ian的《深度学习》书，看了其中的一些章节。特别是数学部分。感觉自己看完，有了更好的掌握和理解。期间也重新翻阅老师的那篇字典学习的论文，发现有了基础之后又有了新的理解。 实现部分&emsp;&emsp;断断续续，这段时间完成了我们大创的系统。项目发布在了GitHub。&emsp;&emsp;其他基本上没实现出什么，有的也是调库。说实在，我很疑惑。究竟有无必要去自己手写一个SIFT之类的。&emsp;&emsp;其他不相关的，大概是通过这段时间自己有意识的参与一些课程的实践。加强Linux环境下的工具使用。以及关于GitHub的使用。&emsp;&emsp;一直有这样的计划，想要去掌握GPU编程。但是实践的东西真的很费时间，更何况手头也无硬件设备支持。更别提其他基础实验都无法完成，常常就导致一些计划的搁置。&emsp;&emsp;更不相关的大概就是自己关于前端内容的一些学习。这是出于我目前的规划考虑的。我觉得自己既然选择了读专硕，在两年毕业后(实际上我觉得也就一年半有余)，如果我未能在”学术”上取得一定的成就，至少我也要有一点竞争力，感觉前端这块需要很烂大街，但是还是缺那种有架构能力的前端，希望自己到时候会是一个全栈。并且，我觉得这门技术的掌握，如果以后要做项目也是很容易的。 结束语&emsp;&emsp;这段时间，感觉自己的确收获挺多。学习的效果比想象中的好一些。没有压力的学习真的是一件很舒服的事情。偶尔，也在思考自己毕设该做什么。自己研究生究竟该研究什么。记得自己之前初生牛犊不怕虎，说过希望自己能够在研究生时期有机会发顶会、顶刊。突然觉得，自己虽然会为此花费精力，但是现在觉得这是一件很困难的事情（虽然本来也不容易）。&emsp;&emsp;感觉自己还是更倾向去做东西。之所以这么渴望去了解学习这个学科的内容，也是因为一直想要实现自己脑海中的那个idea。希望自己能够不忘初心，方得始终。","categories":[{"name":"学习周报","slug":"学习周报","permalink":"http://www.cvblogs.cn/categories/学习周报/"}],"tags":[{"name":"学习总结","slug":"学习总结","permalink":"http://www.cvblogs.cn/tags/学习总结/"}]},{"title":"孟宁《软件工程C实战》实验报告1","slug":"software-engineering-exp1","date":"2017-09-09T15:52:16.000Z","updated":"2017-09-09T16:20:10.000Z","comments":true,"path":"2017/09/09/software-engineering-exp1/","link":"","permalink":"http://www.cvblogs.cn/2017/09/09/software-engineering-exp1/","excerpt":"前言&emsp;&emsp;本篇博文是孟宁老师的Mooc网课的实验报告内容。实验主要是熟悉Linux环境下的vim编辑器以及关于git的实验，对于有相关经验的同学来说，较为简单。但是正是这样的小实验使得学习的人在实验过程中加深对相关工具的使用！非常有意义的实验！","text":"前言&emsp;&emsp;本篇博文是孟宁老师的Mooc网课的实验报告内容。实验主要是熟悉Linux环境下的vim编辑器以及关于git的实验，对于有相关经验的同学来说，较为简单。但是正是这样的小实验使得学习的人在实验过程中加深对相关工具的使用！非常有意义的实验！ 实验内容&emsp;&emsp;即使从来没有使用的人，参照实验大纲，也能够很顺利的完成实验内容。(可能在配置Git的时候，会占用过多的时间！)&emsp;&emsp;虽然不是第一次使用GitHub，但是，依旧没能够记住git push命令的使用…&emsp;&emsp;虽然这次的代码量真的非常有限，但是也能够学习到一些关于vim使用的技巧！ 实验代码&emsp;&emsp;本次实验代码非常简单，关键应该是那些命令行的使用！12345#include&lt;stdio.h&gt;int main()&#123; printf(\"hello world!\\n\"); return 0;&#125; 课程链接软件工程（C编码实践篇） 结束语&emsp;&emsp;非常感谢孟老师能够提供这样一门课程以供我们练习。作为一名已经修读过软件工程的大四学生而言！觉得这门课程的设计非常的合理！很遗憾知道的晚了！","categories":[{"name":"软件工程","slug":"软件工程","permalink":"http://www.cvblogs.cn/categories/软件工程/"}],"tags":[{"name":"实验报告","slug":"实验报告","permalink":"http://www.cvblogs.cn/tags/实验报告/"}]},{"title":"读书笔记:吴福朝《计算机视觉中的数学方法》","slug":"maths-in-CV","date":"2017-09-09T13:39:26.000Z","updated":"2017-09-09T16:21:15.000Z","comments":true,"path":"2017/09/09/maths-in-CV/","link":"","permalink":"http://www.cvblogs.cn/2017/09/09/maths-in-CV/","excerpt":"前言&emsp;&emsp;已经看完这本书的前两篇的内容，第三篇是关于”模型估计”的。本书在网上直接搜索书名即可找到公开的资源以供下载。本文也在文末提供了免费的资源下载链接。","text":"前言&emsp;&emsp;已经看完这本书的前两篇的内容，第三篇是关于”模型估计”的。本书在网上直接搜索书名即可找到公开的资源以供下载。本文也在文末提供了免费的资源下载链接。 内容有感&emsp;&emsp;老实说，我是绝望的。数学基础实在太差了。过程中，一度放弃，靠着毅力以及skip reading才翻完前两篇的内容。笔记做了20几页。在FoxitReader上，这本书也被我圈圈画画的不成样子。可是不知道怎么回事，感觉自己真的是学不透它的概念啊… 《射影几何》篇&emsp;&emsp;本篇的内容可以说是做计算机视觉最基础的理论了，必须掌握的内容。期间，提到一个自标定理论，遥遥记得自己当初选择这个专业就是想做一款假延时的拍照应用，这么多年过去了，我一直以为自己要实现的就是摄像机的标定(至少基础算法应该要是这个)，可是读了此章内容才发现并不是这么回事。还记得读到: “所谓自标定，是指仅从埸景的多幅图像来确定摄像机内参数，这种方法不需精密加工的标定块。” 的时候，我整个人都是崩溃的。期间又想到自己毕设究竟想做什么，是做一个服务东大课堂的应用还是实现自己一直想实现的这个idea(虽然能想见后者的困难度：好似一个连自己都不懂需求是什么的产品经理告诉手下的码农，我的需求可能是这个云云。不幸的是，我自己恰恰又是那个苦逼的实现者…)&emsp;&emsp;本篇的内容，在阅读过程中，也发现了，自己在学习UCF课程的时候，压根其实就没有听懂人家背后的数学知识。读本篇内容时常让我有种：哦，原来教授的意思是这个不是那个啊…后期还需要反复咀嚼一二。 《矩阵张量》篇&emsp;&emsp;吴教授的书的章节命名很对一个强迫症患者的口味。本篇的内容前半部分讲矩阵，后半部分讲张量。前半部分的矩阵中所说的各种矩阵分解的方法，其中的奇异值分解(因为数学不好，总觉得这些专有名词很吓人，阅读之下，发现也就那么回事。)不过，我知道要做到真正的理解和消化为我所用还是需要仔细的品味阅读的。至于后半部分所提到的张量则是让我大开眼界！虽然没有佐证，但我猜：Google的Tensorflow估计就是基于这个Tensor(张量)而来！How amazing!有种感觉，又距离想要知道的内容更近一步了！= = 资源链接计算机视觉中的数学方法(吴福朝) 结束语&emsp;&emsp;这本书的确值得一读，但我想，如果在我大三甚者更早之前能够接触到了解到这本书，我的理解能有我现在多吗？就好像我之前的每次尝试，似乎总是失败的收尾。就好像即使某种意义上，我完成了UCF的CV网课，但我依旧对自己是否真正掌握这些知识心虚不已…但是，可以肯定的是，这本书在以后读来(预计下个月重读)，将又会有很多的收获。期待下回能够补充更读到的属于自己的更专业的关于本书的解读！ &emsp;&emsp;革命尚未成功，同志还需努力。","categories":[{"name":"图像处理","slug":"图像处理","permalink":"http://www.cvblogs.cn/categories/图像处理/"}],"tags":[{"name":"数学基础","slug":"数学基础","permalink":"http://www.cvblogs.cn/tags/数学基础/"}]},{"title":"机器学习相关基础名词：有监督、半监督、无监督","slug":"machine-learning-basic1","date":"2017-09-05T15:06:27.000Z","updated":"2017-09-09T16:16:42.000Z","comments":true,"path":"2017/09/05/machine-learning-basic1/","link":"","permalink":"http://www.cvblogs.cn/2017/09/05/machine-learning-basic1/","excerpt":"前言&emsp;&emsp;学习机器学习有几周了…也了解了一些基础名词，梳理以下，下回再有人逼叨逼的也不懵了。","text":"前言&emsp;&emsp;学习机器学习有几周了…也了解了一些基础名词，梳理以下，下回再有人逼叨逼的也不懵了。 基础概念有监督&emsp;&emsp;样本带有标签的训练集合。通常特征维度为$n+1$，因为特征向量中，多出来的一维表示的是样本标签。 半监督&emsp;&emsp;有监督与无监督的折衷，当我们在用机器学习算法学习一个函数(模型)去拟合数据集的时候，数据集大多数情况下并不理想。毕竟人工标注的成本太高，而我们的数据集通常情况下是很大的。与其毫无”目的”的学习，这时候我们让部分未标注的数据集合充作训练集合进行训练。学习得到的模型效果会更好些。 无监督&emsp;&emsp;训练样本不带有标签的训练集合作为输入的学习算法。如：聚类问题 其它分类器(Classifier)&emsp;&emsp;问题的输出只有一个。要么是要么不是。 回归&emsp;&emsp;分为线性回归、逻辑回归(修正线性回归带来的过拟合问题)。问题的输出是线性的，可能是可能不是。可以进行多分类。 神经网络&emsp;&emsp;参考神经元模型设计：输入层，隐藏层(可以有多层)，输出层。与字典学习作为机器学习的两大分支。 字典学习&emsp;&emsp;将训练集合的特征提取，集合成一个码本进行表示。与神经网络同属于复杂模型学习方法。 稀疏表示&emsp;&emsp;通常情况下，我们的特征的维数很大。这就带来一个问题：计算量的提高。为了平衡算法的时间效率。需要将特征降维后，稀疏表示。如KSVD算法就是将特征矩阵进行奇异值分解得到降维后的特征矩阵进行表示。 推荐学习材料 周志华《机器学习》 斯坦福大学吴恩达《机器学习入门》 台湾大学李宏毅《机器学习入门》 结束语&emsp;&emsp;看着这些概念解释，在想还是写代码比较好些…太水了…说了一堆废话。图个心安。推荐的材料太懒了，链接暂时不放了。自己一搜就有，实在找不到底下评论吧。总结来说，还是自己实践太少。即使大四琐事还是一堆(可能和自己太懒以及太笨有关系。羡慕那些脑瓜好使的人。以及动手能力很强的人。)","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://www.cvblogs.cn/categories/机器学习/"}],"tags":[{"name":"基础概念","slug":"基础概念","permalink":"http://www.cvblogs.cn/tags/基础概念/"}]},{"title":"UCF-CV课程总结:边缘检测","slug":"UCF-CVClass-Summary1","date":"2017-09-04T11:50:56.000Z","updated":"2017-09-05T15:48:24.000Z","comments":true,"path":"2017/09/04/UCF-CVClass-Summary1/","link":"","permalink":"http://www.cvblogs.cn/2017/09/04/UCF-CVClass-Summary1/","excerpt":"前言&emsp;&emsp;这篇博文是本人学习UCF计算机视觉公开课的课程知识梳理系列文章的第二篇。本篇博文主要介绍边缘检测章节的内容。","text":"前言&emsp;&emsp;这篇博文是本人学习UCF计算机视觉公开课的课程知识梳理系列文章的第二篇。本篇博文主要介绍边缘检测章节的内容。 课程内容相关先导知识&emsp;&emsp;边缘一般是指图像在某一局部强度剧烈变化的区域。强度变化一般有两种情况(横轴表示空间变化，纵轴表示灰度变化，虚线表示边缘)：&emsp;&emsp;&emsp;&emsp;边缘检测的任务：找到具有阶跃变化或者屋顶变化的像素点的集合。&emsp;&emsp;最直观的想法就是求微分。 对于第一种情况：一阶微分的峰值为边缘点，二阶微分的零点为边缘点。 对于第二种情况：一阶微分的零点为边缘点，二阶微分的峰值为边缘点。 &emsp;&emsp;一般可将边缘分为水平边缘、垂直边缘和对角线边缘。&emsp;&emsp;由于边缘检测的算法主要是基于图像强度(采用差分的方法来进行计算)的一阶和二阶导数。&emsp;&emsp;但导数通常对噪声敏感，因此必须采用滤波器来改善与噪声有关的边缘检测器的性能。常见的滤波方法主要有高斯滤波，即采用离散化的高斯函数产生一组归一化的高斯核。 一般边缘检测过程&emsp;&emsp;1. 滤波：改善与噪声有关的边缘检测器的性能&emsp;&emsp;2. 增强：将图像灰度点邻域强度值有显著变化的点凸显出来(可通过计算梯度幅值来确定)&emsp;&emsp;3. 检测：常用的方法是通过阈值化方法来检测 边缘检测器介绍(Edge Detector)&emsp;&emsp;课程中讲述到的检测器包括：&emsp;&emsp; Prewitt and Sobel Edge Detector&emsp;&emsp;属于离散微分算子 (discrete differentiation operator)。利用差分求出$x,y$方向上的梯度，求解梯度的大小，阈值化梯度的大小找到边缘。 Prewitt算子&emsp;&emsp;结合了差分运算与邻域平均的方法。其卷积模板如下： Sobel算子&emsp;&emsp;与prewitt算子类似，但考虑到了相邻不同像素点的影响程度是不同的，所以采用加权平均。 Marr Hildreth Edge Detector-LoG&emsp;&emsp;基本步骤： 用高斯器滤波原图像去除噪声 拉普拉斯滤波后的图像(求$x,y$二阶导) 找到零点(边缘点)，重复步骤2直到全部找到 &emsp;&emsp;laplacian算子是一些使用二阶微分的算子，实际上就是梯度的散度(可以利用DoG近似求解LoG降低算法时间复杂度的数量级?可以增强对比度！)LoG计算：不同计算方法，时间复杂度不同 一个2D laplacian算子(n{2}) 四个1D的算子组合而成(4n) &emsp;&emsp;由于 Laplacian使用了图像梯度，它内部的代码其实是调用了 Sobel 算子的 Canny&emsp;&emsp;是一种求最优边缘检测的一套方法。是一种先平滑再求导的方法。&emsp;&emsp;最优边缘检测的三个主要评价标准： 低错误率: 标识出尽可能多的实际边缘，同时尽可能的减少噪声产生的误报。 高定位性: 标识出的边缘要与图像中的实际边缘尽可能接近。 最小响应: 图像中的边缘只能标识一次，并且可能存在的图像噪声不应标识为边缘。 &emsp;&emsp;特别注意第4步！排除非边缘像素， 仅仅保留了一些细线条(候选边缘). 程序实现1234567891011121314151617181920212223242526i = imread('lena.png');%读入原图像A = fspecial('gaussian');%高斯滤波器i = filter2(A, i) / 255;%高斯滤波并归一化(/255)figure;imshow(i);%显示图像imwrite(i,'lena_0.jpg');%保存图像%prewitt方法a = edge(i, 'prewitt');figure;imshow(a);imwrite(a,'lena_1.jpg');%sobel方法a = edge(i, 'sobel');figure;imshow(a);imwrite(a,'lena_2.jpg');%marr hildreth方法(LoG)a = edge(i, 'log');figure;imshow(a);imwrite(a,'lena_3.jpg');%canny方法a = edge(i, 'canny');figure;imshow(a);imwrite(a,'lena_4.jpg'); 引用 边缘检测算法 【OpenCV入门教程之十二】OpenCV边缘检测：Canny算子,Sobel算子,Laplace算子,Scharr滤波器合辑 结束语&emsp;&emsp;一如既往，写文章对于我真的是一件万分困难的事情，基本上只能达到通顺的要求。翻来覆去也就只能用那几个markdown语法。排版也不甚美观。但我相信，坚持下去，总有一天，我能写出自己的内容。","categories":[{"name":"计算机视觉","slug":"计算机视觉","permalink":"http://www.cvblogs.cn/categories/计算机视觉/"}],"tags":[{"name":"课程总结","slug":"课程总结","permalink":"http://www.cvblogs.cn/tags/课程总结/"}]},{"title":"UCF-CV课程总结:概述、滤波及Matlab使用","slug":"UCF-CVClass-Summary","date":"2017-09-01T09:20:40.000Z","updated":"2017-09-05T15:48:24.000Z","comments":true,"path":"2017/09/01/UCF-CVClass-Summary/","link":"","permalink":"http://www.cvblogs.cn/2017/09/01/UCF-CVClass-Summary/","excerpt":"前言&emsp;&emsp;从八月开始，断断续续学习这门课程。从一开始Coursera上乔治亚理工的CV课和CP课继而到UCF的CV课。算是入门了这门课程，为以后的研究工作打下了一些基础。虽然，我的数学基础在很大程度上限制着我的吸收消化。但是，始终相信，有志者事竟成这个道理。&emsp;&emsp;课程资源地址：UCF-CAP 5415 - Computer Vision学习过程中，可以参照课程日程表安排学习时间。适当的加强强度。(由于时间问题，本人只完成了小部分实验…最好还是要做做实验的。)","text":"前言&emsp;&emsp;从八月开始，断断续续学习这门课程。从一开始Coursera上乔治亚理工的CV课和CP课继而到UCF的CV课。算是入门了这门课程，为以后的研究工作打下了一些基础。虽然，我的数学基础在很大程度上限制着我的吸收消化。但是，始终相信，有志者事竟成这个道理。&emsp;&emsp;课程资源地址：UCF-CAP 5415 - Computer Vision学习过程中，可以参照课程日程表安排学习时间。适当的加强强度。(由于时间问题，本人只完成了小部分实验…最好还是要做做实验的。) &emsp;&emsp;虽然在onenote上针对每节课都已经做了笔记，但是发现，自己只是将教授PPT中的内容摘抄了出来。这里借助博客简单梳理一下这门课中学习到的内容(事实上，其中的每一课都值得另起一篇去详细介绍)，顺便提升自己的写作能力总结能力。&emsp;&emsp;我发现，本文的长度大大超过了预期。因此，基于”2-8准则”(实则我实在无法做到一小时完成这个工作)，计划每篇此类总结文章以两到三课为一篇文章去总结课程内容。 课程内容&emsp;&emsp;整门课内容设计较为合理，作为重实现轻理论(少数学细节推导，乔治亚理工的课程较侧重于数学细节)大军中的一员，接受度良好。在课程主页上还有参考资料(免费，开放下载)以及CV领域的顶刊顶会的官网链接等信息。 Lecture1 CVIntroduction&emsp;&emsp;第一课是关于计算机视觉中基础知识的介绍以及整个课程会接触到的内容的学习。了解计算机视觉所研究的是从二维图像中得到三维世界的语意信息。&emsp;&emsp;在这个过程中，常常将图像当作一个函数$f(x,y)$,它是一个离散的关于像素点的函数。常用一个矩阵表示一张图像，其元素是0(黑)～255(白)的灰度值。分辨率则是由图像的像素长宽确定(屏幕的分辨率通常是固定的，但是可以向下调整，分辨率越高图像越细腻)。还介绍了图片的格式(不同的格式只是压缩编码的方式不同)。也介绍了视频的基本属性。依照人眼的构造，视频帧数每秒30帧就可以达到流畅的基本要求。&emsp;&emsp;现今的射影设备都是基于孔洞模型(Pin Hole)进行射影变换。&emsp;&emsp;三维空间中的点$(x,y,z)$通过镜片投影到图像平面上的点$(x,y)$&emsp;&emsp;由以上这个模型，我们就很容易想到：应该如何通过二维图像恢复被摄物体在三维世界中的几何信息呢？&emsp;&emsp;这里不再细展开。以及，CV的应用有哪些：&emsp;&emsp;作为基础知识的简单入门，第一节课还是很不错的。至少罗列的那些应用光是看那些演示视频，想到自己也有机会去实现。光想想就能振奋人心。 Lecture2 Filtering&emsp;&emsp;第二节课是CV领域最最基础的一个概念–滤波(Filtering)。我的第一篇博文整理的就是关于滤波操作的知识(虽然大部分是copy的别人的总结…)。&emsp;&emsp;首先，当你拿到一张图像，一定要区分清楚它究竟是:1.二值的(Binary)、2.灰度的(Gray Scale)还是3.彩色的(Color)。&emsp;&emsp;1.二值图像矩阵元素要么是0要么是1&emsp;&emsp;2.灰度图像，Scale范围通常(0~255)&emsp;&emsp;3.彩色图像较为复杂，通常在RGB空间下分为3个通道(R-Red、G-Green、B-Blue)&emsp;&emsp;因为这些值元素的存在，引入一个图像直方图去直观描述它的比重信息。&emsp;&emsp;&emsp;&emsp;由于各种内外界不稳定因素的干扰，图像并不总是”干净”的,总是有这样那样的噪声(通常高频信息是噪声-变化明显，变现的特征就是高频信息)。噪声叠加原图像得到被污染后的图像。(高斯噪声即噪声的分布符合高斯分布！)&emsp;&emsp;&emsp;&emsp;接着为引入滤波的概念，介绍了基本的数学运算：求导(Derivative，包括连续的和离散的即查分：向前、向后、中心，接着从一维引申到二维（图像是一个二维矩阵），接着提到了相关(Correlation)以及卷积(Convolution))以及求均值(Average/Mean)。&emsp;&emsp;并且，还提到了掩膜(Mask)的概念。&emsp;&emsp;高斯分布的重要意义：&emsp;&emsp;&emsp;&emsp;由于之前的文章已经梳理过，这里不再赘述。第二节结束。目前，我们已经了解了一些基本知识和基本运算(Matlab由库函数实现，推荐使用。) Matlab Tutorial&emsp;&emsp;作为课程的辅助章节，本节内容介绍Matlab的基本使用，作为Matlab的简单入门还是很有必要学习的。助教教授的内容都很实用。(对于没有接触过Matlab的人来说，通过学习本节可以完成基本编程任务。推荐观看。另外，斯坦福的吴恩达教授也在其机器学习视频中教授过Matlab的简单操作使用。也可以参考学习。) 结束语&emsp;&emsp;写博客真是一项锻炼能力的活，花了一个半小时才写完两节课的简单梳理总结。这进度我也是醉了！看来，以后应该利用碎片化的闲暇时间一点点完成。否则太占用学习时间了！","categories":[{"name":"计算机视觉","slug":"计算机视觉","permalink":"http://www.cvblogs.cn/categories/计算机视觉/"}],"tags":[{"name":"课程总结","slug":"课程总结","permalink":"http://www.cvblogs.cn/tags/课程总结/"}]},{"title":"图像处理基础-滤波(filtering)","slug":"image-processing-operation1","date":"2017-08-11T11:39:53.000Z","updated":"2017-09-05T15:48:24.000Z","comments":true,"path":"2017/08/11/image-processing-operation1/","link":"","permalink":"http://www.cvblogs.cn/2017/08/11/image-processing-operation1/","excerpt":"","text":"前言&emsp;&emsp;本文介绍图像处理基础知识滤波(filtering)相关知识。在图像处理中，你经常能够看到它的身影。对于学习图像处理，理解滤波背后的数学知识非常重要。 &emsp;&emsp;滤波分为基于空间域滤波(spatial filtering)与基于频率域滤波(frequency filtering)。二者的目的都是为了改善图像质量。篇幅有限，此篇文章先介绍空间滤波。 空间滤波(Spatial Filtering)&emsp;&emsp;空间滤波操作有时候也被叫做卷积滤波，或者干脆叫卷积(convolution)(离散的卷积，不是微积分里连续的卷积);常常需要用一个滤波器(filter)做空间滤波操作;滤波器也有很多名字:卷积模版(template)、卷积核(kernel)、掩模(mask)、窗口(window)等。 &emsp;&emsp;空间滤波可以分为线性滤波(linear filter)和非线性滤波(non-linear filter)。非线性滤波常见的有中值滤波、最大值滤波等，相当于自定义一个函数，在数学上由于不满足线性变换因此叫做非线性滤波。这里不细研究它。 &emsp;&emsp;线性滤波通常是：将模版覆盖区域内的元素，以模版中对应位置元素为权值，进行累加。与卷积操作类似的，还有一种数学操作叫做协相关(cross-correlatioin)，它们都可以看作是基于矩阵内积的操作。具有平移不变性(shift-invariant)。 &emsp;&emsp;二者的区别：卷积和协相关的差别是，卷积需要先对滤波矩阵进行180度的翻转，但如果矩阵是对称的，那么两者就没有什么差别了。实际上，在信号处理领域，卷积有广泛的意义，而且有其严格的数学定义，但在这里不关注这个。2D卷积需要4个嵌套循环(4-double loop)，所以它并不快，除非我们使用很小的卷积核。这里一般使用3x3或者5x5。而且，对于滤波器，也有一定的规则要求： 1）滤波器的大小应该是奇数，这样它才有一个中心，例如3x3，5x5或者7x7。有中心了，也有了半径的称呼，例如5x5大小的核的半径就是2。 2）滤波器矩阵所有的元素之和应该要等于1，这是为了保证滤波前后图像的亮度保持不变。当然了，这不是硬性要求了。 3）如果滤波器矩阵所有元素之和大于1，那么滤波后的图像就会比原图像更亮，反之，如果小于1，那么得到的图像就会变暗。如果和为0，图像不会变黑，但也会非常暗。 4）对于滤波后的结构，可能会出现负数或者大于255的数值。对这种情况，我们将他们直接截断到0和255之间即可。对于负数，也可以取绝对值。 卷积核(Convolution Kernel)&emsp;&emsp;定义不同的卷积核与原图像做卷积操作，可以产生不同的效果。滤波与模糊的概念区分。模糊是人为感受到的现象，通过滤波操作可以呈现。 什么都不做&emsp;&emsp;滤波器矩阵所有元素之和为1，保证滤波前后图像的亮度保持不变。这个滤波器啥也没有做，得到的图像和原图是一样的。因为只有中心点的值是1。邻域点的权值都是0，对滤波后的取值没有任何影响。 图像锐化滤波器(Sharpness Filter)&emsp;&emsp;图像的锐化和边缘检测很像，首先找到边缘，然后把边缘加到原来的图像上面，这样就强化了图像的边缘，使图像看起来更加锐利了。这两者操作统一起来就是锐化滤波器了，也就是在边缘检测滤波器的基础上，再在中心的位置加1，这样滤波后的图像就会和原始的图像具有同样的亮度了，但是会更加锐利。 &emsp;&emsp;我们把核加大，就可以得到更加精细的锐化效果 &emsp;&emsp;下面的滤波器会更强调边缘。 &emsp;&emsp;主要是强调图像的细节。最简单的3x3的锐化滤波器如下： &emsp;&emsp;实际上是计算当前点和周围点的差别，然后将这个差别加到原来的位置上。另外，中间点的权值要比所有的权值和大于1，意味着这个像素要保持原来的值。 边缘检测(Edge Detection)&emsp;&emsp;我们要找水平的边缘：需要注意的是，这里矩阵的元素和是0，所以滤波后的图像会很暗，只有边缘的地方是有亮度的。 &emsp;&emsp;相当于做差分(differencing)，求导的离散版本，有向前差分(forward differencing)，向后差分(backward differencing)，中心差分(central differencing)。 &emsp;&emsp;下面的滤波器可以找到垂直方向的边缘，这里像素上和下的像素值都使用 &emsp;&emsp;再下面这个滤波器可以找到45度的边缘：取-2不为了什么，只是为了让矩阵的元素和为0而已。 &emsp;&emsp;那下面这个滤波器就可以检测所有方向的边缘。 &emsp;&emsp;为了检测边缘，我们需要在图像对应的方向计算梯度。用下面的卷积核来卷积图像，就可以了。但在实际中，这种简单的方法会把噪声也放大了。另外，需要注意的是，矩阵所有的值加起来要是0。 浮雕(Embossing Filter)&emsp;&emsp;浮雕滤波器可以给图像一种3D阴影的效果。只要将中心一边的像素减去另一边的像素就可以了。这时候，像素值有可能是负数，我们将负数当成阴影，将正数当成光，然后我们对结果图像加上128的偏移。这时候，图像大部分就变成灰色了。 &emsp;&emsp;下面是45度的浮雕滤波器 &emsp;&emsp;只要加大滤波器，就可以得到更加夸张的效果了 均值模糊(Box Filter/Averaging)&emsp;&emsp;我们可以将当前像素和它的四邻域的像素一起取平均，然后再除以5，或者直接在滤波器的5个地方取0.2的值即可，如下图 &emsp;&emsp;可以看到，这个模糊还是比较温柔的，我们可以把滤波器变大，这样就会变得粗暴了：注意要将和再除以13. &emsp;&emsp;如果你想要更模糊的效果，加大滤波器的大小即可。或者对图像应用多次模糊也可以。 高斯模糊(Gaussian Filter)&emsp;&emsp;均值模糊很简单，但不是很平滑。高斯模糊就有这个优点，所以被广泛用在图像降噪上。特别是在边缘检测之前，都会用来移除细节。高斯滤波器是一个低通滤波器。 运动模糊(Motion Blur)&emsp;&emsp;运动模糊可以通过只在一个方向模糊达到，例如下面9x9的运动模糊滤波器。注意，求和结果要除以9。 &emsp;&emsp;这个效果就好像，摄像机是从左上角移动的右下角。 自己手写的卷积函数虽然Matlab已经封装了一个函数con2()作卷积操作，但是还是要自己手写一下加深理解。下面是UCF计算机视觉网课的作业。4层循环。因为边缘效应通常情况下需要补0。还是Matlab新手，代码一点都不elegant，没有借鉴意义。1234567891011121314151617function [] = pa1()m_img = imread('PA1/balloon.jpg');m_kernel = rand(5,5);[r1, c1, cc1] = size(m_img);[r2, c2] = size(m_kernel);for i = r2+1:r1 for j = c2+1:c1 sump = 0; for k = 1:r2 for l = 1:c2 sump = m_img(i-k, j-l) * m_kernel(k,l); end; end; outQ(i,j) = sump; end;endimshow(outQ);wait(0); Matlab中用imfilter()实现线性空间滤波&emsp;&emsp;最常用的是这句：1imfilter(f, w, 'replicate') %相关滤波，默认边界外围填充0，造成黑边，使用'replicate'复制边缘像素，消除边缘效应，输出大小与输入图像f相同. &emsp;&emsp;imfilter()默认是相关算子，在做真正的卷积之前可以先将核旋转180°(除非你指定了滤波模式为’conv’)，rotated_filter=flipud(fliplr(filter))1234567891011121314imfilter(f, w, filtering_mode, boundary_options, size_options)f:图像w:滤波模版filtering_mode:滤波模式 &apos;corr&apos;:相关滤波。[默认值] &apos;conv&apos;:卷积滤波。boundary_options:边界选项 P:(没有引号)边界外围补充0。[默认值] &apos;replicate&apos;:边界外围复制边界值 &apos;symmetric&apos;:边界外围使用边界镜像 &apos;circular&apos;:图像的大小通过讲图像处理为二维周期函数的一个周期来扩展（这是什么？）size_options:大小选项 &apos;same&apos;:输出大小与输入图像f大小相同。[默认值] &apos;full&apos;:输出与扩展（填充）后的图像大小相同。 总结 规范用语，在滑窗操作、计算图像梯度等场合，不要使用“卷积”，而要使用“滤波”或者“协相关”。因为，我们通常讲的卷积，在这几个操作中其实是协相关，那就不要用卷积这个词以避免引起混淆。 不同的滤波器产生的效果不同，滤波器的定义有讲究。经常会看到一些人名命名的算子。比如用作边缘检测，拉普拉斯(Laplacian)算子、Canny算子。观察它们的算子内容，结合卷积核的定义规则。你会发现其实就那么回事。不要被复杂的学术名词给弄懵逼了。 GPU实现代替CPU实现，CPU实现需要四重循环，时间代价太大，性能不好。GPU使用特定的数据结构直接进行计算降低时间代价。 这是我的第一篇博文，本来是想好好写的，发现写博文真的是一项技术活。话到嘴边，憋不出一个字。 参考引用 图像卷积与滤波的一些知识点 图像卷积、相关以及在MATLAB中的操作","categories":[{"name":"图像处理","slug":"图像处理","permalink":"http://www.cvblogs.cn/categories/图像处理/"}],"tags":[{"name":"数学基础","slug":"数学基础","permalink":"http://www.cvblogs.cn/tags/数学基础/"}]},{"title":"开发测试","slug":"hello-world","date":"2017-08-05T11:11:50.000Z","updated":"2017-08-13T19:08:00.000Z","comments":true,"path":"2017/08/05/hello-world/","link":"","permalink":"http://www.cvblogs.cn/2017/08/05/hello-world/","excerpt":"","text":"博客正在完善中&emsp;&emsp;稍安勿躁","categories":[{"name":"网页开发","slug":"网页开发","permalink":"http://www.cvblogs.cn/categories/网页开发/"}],"tags":[{"name":"测试","slug":"测试","permalink":"http://www.cvblogs.cn/tags/测试/"}]}]}