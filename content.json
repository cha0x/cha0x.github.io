{"meta":{"title":"CVBlogs","subtitle":null,"description":"developing..","author":"Zhong Qin","url":"http://www.cvblogs.cn"},"pages":[{"title":"categories","date":"2017-08-13T09:19:54.000Z","updated":"2017-08-13T09:20:30.000Z","comments":false,"path":"categories/index.html","permalink":"http://www.cvblogs.cn/categories/index.html","excerpt":"","text":""},{"title":"","date":"2017-08-13T09:23:33.000Z","updated":"2017-08-13T19:11:55.000Z","comments":true,"path":"about/index.html","permalink":"http://www.cvblogs.cn/about/index.html","excerpt":"","text":"Talk is cheap.Show me the code. Linus Torvaldsdeveloper of the Linux kernel"},{"title":"tags","date":"2017-08-13T09:16:20.000Z","updated":"2017-08-13T09:18:58.000Z","comments":true,"path":"tags/index.html","permalink":"http://www.cvblogs.cn/tags/index.html","excerpt":"","text":""},{"title":"","date":"2017-08-13T18:52:05.000Z","updated":"2017-08-13T18:52:05.000Z","comments":false,"path":"about/index/amazingdots.html","permalink":"http://www.cvblogs.cn/about/index/amazingdots.html","excerpt":"","text":"CVBlogs html, body { background: #fff; margin: 0; padding:0;} canvas { width: 100%; height: 100%; position: absolute; } $(function(){ var canvas = document.querySelector('canvas'), ctx = canvas.getContext('2d') canvas.width = window.innerWidth; canvas.height = window.innerHeight; ctx.lineWidth = .3; ctx.strokeStyle = (new Color(150)).style; var mousePosition = { x: 30 * canvas.width / 100, y: 30 * canvas.height / 100 }; var dots = { nb: 150, distance: 50, d_radius: 100, array: [] }; function colorValue(min) { return Math.floor(Math.random() * 255 + min); } function createColorStyle(r,g,b) { return 'rgba(' + r + ',' + g + ',' + b + ', 0.8)'; } function mixComponents(comp1, weight1, comp2, weight2) { return (comp1 * weight1 + comp2 * weight2) / (weight1 + weight2); } function averageColorStyles(dot1, dot2) { var color1 = dot1.color, color2 = dot2.color; var r = mixComponents(color1.r, dot1.radius, color2.r, dot2.radius), g = mixComponents(color1.g, dot1.radius, color2.g, dot2.radius), b = mixComponents(color1.b, dot1.radius, color2.b, dot2.radius); return createColorStyle(Math.floor(r), Math.floor(g), Math.floor(b)); } function Color(min) { min = min || 0; this.r = colorValue(min); this.g = colorValue(min); this.b = colorValue(min); this.style = createColorStyle(this.r, this.g, this.b); } function Dot(){ this.x = Math.random() * canvas.width; this.y = Math.random() * canvas.height; this.vx = -.5 + Math.random(); this.vy = -.5 + Math.random(); this.radius = Math.random() * 2; this.color = new Color(); console.log(this); } Dot.prototype = { draw: function(){ ctx.beginPath(); ctx.fillStyle = this.color.style; ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2, false); ctx.fill(); } }; function createDots(){ for(i = 0; i < dots.nb; i++){ dots.array.push(new Dot()); } } function moveDots() { for(i = 0; i < dots.nb; i++){ var dot = dots.array[i]; if(dot.y < 0 || dot.y > canvas.height){ dot.vx = dot.vx; dot.vy = - dot.vy; } else if(dot.x < 0 || dot.x > canvas.width){ dot.vx = - dot.vx; dot.vy = dot.vy; } dot.x += dot.vx; dot.y += dot.vy; } } function connectDots() { for(i = 0; i < dots.nb; i++){ for(j = 0; j < dots.nb; j++){ i_dot = dots.array[i]; j_dot = dots.array[j]; if((i_dot.x - j_dot.x) < dots.distance && (i_dot.y - j_dot.y) < dots.distance && (i_dot.x - j_dot.x) > - dots.distance && (i_dot.y - j_dot.y) > - dots.distance){ if((i_dot.x - mousePosition.x) < dots.d_radius && (i_dot.y - mousePosition.y) < dots.d_radius && (i_dot.x - mousePosition.x) > - dots.d_radius && (i_dot.y - mousePosition.y) > - dots.d_radius){ ctx.beginPath(); ctx.strokeStyle = averageColorStyles(i_dot, j_dot); ctx.moveTo(i_dot.x, i_dot.y); ctx.lineTo(j_dot.x, j_dot.y); ctx.stroke(); ctx.closePath(); } } } } } function drawDots() { for(i = 0; i < dots.nb; i++){ var dot = dots.array[i]; dot.draw(); } } function animateDots() { ctx.clearRect(0, 0, canvas.width, canvas.height); moveDots(); connectDots(); drawDots(); requestAnimationFrame(animateDots); } $('canvas').on('mousemove', function(e){ mousePosition.x = e.pageX; mousePosition.y = e.pageY; }); $('canvas').on('mouseleave', function(e){ mousePosition.x = canvas.width / 2; mousePosition.y = canvas.height / 2; }); createDots(); requestAnimationFrame(animateDots); });"}],"posts":[{"title":"为什么张口闭口都先提贝叶斯和马尔可夫？","slug":"理论学习/为什么张口闭口贝叶斯和马尔可夫","date":"2017-12-30T12:51:45.000Z","updated":"2018-01-01T15:11:33.545Z","comments":true,"path":"2017/12/30/理论学习/为什么张口闭口贝叶斯和马尔可夫/","link":"","permalink":"http://www.cvblogs.cn/2017/12/30/理论学习/为什么张口闭口贝叶斯和马尔可夫/","excerpt":"前言作为一个机器学习萌新，体系结构还未完善的建立起来。在与大牛的交谈过程中，经常他们讨论一个问题的解决方案时候，经常能听到是用”贝叶斯网络”和”马尔可夫链”？。起始时非常不解，就我本人而言，似乎机器学习 == 神经网络（= =，JS中的双等）。因此每当别人提到这两个名词的时候内心都非常的疑惑，为什么要提这两个而不具体的讲到底是用了什么方法呢？直到最近又重新看了一遍西瓜书之后才重新审视了自己的偏见，也借着梳理的机会分享一下（大部分还是摘录笔记）。强烈建议自己看看西瓜书第7章和第14章。","text":"前言作为一个机器学习萌新，体系结构还未完善的建立起来。在与大牛的交谈过程中，经常他们讨论一个问题的解决方案时候，经常能听到是用”贝叶斯网络”和”马尔可夫链”？。起始时非常不解，就我本人而言，似乎机器学习 == 神经网络（= =，JS中的双等）。因此每当别人提到这两个名词的时候内心都非常的疑惑，为什么要提这两个而不具体的讲到底是用了什么方法呢？直到最近又重新看了一遍西瓜书之后才重新审视了自己的偏见，也借着梳理的机会分享一下（大部分还是摘录笔记）。强烈建议自己看看西瓜书第7章和第14章。 机器学习模型分几类？也许你也像我一样，目前似乎已经懂了一些机器学习的相关概念。例如什么是样本（测试、训练）以及标签，什么是特征或维度即与它们相关的一些专有名词（特征提取、降维等），什么是模型表示，什么是目标函数评价，什么是优化= =。以及对应的经典的算法的专有名词表示（例如：SVM、NN、CNN、RNN；MSE；SGD）。（好吧，似乎目前我学的最多的就是NN相关的一些内容…）忽略以上这些，一定要明白的大局观念就是：学习 = 表示 + 评价 + 优化可以梳理成下面这个表格： 表示 评价 优化 基于实例的方法 准确/错误比率 组合优化 近邻方法 精确率和召回率 贪心搜索 支持向量机 平方误差 柱搜索 超平面方法 似然(likelihood) 分支限界法 朴素贝叶斯 后验概率 连续优化 逻辑斯蒂回归 信息增益 无约束 决策树方法 K-L距离 梯度下降 规则集的方法 成本/效用 共轭梯度 命题规则 利润 拟牛顿法 逻辑程序 有约束 神经网络 线性规划 图模型 二次规划 贝叶斯网络 条件随机场 另外还有必要再确认一下机器学习模型到底分几类？传统的分类方式是按照训练数据集是否有标签分成：有监督（数据集带标签）、无监督（数据集不带标签）、半监督（大部分数据集不带标签少部分带标签）更具体的，却一般将其分成两种：生成式模型（Generative Model）与鉴别式模型（Discriminative Model），这两类也是贝叶斯和马尔可夫分别的代表，一个基于统计，一个基于概率。 生成式模型对于输入x，类别标签y，产生式模型估计它们的联合概率分布P(x,y)。产生式模型可以根据贝叶斯公式得到判别式模型，但反过来不行。 产生式模型常见的主要有： Gaussians Naive Bayes Mixtures of Multinomials Mixtures of Gaussians Mixtures of Experts HMMs（隐马尔可夫模型） Sigmoidal Belief Networks, Bayesian Networks Markov Random Fields Latent Dirichlet Allocation鉴别式模型对于输入x，类别标签y，判别式模型估计条件概率分布P(y|x)判别式模型常见的主要有 Logistic Regression SVM Traditional Neural Networks Nearest Neighbor CRF Linear Discriminant Analysis Boosting Linear Regression 结束语当我们打开任何一个机器学习的网络视频时，不论是AndrewNg还是李宏毅老师的视频，总是从最简单的线性分类器讲起。接着会讲到如何衡量一个机器学习算法的好坏？接着就是巴拉巴拉一堆数学理论。以至于每次我看完都总觉得：哇，这都讲了啥啊= =，这也就导致了至今为止尚未完全的能够理解这个过程对应的编码过程。毕竟Linus大神有言”Talk is cheap，show me the code”。与计算机专业相关的任何内容的学习最终都离不开需要编程实现。于是我至今都不认为自己已经入门机器学习。但是一方面，我似乎又学习了很长时间的理论。大有种”我要这铁棒有何用”的无奈= =。","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://www.cvblogs.cn/categories/机器学习/"}],"tags":[{"name":"基础概念","slug":"基础概念","permalink":"http://www.cvblogs.cn/tags/基础概念/"}]},{"title":"机器学习基础概念再梳理","slug":"理论学习/机器学习基础概念再梳理","date":"2017-12-28T15:35:45.000Z","updated":"2017-12-28T16:32:03.282Z","comments":true,"path":"2017/12/28/理论学习/机器学习基础概念再梳理/","link":"","permalink":"http://www.cvblogs.cn/2017/12/28/理论学习/机器学习基础概念再梳理/","excerpt":"前言最近真的是被毕设的东西搞疯了。一直以为自己遇到毕设的问题应该是非常容易的。没想到最终却是崩溃了…发现很多知识都不会，或者说根本就不理解。直到我找到了这篇文章，感觉自己瞬间被打通了任督二脉。不过还是推荐有一点经验的同学自己去看原文原文地址。接下来的内容只是我摘录的一些原文以及穿插个人的笔记。","text":"前言最近真的是被毕设的东西搞疯了。一直以为自己遇到毕设的问题应该是非常容易的。没想到最终却是崩溃了…发现很多知识都不会，或者说根本就不理解。直到我找到了这篇文章，感觉自己瞬间被打通了任督二脉。不过还是推荐有一点经验的同学自己去看原文原文地址。接下来的内容只是我摘录的一些原文以及穿插个人的笔记。 机器学习何谓学习？学习=表示+评价+优化 表示 评价 优化 基于实例的方法 准确/错误比率 组合优化 近邻方法 精确率和召回率 贪心搜索 支持向量机 平方误差 柱搜索 超平面方法 似然(likelihood) 分支限界法 朴素贝叶斯 后验概率 连续优化 逻辑斯蒂回归 信息增益 无约束 决策树方法 K-L距离 梯度下降 规则集的方法 成本/效用 共轭梯度 命题规则 利润 拟牛顿法 逻辑程序 有约束 神经网络 线性规划 图模型 二次规划 贝叶斯网络 条件随机场 泛化(Generalization)基本目标是对训练集合中样例的泛化。机器学习初学者最常犯的错误就是在训练数据上做测试，从而产生胜利的错觉。交叉验证（Cross Validation）将训练数据随机地等分为若干份，其中的每一份均可用做测试，而剩下的数据用作训练，然后将每个学习的分类器在它没见过的样例上进行测试，将测试结果取平均后，就可用来评价不同参数设置的性能。 过拟合（Overfitting）当你的分类器在训练数据上准确率为100%，而在测试数据上仅有50%的时候，说明这个分类器发生过拟合。常见误解是认为其由噪音造成的。一种理解过拟合的方式是将泛化误差分解为偏置（bias）和方差（variance）。偏置度量了学习器倾向于一直学习相同错误的程度。方差则度量了学习器倾向于忽略真实信号、学习随机食物的程度。 避免过拟合的方法交叉验证是一种方法。然而最常用的方法是对评价函数增加一个正则项（regularization term）。另外还有卡方测试等统计显著性检测。 欠拟合（Underfitting）为了避免过拟合（方差）时很容易陷入欠拟合（偏置）问题中。 维度灾难“非均匀性的祝福”可以抵消维度灾难。 特征工程现在经常采用的一种方式是先自动产生大量的候选特征，然后根据它们与分类类别的信息增益等方法来选取最好的特征。 大数据带来的问题可扩展性时间和内存的资源有限。作为一条规则，首先应该在logistics回归之前尝试朴素贝叶斯，在支持向量机之前先尝试近邻。 模型集成最简单的集成技术是bagging。另外还有一个是boosting。 结束语感觉自己对于学习时间的把控是自从十月答应和曹老师做医学影像以来就被浪费算起（感觉自己真的是疯了才会去学一些乱七八糟的：）。接着十一月去了公司实习，然后十二月的时候又执着于自己的一些事情。真的是感觉自己要炸了。留给毕设的时间真的是少的可怜。","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://www.cvblogs.cn/categories/机器学习/"}],"tags":[{"name":"基础概念","slug":"基础概念","permalink":"http://www.cvblogs.cn/tags/基础概念/"}]},{"title":"前端学习教程资源及经验分享","slug":"开发学习/web开发_教程学习经验分享","date":"2017-12-25T18:09:04.000Z","updated":"2017-12-26T10:47:39.759Z","comments":true,"path":"2017/12/26/开发学习/web开发_教程学习经验分享/","link":"","permalink":"http://www.cvblogs.cn/2017/12/26/开发学习/web开发_教程学习经验分享/","excerpt":"前言从八月心血来潮搭个人博客到从九月开始自己学习Web开发，老实说看了很多教程。从中学习到了很多。特别是通过一些项目得到了很大的锻炼。这里简单的对自己说学习过的教程资源做一个总结。","text":"前言从八月心血来潮搭个人博客到从九月开始自己学习Web开发，老实说看了很多教程。从中学习到了很多。特别是通过一些项目得到了很大的锻炼。这里简单的对自己说学习过的教程资源做一个总结。 学完Wes Bos大神的ES6 for EveryoneBilibili视频地址推荐指数：非常推荐之前一直对JavaScript并不是很上心，可能是和一开始的语言偏见有关。在学习和实践之后发现绕来绕去还是回到语法的学习。 Node Authentication Tutorial with Passport.jsBilibili视频地址推荐指数：非常推荐不建议一开始就学习这个。这个教程主要讲的是登陆验证。能让你明白Node中是如何组合Request、Response以及Session的运用。 Semantic UI In 60 MinutesBilibili视频地址虽然看完了但是感觉还是啥都没学会，也许是因为文档是英文的（虽然也有中文的文档，但是体验不好）。总觉得自己是没有掌握前段样式框架的学习套路导致的学习转换率太低了。 前端工程师必备的PS技能——切图篇慕课教程地址学习了一个很有用的工具！真的很有趣。不过作为偏后端编程的我们还是以后会少用= = 创业公司的Nodejs工程师慕课教程地址真正学习Node之前，建议学习一下这个课程，喝完鸡汤好上路：） 进击Node.js基础（一）慕课教程地址由于课程都较短，当时是一口气学完的，值得一学。 快乐的sublime编辑器慕课教程地址在学习前端课程中，会发现Sublime的出现率真的很高！这个教程算是不错的。 IntelliJ IDEA神器使用技巧慕课教程地址很值得学习的一门课，至少对于自己一直需要使用的IDE还是需要熟悉的。正所谓”工欲善其事必先利其器”。最关键的是教程是免费的。 Handlebars模板引擎慕课教程地址自己学习的第一个模版引擎，对于前后端分离的趋势。掌握一个模版引擎之后上手其他模版引擎真的非常快！ 一半或更少传智播客Node.jsBilibili视频地址课程时长：5Days老师讲的不错，讲的比较细致而全面，学完这个的话就能够掌握Node.js开发的核心所在了（如什么是异步编程以及模块的概念等）。特别重要的是如何Debug，之前有点不以为然，但是几天前，因为一直以来都没有debugger的习惯，导致使用console.log()异常痛苦实在是要了老血命了。但是当时也许是自己比较笨，或者是懒得学（教程实在是觉得很拖沓，总共有五天的教程量），大概就只是学了一点点。 传智播客AJAXBilibili视频地址课程时长：4Days同属于传智Web开发套餐，这个教程里学到了很重要的关于网络协议的一些理论知识。很形象。比起我校网络老师只会念PPT和讲自己的成年旧事不知道强到哪里去。但是因为实在是一些知识点讲的太细了，最终还是没能坚持下来。 传智播客JQueryBilibili视频地址课程时长：4Days基本上没怎么学，当时并不是很上心。不过看评价很不错。 Grunt-beginner前端自动化工具慕课教程地址记得当时学习这个是因为要修改一个hexo主题，但是最终也没有学会。作为自动化工具。Grunt似乎已经被Gulp拍死在了沙滩上… 淘沙在学Wes Bos - React For BeginnersBilibili视频地址课程时长：2.5h/29Lessons其实并不适合从零开始学习，还是需要从实践中找到自己去发现自己欠缺的地方，这样子回头再去学的话就能够有的放矢，学习效率也更高。 传智播客混合APP开发基础Bilibili视频地址课程时长：5Days老实说我就看了第一天的内容。 Redux-React TutorialBilibili视频地址关于React、Redux还是不是很熟悉 一点心得与体会初次接触Web开发（很惭愧，之前的大作业都是用的别人的代码，验收的时候，跑起来就OK，导致根本就没往心里去学。所以基本上可以说是从0开始的。其实在接触Web开发之前，我对写网页（特别是前端开发）抱有很大的偏见。总觉得其不过尔尔，但是真要我自己真的动手去做却又做不出来。我觉得这可能也是一部分人的傲慢与偏见。从一开始的HTML到CSS最后到最原始的JavaScript语法再到后来的Node.js以及React.js，学习过程中很多时候只是看视频里的人敲而已。真正自己写代码还是借着走项目的机会。从0开始自己一点点的实现内容。中间学习到了很多东西。有的时候还是挺有成就感的。但是当我的舍友让我向其展示我所做的内容我却感觉自己拿不出一个抓眼的东西。总觉得自己好像一直在coding，GitHub的主页颜色也好看。但是真正能够给别人看的项目却是少之又少。所以革命尚未成功，还需努力。虽然目前也只是学习了一个皮毛，却是想要借着空闲将我目前学习的Web开发过程中的一些教程资源做一个简单的汇总整理。也希望自己重新从里头再找找看当时因为各种原因弃坑的那些教程中有没有可以再学习的！因为老师们讲课一般较慢，建议学习的时候1.5X播放。","categories":[{"name":"网页开发","slug":"网页开发","permalink":"http://www.cvblogs.cn/categories/网页开发/"}],"tags":[{"name":"课程总结","slug":"课程总结","permalink":"http://www.cvblogs.cn/tags/课程总结/"}]},{"title":"mxnet之简单线性回归源码解读","slug":"开发学习/mxnet-简单线性回归源码解读","date":"2017-12-12T02:40:21.000Z","updated":"2017-12-12T04:36:49.789Z","comments":true,"path":"2017/12/12/开发学习/mxnet-简单线性回归源码解读/","link":"","permalink":"http://www.cvblogs.cn/2017/12/12/开发学习/mxnet-简单线性回归源码解读/","excerpt":"前言此篇博文相关：线性回归 — 使用Gluon中源码的解读。","text":"前言此篇博文相关：线性回归 — 使用Gluon中源码的解读。 源码及注释解析1234567891011121314151617181920212223242526272829# 设置迭代次数5次，每次迭代都完整取所有数据epochs = 5# 设置每次取数据的batch = 10，如例子中数据集是1000，则每次迭代都取100次数据，每次都取10个数据batch_size = 10# for循环迭代：共5次，range(epochs)模拟0，1，2，3，4for e in range(epochs): #每次迭代，初始的损失置为0 total_loss = 0 # 从data_iter迭代器中取数据，data_iter = gluon.data.Dataloader(dataset,batch_size,shuffle=True) # 上诉dataset = gluon.data.ArrayDataset(X,y)即由数据集X和其对应的标签y组成的数据集合 # 因此，data_iter迭代器每次取出的data和label即batch_size个数据集对：X'和y'，直到取完所有数据，结束循环（1000/10=100次） for data, label in data_iter: # 利用autograd.record()API自动记录梯度 with autograd.record(): # 输出等于将数据X传入你定义的模型net（可以这么理解：线性模型即是y'关于x的函数） output = net(data) # 这里定义的损失函数是衡量真值label与有你的模型产生的预测值之间的误差。此处使用的是均方误差，你也可以换成你自己定义的其他损失函数 loss = square_loss(output, label) # 反向传播误差，这里可以将这个动作看作是一个信号，损失反向了，但是真正利用损失反向传播的却是接下来的trainer loss.backward() # 传播了误差之后，我们还需要利用一些更新参数的方法对参数进行更新 # 注意这里使用的是gluon提供的API:gluon.Trainer(net.collect_params,'使用的更新模型参数的方法名：如随机梯度下降',&#123;指定的学习率learning_rate:0.1是一个字典&#125;) # 如：trainer = gluon.Trainer(net.collect_params(),'sgd', &#123;'learning_rate': 0.1&#125;) # 最后利用trainer.step(batch_size)API反向更新模型参数w,b trainer.step(batch_size) # 将每次训练的损失加入总损失（一共要加100次，直到迭代完成）。由于每次循环得到的是一个长度为batch_size的一维向量，但是总损失是标量。因此得利用asscalar()转化为标量进行操作 total_loss += nd.sum(loss).asscalar() # 打印出一次迭代的平均误差=总误差/样本数 print(\"Epoch %d, average loss: %f\" % (e, total_loss/num_examples)) 一些易混淆的名词模型定义可以这么通俗的理解：模型即是你定义的一个由数据集生成预测值的函数。在训练过程中，我们往模型中传入训练数据集得到的是一个预测值。我们无法知道这个预测值到底是对是错是好是坏。它只是单纯的对预测值的一个刻画。 损失函数那么我们如何描述我们的模型是好是坏呢？这里就必须引入损失这个概念。所谓损失，单纯来讲就是预测值与真实值之间的误差。理想情况下，我们希望我们的损失是0或者接近于0。 初始化模型参数其实当我们在说模型的时候，我们通常不能很完整的说出：我们的模型具体是什么（我在想这可能是由于我们维度限制了我们的想象力= =）。也就是大部分模型无法解释清楚的。不像线性模型：我们可以这么定义：$y^’=wx+b$，然后我们可以这么解释：例如，w是斜率而b是截距。但是对于一些非线性的模型，里头的参数不再具有可解释性质。因此，一般情况下，我们说我训练一个模型指的就是我训练了模型中的参数。例如：w和b就是我们通过训练线性模型得到的参数。但是，想象一下，最初的时候，我们手上只有一些数据，以及数据对应的标签（真实值）。还是以线性模型为例子：我们定义了一个模型$y^’=wx+b$(目前，在不对w和b初始化的情况下，这两个也是变量)。因此，我们的模型就有了三个变量。但是我们只希望在给模型传入一个数据x的时候得到的是一个预测值$y^’$。因此，我们就需要初始化我们的模型参数w和b。我们可以随机对其初始化，也可以指定一个参数（可能是从其他地方迁移学习过来的：其实就是按照数据集的关系的相似性，衡量照抄它的参数= =）。 模型参数更新策略（优化）现在，我们的模型中只剩下一个变量$y^’$，我们可以输入一个数据得到一个预测值。我们通过比较预测值和真实值得到损失。但是，我们要如何更新我们的参数使得我们的模型在每一次迭代完所有数据之后。根据损失，能够调整模型参数！实现利用数据编程！这里就有了反向传播以及随机梯度下降等的概念。反向传播传播的是损失（也叫残差），随机梯度中就是利用损失的反向梯度，往回走batch_size个样本损失的距离，使得参数得到更新。param[:] = param - lr * param.grad。这里lr就是学习率。这样在进行下一次循环（此时还是在一次迭代，100次循环里头）的时候，我们的参数能够有所改进，使模型更拟合真实数据。也就是说话我们共循环更新了5*1000/10=500次参数！ 结束语尽管不知道已经花了多少时间和精力取学习了多少机器学习相关的东西，但是感觉自己对于理论或者说这些专有名词，永远都不上心的样子。但是这样子真的是百害而无一利。直到我遇到了李沐老师团队的MXNet= =。决定一定要沉心静气学好理论并且动手实践！","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://www.cvblogs.cn/categories/机器学习/"}],"tags":[{"name":"MXNet","slug":"MXNet","permalink":"http://www.cvblogs.cn/tags/MXNet/"}]},{"title":"python之高级语言特性：切片","slug":"开发学习/python-高级语言特性","date":"2017-12-11T15:19:34.000Z","updated":"2017-12-12T04:39:54.535Z","comments":true,"path":"2017/12/11/开发学习/python-高级语言特性/","link":"","permalink":"http://www.cvblogs.cn/2017/12/11/开发学习/python-高级语言特性/","excerpt":"前言由于最近大都使用Python作为主要的开发语言，并且以后也将长期使用（用于编程科学计算相关的内容）等。决定还是好好学习一下python。以下内容是学习廖雪峰Python教程-切片的笔记梳理。","text":"前言由于最近大都使用Python作为主要的开发语言，并且以后也将长期使用（用于编程科学计算相关的内容）等。决定还是好好学习一下python。以下内容是学习廖雪峰Python教程-切片的笔记梳理。 切片对这种经常取指定索引范围的操作，用循环十分繁琐，因此，Python提供了切片（Slice）操作符，能大大简化这种操作。L[0:3]表示，从索引0开始取，直到索引3为止，但不包括索引3。即索引0，1，2，正好是3个元素。如果第一个索引是0，还可以省略：L[:3]类似的，既然Python支持L[-1]取倒数第一个元素，那么它同样支持倒数切片:L[-2:]。记住倒数第一个元素的索引是-1。什么都不写，只写[:]就可以原样复制一个listtuple也是一种list，唯一区别是tuple不可变。因此，tuple也可以用切片操作，只是操作的结果仍是tuple。Python没有针对字符串的截取函数，只需要切片一个操作就可以完成，非常简单。 小结切片利用的是[(起始位置，如果是0可以被省略):(切片结束位置，如果是全部可以被省略):(截取数据的步长，如果不指定，连同前面的:可以被省略)]。 多维数组的切片由于python不支持多维列表这一说（我们无法利用列表来模拟多维数组），因此我们得引入numpy进行转化。也是前几个冒号组成范围，最后一个冒号是步长。如果省略则为1。 引用链接Python 基础——range() 与 np.arange()http://old.sebug.net/paper/books/scipydoc/numpy_intro.html廖雪峰Python教程-切片","categories":[{"name":"网页开发","slug":"网页开发","permalink":"http://www.cvblogs.cn/categories/网页开发/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.cvblogs.cn/tags/Python/"}]},{"title":"翻译：理解深度学习中的卷积操作","slug":"理论学习/理解深度学习中的卷积操作","date":"2017-12-09T17:18:18.000Z","updated":"2017-12-10T12:48:24.408Z","comments":true,"path":"2017/12/10/理论学习/理解深度学习中的卷积操作/","link":"","permalink":"http://www.cvblogs.cn/2017/12/10/理论学习/理解深度学习中的卷积操作/","excerpt":"前言此文为译文，目的是让自己更好的理解卷积操作。原文地址：Understanding Convolution in Deep Learning 非常fascinating的是作者关于卷积在卷积网络中的应用。之前从来没有想过，为啥卷积网络就卷积了呢？（不过似乎我一直也都是停留在对全连接网络的学习上= =）","text":"前言此文为译文，目的是让自己更好的理解卷积操作。原文地址：Understanding Convolution in Deep Learning 非常fascinating的是作者关于卷积在卷积网络中的应用。之前从来没有想过，为啥卷积网络就卷积了呢？（不过似乎我一直也都是停留在对全连接网络的学习上= =） 译文如今，卷积可能是深度学习中最重要的一个概念。卷积操作及卷积网络使深度学习在机器学习任务中表现靠前。但是，什么使得卷积操作如此强大呢？在这篇文章中我会解释卷积操作以及关联它的相关概念帮助你更完全的理解卷积。 虽然已有大量介绍卷积相关的深度学习的博文，但是我发现他们大都因为介绍了过多的不必要的数学细节反而导致令人费解。这篇博文虽然也会介绍一些数学细节，但是我会通过图片的形式展现关键的数学表达式，使其更直观易懂。第一部分是介绍一些通泛的卷积概念以及卷积网络。第二部分则是为深度学习研究人员和专家能够加强理解而准备的一些更高级的概念。 什么是卷积？整篇文章都是建立在去解答这个问题上，因此首先了解大致的方向是很有帮助的。那么，单纯的卷积说的是什么呢？ 你可以想象卷积是混淆信息的方式。想象两个装满信息的桶被按照某种指定的规则被倒入一个桶里进行混合。每一个桶里的内容，都有它自己的关于如何混合其他桶中信息的指导方式。因此，卷积是一个按照指定步骤执行的混合信息的操作。 事实上，卷积和其他数学运算一样也可以被数学定义。尽管卷积操作本身十分的复杂，但是对于复杂的等式，它又可以简化表示。因此，为了简化表达，卷积操作被大量用在了物理学以及工程学上。在第二部分，经过一小段数学证明后。我们会关联和整合科学和深度学习的创意，得到更深层次的关于卷积的理解。但是，我们现在先暂时关注卷积在实际中的应用。 我们如何对图片做卷积操作？当我们对图片做卷积时，我们是对两个维度做了卷积（即图片的宽和高方向）。我们混合两个桶中的内容：第一个桶是输入的图片（可以看作是三个像素矩阵组成，因为图像是由RGB三通道组成的；每个像素矩阵中元素的值：0～255）。第二个桶中是卷积核，一个独立的由浮点数组成的矩阵。（可以将它的大小以及模式看作是一个如何混合两个桶中信息的指导方式）。输出的结果在深度学习中被叫做特征图像(feature map)。每个通道都会产生一个特征图像。 现在，我们演示卷积是如何混合两份信息。一种方法是利用输入图像采样一个小块做卷积操作–我们用100X100的图像，以及3X3的核。因此，我们可以同时采样3X3个像素点（和核做点乘）。最终得到的是一个中心值。当采样完一个地方（3X3）就向一个方向移动一个像素点。循环往复。当所有的像素都被计算后操作才停止。下面的动图展示了卷积操作的一个过程。如你所见，为了保证与原图像有同样的密度一致性，这里通常还有一个正则化的过程。 为什么作用在图片的卷积操作在机器学习中如此有效？在一张图像中有大量的我们不需要的冗余信息。一个很好的例子就是Burda Bootcamp（这是原文作者一个在快速原型生成的马拉松式的学生实验项目中的项目= =）在一个项目，作者想要搭建一个用于时尚图片搜索深度自编码器：你上传一张关于时尚单品的照片，自编码器会找出与图中的单品包含的相关风格的图片。 现在，如果你想鉴别不同风格的衣服，衣服的颜色不会有什么帮助，类似的还有衣服的商标等。关键的要素是衣服的形状。通常，女士衬衫的形状是异于短袖，夹克或毛衣的。因此，我们需要过滤图像中不必要的信息。通过卷积操作我们可以很容易完成这个需求。 作者的同事Jannek Thomas用Sobel算子（它的定义与前面的那个那个边缘算子差不多）预处理了数据，得到了重要的边缘信息。这也是为什么卷积操作也叫做滤波。边缘信息的提取对于形状信息的获得非常有帮助。 更深入的：很多的核产生很多的特征图像（map）。例如：锐化图像的，模糊图像的。 通过这个过程–输入图像，转化输入，得到转化后的图像将其引入算法中。被成为特征提取工程。特征工程非常困难，拥有的学习资料也非常有限。因此，很少有人能够熟练运用它。有效的特征提取在不同的任务中区别很大。因此，不存在通用的特征。同时，对于时间序列数据，特征几乎收效甚微。识别特征的有效性需要大量的经验。 因此，特征工程非常困难，你必须从零开始一点点去试探。但是，当我们关注图像本身，有什么方法可以自动的找到特征提取的核的吗？ 引入卷积网络卷积网络就是干这个的。较于固定我们的核，我们指定一组参数然后让网络训练我们的核。当我们训练我们的卷积网络时，核会随着过程学习，过滤得到更有用的信息。这个过程是全自动的，也被叫做特征学习。特征学习自动得到一个任务的特征。我们所需要做的就是训练我们的网络，去找到一个与新的任务相关的filter。这就是为什么卷积网络如此强大的原因–不再为特征的提取而烦恼。 数据编程的概念 通常我们在一个卷积网络中，不会只学习一个核。我们同时学到一个组织（hierarchy）的多个核。例如：一个32X16X16的核应用在一张256X256的图像上会产生32个241X241的特征图像。（这是标准大小，实现的不同大小特跟着改变；image size - kernel size +1）。因此我们自动学习得到的32个新特征拥有与我们的任务相关的所有信息。这些特征又为接下来的核计算提供了输入。一旦我们学习完所有的核，我们就将其传入给一个全连接的网络（简单的网络，用作图像的分类。）。这就是卷积网络所有的应该知道的概念（池化的过程也很重要，但是它的内容也够写一篇博文了）。 结束语放弃了，第二部分还是自己看吧= =翻译的效率实在太低了。","categories":[{"name":"深度学习","slug":"深度学习","permalink":"http://www.cvblogs.cn/categories/深度学习/"}],"tags":[{"name":"数学基础","slug":"数学基础","permalink":"http://www.cvblogs.cn/tags/数学基础/"}]},{"title":"linux之ssh命令","slug":"开发学习/linux_ssh命令","date":"2017-12-08T12:12:12.000Z","updated":"2017-12-12T04:42:39.444Z","comments":true,"path":"2017/12/08/开发学习/linux_ssh命令/","link":"","permalink":"http://www.cvblogs.cn/2017/12/08/开发学习/linux_ssh命令/","excerpt":"前言今天需要使用ssh的时候发现居然不好使了，原来是自己在电脑上用了lantern之后，ip被改了，不在一个局域网内，无法访问非公网ip。（主要是根本ping不同目的主机= =）于是打算借着机会好好的梳理一下ssh命令。","text":"前言今天需要使用ssh的时候发现居然不好使了，原来是自己在电脑上用了lantern之后，ip被改了，不在一个局域网内，无法访问非公网ip。（主要是根本ping不同目的主机= =）于是打算借着机会好好的梳理一下ssh命令。 参考链接ssh用法及命令 结束语为什么这篇文章的结束语这么靠前，是因为，我在看完大段的内容之后依旧无法弄清楚。如果我要将远端的8000端口映射到本地的8888端口我该用什么命令。感觉这样子陈列知识点真的很糟糕。还是应该以具体的应用来说比较好。12ssh -L 8888:localhost:8000 remote#remote是远端主机名ssh -p 8888 localhost#此时ssh登陆本机8888端口就相当于登陆了remote了，稍后可以一试：） 什么是SSH首先，需要明确的是：SSH是一种网络协议，用于计算机之间的加密登录。目前已经成为Linux系统的标准配置。 SSH只是一种协议，存在多种实现，既有商业实现，也有开源实现。本文针对的实现是OpenSSH，它是自由软件，应用非常广泛。这里只讨论SSH在Linux Shell中的用法。如果要在Windows系统中使用SSH，会用到另一种软件PuTTY。 注解：SSH只是一种协议，而我们所用的SSH命令则是基于该工具封装的一种命令行工具（linux shell）。PuTTY是一个实现这些协议的图形化工具（它支持的协议不止有SSH） SSH原理SSH之所以能够保证安全，原因在于它采用了公钥加密。整个过程是这样的：（1）远程主机收到用户的登录请求，把自己的公钥发给用户。（2）用户使用这个公钥，将登录密码加密后，发送回来。（3）远程主机用自己的私钥，解密登录密码，如果密码正确，就同意用户登录。 不像https协议，SSH协议的公钥是没有证书中心（CA）公证的，也就是说，都是自己签发的。 中间人攻击可以设想，如果攻击者插在用户与远程主机之间（比如在公共的wifi区域），用伪造的公钥，获取用户的登录密码。再用这个密码登录远程主机，那么SSH的安全机制就荡然无存了。这种风险就是著名的”中间人攻击”（Man-in-the-middle attack） SSH基本用法SSH远程登录口令登录123456#假定你要以用户名user，登录远程主机host，只要一条简单命令就可以了。$ ssh user@host 如：ssh pika@192.168.0.111#如果本地用户名与远程用户名一致，登录时可以省略用户名。$ ssh host#SSH的默认端口是22，也就是说，你的登录请求会送进远程主机的22端口。使用p参数，可以修改这个端口$ ssh -p 2222 user@host 公钥登录所谓”公钥登录”，原理很简单，就是用户将自己的公钥储存在远程主机上。登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录shell，不再要求密码。这种方法要求用户必须提供自己的公钥。如果没有现成的，可以直接用ssh-keygen生成一个12345$ ssh-keygen# 运行结束以后，在$HOME/.ssh/目录下，会新生成两个文件：id_rsa.pub和id_rsa。前者是你的公钥，后者是你的私钥。# 这时再输入下面的命令，将公钥传送到远程主机host上面：$ ssh-copy-id user@host 使用ssh在远程后台不中断地跑程序使用nohup命令让程序在关闭窗口（切换SSH连接）的时候程序还能继续在后台运行1nohup python3 a.py &amp; SSH远程操作SSH数据传输SSH不仅可以用于远程主机登录，还可以直接在远程主机上执行操作。SSH可以在用户和远程主机之间，建立命令和数据的传输通道，因此很多事情都可以通过SSH来完成。 scp 跨机远程拷贝scp是secure copy的简写，用于在Linux下进行远程拷贝文件的命令，和它类似的命令有cp，不过cp只是在本机进行拷贝不能跨服务器，而且scp传输是加密的。可能会稍微影响一下速度。两台主机之间复制文件必需得同时有两台主机的复制执行帐号和操作权限。 注解：建议使用scp进行远程copy 绑定本地端口可以让那些不加密的网络连接，全部改走SSH连接，从而提高安全性。12#假定我们要让8080端口的数据，都通过SSH传向远程主机，命令就这样写：$ ssh -D 8080 user@host SSH会建立一个socket，去监听本地的8080端口。一旦有数据传向那个端口，就自动把它转移到SSH连接上面，发往远程主机。可以想象，如果8080端口原来是一个不加密端口，现在将变成一个加密端口。 本地端口转发有时，绑定本地端口还不够，还必须指定数据传送的目标主机，从而形成点对点的”端口转发”。为了区别后文的”远程端口转发”，我们把这种情况称为”本地端口转发”（Local forwarding） 远程端口转发既然”本地端口转发”是指绑定本地端口的转发，那么”远程端口转发”（remote forwarding）当然是指绑定远程端口的转发。","categories":[{"name":"网页开发","slug":"网页开发","permalink":"http://www.cvblogs.cn/categories/网页开发/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.cvblogs.cn/tags/Linux/"}]},{"title":"metadata元数据","slug":"理论学习/metadata元数据","date":"2017-12-08T11:00:26.000Z","updated":"2017-12-12T04:40:39.283Z","comments":true,"path":"2017/12/08/理论学习/metadata元数据/","link":"","permalink":"http://www.cvblogs.cn/2017/12/08/理论学习/metadata元数据/","excerpt":"metadata 元数据一直以来有一个困惑，为什么机器学习的数据集中经常会需要一个metadata的东西（也被叫做元数据）。实在是费解，于是今天忍不住百度了一下。算是解开了疑惑。按照原文的意思，元数据应该被翻译做中间数据而不是元数据。这个翻译容易混淆视听。因此，元数据还有其它名称，中介数据，中继数据。","text":"metadata 元数据一直以来有一个困惑，为什么机器学习的数据集中经常会需要一个metadata的东西（也被叫做元数据）。实在是费解，于是今天忍不住百度了一下。算是解开了疑惑。按照原文的意思，元数据应该被翻译做中间数据而不是元数据。这个翻译容易混淆视听。因此，元数据还有其它名称，中介数据，中继数据。 注解：这里，我的直观感受是元数据相当于文件系统中的目录表。因为我们需要的数据太大了。如果只是一张表通过数据字典映射是表示不了的。因此将其再细分，也便于管理。（应该可以这么理解吧= =）这也就解释了为什么一些大的数据集都有一个metadata（是这样吧 = =） 参考链接通过metadata认识元数据","categories":[{"name":"图像处理","slug":"图像处理","permalink":"http://www.cvblogs.cn/categories/图像处理/"}],"tags":[{"name":"基础概念","slug":"基础概念","permalink":"http://www.cvblogs.cn/tags/基础概念/"}]},{"title":"Django之表单","slug":"开发学习/django_表单","date":"2017-12-08T10:15:18.000Z","updated":"2017-12-10T13:31:29.114Z","comments":true,"path":"2017/12/08/开发学习/django_表单/","link":"","permalink":"http://www.cvblogs.cn/2017/12/08/开发学习/django_表单/","excerpt":"前言HTML表单是网站交互性的经典方式。有必要区别与表格Table。这两个，本质上有很大的差别。","text":"前言HTML表单是网站交互性的经典方式。有必要区别与表格Table。这两个，本质上有很大的差别。 注解：表格Table用于展示数据表单Form则用于提交数据等 HTTP请求HTTP协议以”请求－回复”的方式工作。客户发送请求时，可以在请求中附加数据。服务器通过解析请求，就可以获得客户传来的数据，并根据URL来提供特定的服务。 GET 方法创建一个 search.py 文件，用于接收用户的请求。记得一定要将自己定义的路由处理函数在urls.py中定义的正则路由对应起来。 注解：此处将视图显示和请求处理分成两个函数处理。 POST 方法提交数据时更常用POST方法。用一个URL和处理函数，同时显示视图和处理请求。注意：csrf 全称是 Cross Site Request Forgery。这是Django提供的防止伪装提交请求的功能。POST 方法提交的表格，必须有此标签。 Request 对象每个view 函数的第一个参数是一个 HttpRequest 对象注意：不能使用语句if request.POST来判断是否使用HTTP POST方法；应该使用if request.method == “POST” 。 QueryDict对象在HttpRequest对象中, GET和POST属性是django.http.QueryDict类的实例。QueryDict类似字典的自定义类，用来处理单键对应多值的情况。","categories":[{"name":"网页开发","slug":"网页开发","permalink":"http://www.cvblogs.cn/categories/网页开发/"}],"tags":[{"name":"Django","slug":"Django","permalink":"http://www.cvblogs.cn/tags/Django/"}]},{"title":"Django之数据库","slug":"开发学习/django之数据库","date":"2017-12-08T09:56:10.000Z","updated":"2017-12-10T13:20:47.385Z","comments":true,"path":"2017/12/08/开发学习/django之数据库/","link":"","permalink":"http://www.cvblogs.cn/2017/12/08/开发学习/django之数据库/","excerpt":"前言关于在Django框架中如何使用数据库。","text":"前言关于在Django框架中如何使用数据库。 数据库的使用定义模型创建 APPDjango规定，如果要使用模型，必须要创建一个app。修改对应App目录下的models.py文件。12345# models.pyfrom django.db import models class Test(models.Model): name = models.CharField(max_length=20) 注解：类名代表了数据库表名，继承了models.Model。类里面的字段代表数据表中的字段(name)数据类型则由CharField（相当于varchar）、DateField（相当于datetime）max_length 参数限定长度。 在命令行中运行123python manage.py migrate # 创建表结构python manage.py makemigrations TestModel # 让 Django 知道我们在我们的模型有一些变更python manage.py migrate TestModel # 创建表结构 表名组成结构为：应用名_类名（如：TestModel_test）。 注意：尽管我们没有在models给表设置主键，但是Django会自动添加一个id作为主键。 数据库操作在 HelloWorld(所创建的App)目录中添加 testdb.py 文件（下面介绍），并修改 urls.py 注解：此处只要在对应App目录下创建好操作数据库的文件，以及在urls.py中处理好对应的路由转发规则即可。并不强制要求一定是这样。但是路由的映射一定要对应上。 添加数据添加数据需要先创建对象，然后再执行 save 函数，相当于SQL中的INSERT1234567891011# -*- coding: utf-8 -*- from django.http import HttpResponse #因为是处理客户端http请求，因此需要引入该模块 from TestModel.models import Test #该模块中定义了我们的表结构（模型），可以理解为是一个类（自定义的数据类型） # 数据库操作def testdb(request): #此处对应urls.py中的路由处理函数，一定要对应上 test1 = Test(name='runoob') #创建了一个实例对象 test1.save() #将实例对象保存（可以看作是SQL中的INSERT操作） return HttpResponse(\"&lt;p&gt;数据添加成功！&lt;/p&gt;\") #如只是用HttpResponse则无需在参数中添加request。如果是render等则需要带上 获取数据通过objects这个模型管理器来进行完成对应的操作all()获得所有数据行，相当于SQL中的SELECT * FROMfilter相当于SQL中的WHERE，可设置条件过滤结果objects.get(id=1)获取单个对象objects.order_by(‘name’)[0:2]限制返回的数据 相当于 SQL 中的 OFFSET 0 LIMIT 2;objects.order_by(“id”)数据排序上面的方法可以连锁使用 更新数据修改数据可以使用 save() 或 update() save()和update都得针对已经有的数据进行操作 删除数据删除数据库中的对象只需调用该对象的delete()方法即可 结束语Django中的数据库操作还是挺简单的，但是封装感觉会是一个问题，单纯的利用框架提供的这个似乎解耦等不会很好，有待继续学习。 参考链接http://www.runoob.com/django/django-model.html","categories":[{"name":"网页开发","slug":"网页开发","permalink":"http://www.cvblogs.cn/categories/网页开发/"}],"tags":[{"name":"Django","slug":"Django","permalink":"http://www.cvblogs.cn/tags/Django/"}]},{"title":"python之数据结构","slug":"开发学习/python_python数据结构","date":"2017-12-08T09:26:06.000Z","updated":"2017-12-12T04:41:50.627Z","comments":true,"path":"2017/12/08/开发学习/python_python数据结构/","link":"","permalink":"http://www.cvblogs.cn/2017/12/08/开发学习/python_python数据结构/","excerpt":"前言本章是关于python中基本数据结构知识的一些梳理。","text":"前言本章是关于python中基本数据结构知识的一些梳理。 Python 列表(List) 可以这么说是，用[与]将元素圈起来- - 序列中的每个元素都分配一个数字 - 它的位置，或索引，第一个索引是0，第二个索引是1，依此类推。Python有6个序列的内置类型，但最常见的是列表和元组。序列都可以进行的操作包括索引，切片，加，乘，检查成员。Python已经内置确定序列的长度以及确定最大和最小的元素的方法。 列表是最常用的Python数据类型，它可以作为一个方括号内的逗号分隔值出现。创建一个列表，只要把逗号分隔的不同的数据项使用方括号括起来即可。与字符串的索引一样，列表索引从0开始。列表可以进行截取、组合等。 删除列表元素del语句来删除列表的的元素。 Python列表脚本操作符列表对 + 和 的操作符与字符串相似。+ 号用于组合列表， 号用于重复列表。 Python 元祖(Tuple)元组与列表类似，不同之处在于元组的元素不能修改。元组使用小括号，列表使用方括号。元组创建很简单，只需要在括号中添加元素，并使用逗号隔开即可。元组中只包含一个元素时，需要在元素后面添加逗号元组与字符串类似，下标索引从0开始，可以进行截取，组合等。将列表转换为元组:tuple(seq) Python 字典(Dictionary)字典是另一种可变容器模型，且可存储任意类型对象。字典的每个键值(key=&gt;value)对用冒号(:)分割，每个对之间用逗号(,)分割，整个字典包括在花括号({})中。键必须是唯一的，但值则不必。键必须是不可变的，如字符串，数字或元组。 删除字典元素123del dict['Name']; # 删除键是'Name'的条目dict.clear(); # 清空词典所有条目del dict ; # 删除词典 字典键的特性字典值可以没有限制地取任何python对象，既可以是标准的对象，也可以是用户定义的，但键不行。 不允许同一个键出现两次。创建时如果同一个键被赋值两次，后一个值会被记住。 键必须不可变，所以可以用数字，字符串或元组充当，所以用列表就不行。","categories":[{"name":"网页开发","slug":"网页开发","permalink":"http://www.cvblogs.cn/categories/网页开发/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.cvblogs.cn/tags/Python/"}]},{"title":"python之读取数据的方式","slug":"开发学习/python_python读取数据的方式","date":"2017-12-08T09:01:01.000Z","updated":"2017-12-12T04:42:05.586Z","comments":true,"path":"2017/12/08/开发学习/python_python读取数据的方式/","link":"","permalink":"http://www.cvblogs.cn/2017/12/08/开发学习/python_python读取数据的方式/","excerpt":"Python读取数据的方式在文本处理的过程中，将文件加载内存中是第一步，这就涉及到怎样将文件中的某一列映射到具体的变量的过程。推荐两种优雅的方式来读取数据，都是先配置字段模式，然后按照模式读取，而模式则有字典模式和列表模式两种形式；","text":"Python读取数据的方式在文本处理的过程中，将文件加载内存中是第一步，这就涉及到怎样将文件中的某一列映射到具体的变量的过程。推荐两种优雅的方式来读取数据，都是先配置字段模式，然后按照模式读取，而模式则有字典模式和列表模式两种形式； 读取文件，按照分隔符分割成字段数据列表使用yield关键字，每次抛出单个行的分割数据，这样在调度程序中可以用for fields in read_file_data(fpath)的方式读取每一行。 使用配置好的字典模式，装配读取的数据列表这种方法配置一个{“字段名”: 字段位置}的字典作为数据模式，然后按照该模式装配读取的列表数据，最后实现用字典的方式访问数据。 使用配置好的列表模式，装配读取的数据列表如果需要读取文件所有列，或者前面的一些列，那么配置字典模式优点复杂，因为需要给每个字段配置索引位置，并且这些位置是从0开始完后数的，属于低级劳动，需要消灭。 按列表模式读列表模式应命运而生，先将配置好的列表模式转换成字典模式，然后按字典加载就可以实现。使用的时候，可以用列表的形式配置模式，不需要配置索引更加简洁 结束语 尚未理解透彻数据处理中的字典模式与列表模式。 引用链接Python使用list字段模式或者dict字段模式读取文件的方法","categories":[{"name":"网页开发","slug":"网页开发","permalink":"http://www.cvblogs.cn/categories/网页开发/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.cvblogs.cn/tags/Python/"}]},{"title":"linux之软链接与硬链接","slug":"开发学习/linux_软链接与硬链接","date":"2017-12-08T07:18:22.000Z","updated":"2017-12-10T12:56:53.806Z","comments":true,"path":"2017/12/08/开发学习/linux_软链接与硬链接/","link":"","permalink":"http://www.cvblogs.cn/2017/12/08/开发学习/linux_软链接与硬链接/","excerpt":"软链接称之为符号连接（Symbolic Link）。类似于Windows的快捷方式，在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。","text":"软链接称之为符号连接（Symbolic Link）。类似于Windows的快捷方式，在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。 注解：此处说的一个文本文件包含另一文件的位置信息，可以将其看作指针。因此每次打开软链接的文件都会定位到源文件目录所在的位置。 软链接的缺点在于：因为链接文件包含有原文件的路径信息，所以当原文件从一个目录下移到其他目录中，再访问链接文件，系统就找不到了，而硬链接就没有这个缺陷，你想怎么移就怎么移；还有它要系统分配额外的空间用于建立新的索引节点和保存原文件的路径。 硬链接通过索引节点来进行连接。保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Index)。允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。 注解：好比C++中，为一个内存区域创建了多个别名。 硬链接文件有两个限制 不允许给目录创建硬链接； 只有在同一文件系统中的文件之间才能创建链接，而且只有超级用户才有建立硬链接权限。 对硬链接文件进行读写和删除操作时候，结果和软链接相同。但如果我们删除硬链接文件的源文件，硬链接文件仍然存在，而且保留了愿有的内容。 软链接没有硬链接以上的两个限制，因而现在更为广泛使用，它具有更大的灵活性，甚至可以跨越不同机器、不同网络对文件进行链接。 创建命令ln -s创建软链接 ln创建硬链接 参考链接linux 创建连接命令 ln -s 软链接","categories":[{"name":"网页开发","slug":"网页开发","permalink":"http://www.cvblogs.cn/categories/网页开发/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.cvblogs.cn/tags/Linux/"}]},{"title":"python之编码规范笔记","slug":"开发学习/python_编码规范","date":"2017-12-08T05:21:01.000Z","updated":"2017-12-12T04:43:44.241Z","comments":true,"path":"2017/12/08/开发学习/python_编码规范/","link":"","permalink":"http://www.cvblogs.cn/2017/12/08/开发学习/python_编码规范/","excerpt":"前言主要是python中基础结构及对应容易被我忘记的编码建议的笔记梳理。","text":"前言主要是python中基础结构及对应容易被我忘记的编码建议的笔记梳理。 基本结构 模块：小写、可以有下划线 包：小写、无下划线 类：CapWords(驼峰式命名) 函数命名：小写，可以有下划线 常量命名：大写，可以有下划线 类的属性：小写，前缀下划线 类的方法第一个参数必须是self，静态方法第一个参数必须是cls 编码建议 尽可能使用‘is’,‘is not’取代‘==’，比如if x is not None 要优于if x。 使用isinstance()比较对象的类型 使用startswith() and endswith()代替切片进行序列前缀或后缀的检查","categories":[{"name":"网页开发","slug":"网页开发","permalink":"http://www.cvblogs.cn/categories/网页开发/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.cvblogs.cn/tags/Python/"}]},{"title":"git利用https无法push解决方法","slug":"开发学习/git的https无法push解决方法","date":"2017-12-08T02:22:26.000Z","updated":"2017-12-12T04:44:27.656Z","comments":true,"path":"2017/12/08/开发学习/git的https无法push解决方法/","link":"","permalink":"http://www.cvblogs.cn/2017/12/08/开发学习/git的https无法push解决方法/","excerpt":"错误信息：fatal: Unable to find remote helper for &#39;https&#39;昨天想要提交代码的时候，死活无法push，稍晚的时候才想起来原来是自己太着急了，代码都没有commit，那么何谈push呢。","text":"错误信息：fatal: Unable to find remote helper for &#39;https&#39;昨天想要提交代码的时候，死活无法push，稍晚的时候才想起来原来是自己太着急了，代码都没有commit，那么何谈push呢。 切记本地与远端的区别。远端只需要将它看作是一个存储数据作备份的地方。真正的内容其实是需要在本地完成的。而git这个工具的本质就是，先add修改（如果是对已有文件作修改则只需要用commit -am提交修改信息。git会保存所有的提交版本记录。） 另外，由于用conda进入了虚拟环境，导致push的时候依旧报错。报错信息是fatal: Unable to find remote helper for &#39;https&#39;。上网查找的时候说是我没有安装curl等（但是其实根据一个正常工作的git config --list信息对比，我的git及curl是可以正常用的）。 最后，其实是因为我进入了conda的环境。退出来虚拟环境，就可以正常提交了。 结束语还是环境变量的问题。","categories":[{"name":"网页开发","slug":"网页开发","permalink":"http://www.cvblogs.cn/categories/网页开发/"}],"tags":[{"name":"测试","slug":"测试","permalink":"http://www.cvblogs.cn/tags/测试/"}]},{"title":"Django之基础概念学习","slug":"开发学习/django_基础概念学习","date":"2017-12-07T04:47:10.000Z","updated":"2017-12-12T04:44:45.655Z","comments":true,"path":"2017/12/07/开发学习/django_基础概念学习/","link":"","permalink":"http://www.cvblogs.cn/2017/12/07/开发学习/django_基础概念学习/","excerpt":"前言最近需要学习Django框架。笔记备忘。其实学习一个框架，莫过于自己动手从零开始搭建。亲身去体会这个框架。这样学习才能事半功倍。神奇的发现hexo的文件里不可以有那个跨站点的token标签= =","text":"前言最近需要学习Django框架。笔记备忘。其实学习一个框架，莫过于自己动手从零开始搭建。亲身去体会这个框架。这样学习才能事半功倍。神奇的发现hexo的文件里不可以有那个跨站点的token标签= = 引用链接https://www.cnblogs.com/feixuelove1009/p/5823135.htmlhttp://www.runoob.com/django/django-first-app.html Web框架介绍其它基于python的web框架，如tornado、flask、webpy都是在这个范围内进行增删裁剪的。例如tornado用的是自己的异步非阻塞“wsgi”，flask则只提供了最精简和基本的框架。Django则是直接使用了WSGI，并实现了大部分功能 MVC/MTV介绍模型(model)：定义数据库相关的内容，一般放在models.py文件中。视图(view)：定义HTML等静态网页文件相关，也就是那些html、css、js等前端的东西。控制器(controller)：定义业务逻辑相关，就是你的主要代码。MTV: 有些WEB框架觉得MVC的字面意思很别扭，就给它改了一下。view不再是HTML相关，而是主业务逻辑了，相当于控制器。html被放在Templates中，称作模板，于是MVC就变成了MTV。这其实就是一个文字游戏，和MVC本质上是一样的，换了个名字和叫法而已，换汤不换药。 Django模型组织 我们学Django学的是什么？ 目录结构规范 urls路由方式 settings配置 ORM操作 模板渲染 其它 Django项目目录结构所有的APP共享项目资源在每个django项目中可以包含多个APP，相当于一个大型项目中的分系统、子模块、功能部件等等，相互之间比较独立，但也有联系。编写路由路由都在urls.py文件里，它将浏览器输入的url映射到相应的业务处理逻辑 此处尚未理解透彻 业务处理逻辑业务处理逻辑都在views.py文件里。通过上面两个步骤，我们将urls.py中的index这个url指向了views.py里的index（）函数，它接收用户请求request，并返回一个“hello world”字符串。实际上这肯定不行，通常我们都是将html文件返回给用户。 返回HTML文件写这么一个index.html文件,再修改一下views文件。为了让django知道我们的html文件在哪里，需要修改settings.py文件的相应内容。但默认情况下，它正好适用，你无需修改。 注：这里有个小技巧，在多次频繁重启服务时，由于端口未释放的原因，容易启动不了服务，修改一下端口就OK了。 使用静态文件我们已经可以将html文件返还给用户了，但是还不够，前端三大块，html、css、js还有各种插件，它们齐全才是一个完整的页面。在django中，一般将静态文件放在static目录中。你的CSS,JS和各种插件都可以放置在这个目录里。为了让django找到这个目录，依然需要对settings进行配置。同样，在index.html文件中，可以引入js文件了。 接收用户发送的数据我们将一个要素齐全的html文件返还给了用户浏览器。但这还不够，因为web服务器和用户之间没有动态交互。 下面我们设计一个表单，让用户输入用户名和密码，提交给index这个url，服务器将接收到这些数据。注意：跨站保护机制django有一个csrf跨站请求保护机制，我们暂时在settings文件中将它关闭，或者在form表单里添加一个标签。 返回动态页面我们收到了用户的数据，但返回给用户的依然是个静态页面，通常我们会根据用户的数据，进行处理后在返回给用户。 这时候，django采用自己的模板语言，类似jinja2，根据提供的数据，替换掉html中的相应部分，详细语法入门后再深入学习 使用数据库流程走到这里，django的MTV框架基本已经浮出水面了，只剩下最后的数据库部分了。django通过自带的ORM框架操作数据库，并且自带轻量级的sqlite3数据库。 在settings.py里注册你的app(不注册它，你的数据库就不知道该给哪个app创建表) 然后我们在settings中，配置数据库相关的参数，如果使用自带的sqlite，不需要修改。 再编辑models.py文件，也就是MTV中的M。 接下来要在pycharm的teminal中通过命令创建数据库的表 12python manage.py makemigrationspython manage.py migrate 修改views.py中的业务逻辑 重启web服务后，刷新浏览器页面，之后和用户交互的数据都能保存到数据库中。任何时候都可以从数据库中读取数据，展示到页面上。 结束语关于学习方法的建议：学习任何东西，不要直接扎入细节，应该先了解它的外围知识，看看它的整体架构，再学习它的基本内容，然后才是深入学习，打磨技巧！","categories":[{"name":"网页开发","slug":"网页开发","permalink":"http://www.cvblogs.cn/categories/网页开发/"}],"tags":[{"name":"Django","slug":"Django","permalink":"http://www.cvblogs.cn/tags/Django/"}]},{"title":"深度学习框架","slug":"理论学习/深度学习框架","date":"2017-12-05T02:57:10.000Z","updated":"2017-12-10T12:55:52.794Z","comments":true,"path":"2017/12/05/理论学习/深度学习框架/","link":"","permalink":"http://www.cvblogs.cn/2017/12/05/理论学习/深度学习框架/","excerpt":"PyTorchPyTorch准备数据有很多灵活的方式，在最后能够将数据转为Numpy数组即可，通过Numpy数据可以转化为PyTorch所需的Tensor。 对于图像数据，可以直接通过opencv，Pillow等做处理； 语音数据可以通过scipy和librosa来处理成numpy； 文本数据可以通过CNTK之类的自然语言处理库处理成numpy数组。","text":"PyTorchPyTorch准备数据有很多灵活的方式，在最后能够将数据转为Numpy数组即可，通过Numpy数据可以转化为PyTorch所需的Tensor。 对于图像数据，可以直接通过opencv，Pillow等做处理； 语音数据可以通过scipy和librosa来处理成numpy； 文本数据可以通过CNTK之类的自然语言处理库处理成numpy数组。 SKImage| 子模块名称 | 主要实现功能 || ———— | ——————————– || io | 读取、保存和显示图片或视频 || data | 提供一些测试图片和样本数据 || color | 颜色空间变换 || filters | 图像增强、边缘检测、排序滤波器、自动阈值等 || draw | 操作于numpy数组上的基本图形绘制，包括线条、矩形、圆和文本等 || transform | 几何变换或其它变换，如旋转、拉伸和拉东变换等 || morphology | 形态学操作，如开闭运算、骨架提取等 || exposure | 图片强度调整，如亮度调整、直方图均衡等 || feature | 特征检测与提取等 || measure | 图像属性的测量，如相似性或等高线等 || segmentation | 图像分割 || restoration | 图像恢复 || util | 通用函数 |","categories":[{"name":"深度学习","slug":"深度学习","permalink":"http://www.cvblogs.cn/categories/深度学习/"}],"tags":[{"name":"基础概念","slug":"基础概念","permalink":"http://www.cvblogs.cn/tags/基础概念/"}]},{"title":"计算架构之CPU与GPU","slug":"理论学习/计算架构之CPU与GPU","date":"2017-11-29T09:38:10.000Z","updated":"2017-12-10T13:12:50.244Z","comments":true,"path":"2017/11/29/理论学习/计算架构之CPU与GPU/","link":"","permalink":"http://www.cvblogs.cn/2017/11/29/理论学习/计算架构之CPU与GPU/","excerpt":"前言日益复杂的3D图形图像时就会常常出现显卡等待CPU数据的情况","text":"前言日益复杂的3D图形图像时就会常常出现显卡等待CPU数据的情况 CUDA介绍CUDA是计算统一设备构架（Compute Unified Device Architecture）的缩写。CUDA和GPU之间的关系十分重要。CUDA在编程基础上实现GPU的性能。CUDA：软件GPU：硬件 发展历程GPGPU-&gt;CUDA-&gt;GPU 结束语CUDA只是一种并行计算架构，相关的概念还有OpenCL、OpenMP等 SSL:Semi-Supervised Learning 期望最大算法(Expectation Maximum，EM) 高斯混合模型(Gaussian Mixture Model，GMM) 最小割法(Mincut):首次将图论应用于解决SSL问题 调和函数法(Harmonic Function)将预测函数从离散形式扩展到连续形式 流形正则化法(Manifold Regularization)将流形学习的思想用于SSL场景 用于聚类的半监督距离度量学习方法，学习一种距离度量。 将EM和朴素贝叶斯结合，通过引入加权系数动态调整无类标签的样例的影响提高了分类准确度，建立每类中具有多个混合部分的模型，使贝叶斯偏差减小。 协同训练改进算法，不需要充分冗余的视图，而利用两个不同类型的分类器来完成学习 同时解决有类标签样本稀疏和具有附加无类标签样例成对约束的问题 三个常用基本假设基于一个事实：未标记样本虽未直接包含标记信息，但若它们与有标记信息样本是从同样的数据源独立同分布采样而来，则它们所包含的关于数据分布的信息对建立模型是有帮助的。利用好未标记样本来提升模型泛化能力，就是半监督学习研究的重点。在半监督学习中有三个常用的基本假设来建立预测样例和学习目标之间的关系：（1）平滑假设(Smoothness Assumption)：位于稠密数据区域的两个距离很近的样例的类标签相似，也就是说，当两个样例被稠密数据区域中的边连接时，它们在很大的概率下有相同的类标签；相反地，当两个样例被稀疏数据区域分开时，它们的类标签趋于不同。（2）聚类假设(Cluster Assumption)：当两个样例位于同一聚类簇时，它们在很大的概率下有相同的类标签。这个假设的等价定义为低密度分离假设(Low Sensity Separation Assumption)，即分类决策边界应该穿过稀疏数据区域，而避免将稠密数据区域的样例分到决策边界两侧。（3）流形假设(Manifold Assumption)：将高维数据嵌入到低维流形中，当两个样例位于低维流形中的一个小局部邻域内时，它们具有相似的类标签。 四大类学习场景半监督学习可进一步划分为纯(pure)半监督学习和直推学习（transductive learning）：纯半监督学习假定训练数据中的未标记样本并非待预测数据；而直推学习假定学习过程中所考虑的未标记样本恰是待预测数据，学习的目的就是在未标记样本上获得最优泛化性能。纯半监督学习是基于开放世界的假设，希望学得的模型能适用于训练过程中未观察到的数据；而直推学习是基于封闭世界假设，仅试图对学习过程中观察到的未标记数据进行预测。从不同的学习场景看，SSL可分为四大类： 半监督分类半监督分类(Semi-Supervised Classification)：是在无类标签的样例的帮助下训练有类标签的样本，获得比只用有类标签的样本训练得到的分类器性能更优的分类器，弥补有类标签的样本不足的缺陷，其中类标签yi取有限离散值。 半监督回归半监督回归(Semi-Supervised Regression)：在无输出的输入的帮助下训练有输出的输入，获得比只用有输出的输入训练得到的回归器性能更好的回归器，其中输出yi取连续值； 半监督聚类半监督聚类(Semi-Supervised Clustering)：在有类标签的样本的信息帮助下获得比只用无类标签的样例得到的结果更好的簇，提高聚类方法的精度； 半监督降维半监督降维(Semi-Supervised Dimensionality Reduction)：在有类标签的样本的信息帮助下找到高维输入数据的低维结构，同时保持原始高维数据和成对约束(Pair-Wise Constraints)的结构不变，即在高维空间中满足正约束(Must-Link Constraints)的样例在低维空间中相距很近，在高维空间中满足负约束(Cannot-Link Constraints)的样例在低维空间中距离很远。 未来的研究方向包括以下一些内容理论分析抗干扰性与可靠性训练样例与参数的选取优化求解从各种SSL算法的实现过程可以看出，SSL问题大多为非凸、非平滑问题，或整数规划和组合优化问题，存在多个局部最优解，例如求解SSL产生式方法目标函数的EM算法只能得到局部极大值目前主要采用各种放松方法把目标函数近似转化为凸或连续最优化问题，不易得到全局最优解，算法的时空复杂性很高，问题的求解依赖于最优化理论的突破，未来需要研究新的算法求解全局最优解。 研究拓展SSL从产生以来，主要用于实验室中处理人工合成数据，未来的研究一方而需要讨论SSL可以显著提高哪些学习任务的性能，拓展SSL在现实领域的实际应用，另一方而需要制定出一个统一的令人信服的SSL方法的使用规程。此外，目前有许多的半监督分类方法，而对半监督回归问题的研究比较有限。未来有待继续研究半监督分类和半监督回归之间的关系，并提出其他半监督回归方法。 Active Learning:主动学习主动学习就是要引入专家知识，通过与外部交互来将部分未标记样本转变为有标记样本。如果不通过外部标记，还可以利用未标记样本，就是半监督学习的研发范围","categories":[{"name":"深度学习","slug":"深度学习","permalink":"http://www.cvblogs.cn/categories/深度学习/"}],"tags":[{"name":"基础概念","slug":"基础概念","permalink":"http://www.cvblogs.cn/tags/基础概念/"}]},{"title":"web开发之内存泄漏","slug":"开发学习/web开发_内存泄漏","date":"2017-11-12T14:31:10.000Z","updated":"2017-12-12T04:45:36.658Z","comments":true,"path":"2017/11/12/开发学习/web开发_内存泄漏/","link":"","permalink":"http://www.cvblogs.cn/2017/11/12/开发学习/web开发_内存泄漏/","excerpt":"前言以下文章内容大都摘自阮一峰的网络博客JavaScript 内存泄漏教程篇,仅作个人学习笔记备记。本来不想记的，因为对于只是在本地写hello world的我来说，内存管理似乎从来不是一件必要的事情。但是，突然想到，内存的管理对于部署在服务器上的或者说生产环境中的应用是多么的重要。想象一下，要是一个需要7/24运行的web应用内存泄漏了：）简直就是一场灾难。服务器怠机则无法提供服务。","text":"前言以下文章内容大都摘自阮一峰的网络博客JavaScript 内存泄漏教程篇,仅作个人学习笔记备记。本来不想记的，因为对于只是在本地写hello world的我来说，内存管理似乎从来不是一件必要的事情。但是，突然想到，内存的管理对于部署在服务器上的或者说生产环境中的应用是多么的重要。想象一下，要是一个需要7/24运行的web应用内存泄漏了：）简直就是一场灾难。服务器怠机则无法提供服务。 什么是内存泄漏对于持续运行的服务进程（daemon），必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。不再用到的内存，没有及时释放，就叫做内存泄漏（memory leak）。有些语言（比如 C 语言）必须手动释放内存，程序员负责内存管理。这很麻烦，所以大多数语言提供自动内存管理，减轻程序员的负担，这被称为”垃圾回收机制”（garbage collector）。 垃圾回收机制最常使用的方法叫做”引用计数”（reference counting）：语言引擎有一张”引用表”，保存了内存里面所有的资源（通常是各种值）的引用次数。如果一个值的引用次数是0，就表示这个值不再用到了，因此可以将这块内存释放。但是，并不是说有了垃圾回收机制，程序员就轻松了。你还是需要关注内存占用：那些很占空间的值，一旦不再用到，你必须检查是否还存在对它们的引用。如果是的话，就必须手动解除引用。 内存泄漏的识别方法经验法则是，如果连续五次垃圾回收之后，内存占用一次比一次大，就有内存泄漏。这就要求实时查看内存占用。 浏览器Chrome 浏览器查看内存占用，按照以下步骤操作。123451. 打开开发者工具，选择 Timeline 面板2. 在顶部的Capture字段里面勾选 Memory3. 点击左上角的录制按钮。4. 在页面上进行各种操作，模拟用户的使用情况。5. 一段时间后，点击对话框的 stop 按钮，面板上就会显示这段时间的内存占用情况。 如果内存占用基本平稳，接近水平，就说明不存在内存泄漏。反之，就是内存泄漏了。 命令行命令行可以使用Node 提供的process.memoryUsage方法。process.memoryUsage返回一个对象，包含了 Node进程的内存占用信息。该对象包含四个字段，单位是字节。判断内存泄漏，以heapUsed字段为准。1234rss（resident set size）：所有内存占用，包括指令区和堆栈。heapTotal：&quot;堆&quot;占用的内存，包括用到的和没用到的。heapUsed：用到的堆的部分。external： V8 引擎内部的 C++ 对象占用的内存。 WeakMapES6 考虑到了这一点，推出了两种新的数据结构：WeakSet 和 WeakMap。它们对于值的引用都是不计入垃圾回收机制的，所以名字里面才会有一个”Weak”，表示这是弱引用。 参考链接JavaScript 内存泄漏教程","categories":[{"name":"网页开发","slug":"网页开发","permalink":"http://www.cvblogs.cn/categories/网页开发/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://www.cvblogs.cn/tags/Node-js/"}]},{"title":"web开发之LiveServer使用","slug":"开发学习/web开发_LiveServer使用","date":"2017-11-12T14:15:10.000Z","updated":"2017-12-26T10:48:13.965Z","comments":true,"path":"2017/11/12/开发学习/web开发_LiveServer使用/","link":"","permalink":"http://www.cvblogs.cn/2017/11/12/开发学习/web开发_LiveServer使用/","excerpt":"live-server模块的作用 实现热插拔hot socketing(修改文件之后，浏览器能够自动刷新) 当服务启动时，自动打开所在的项目。(实现opener的功能) 快速搭建临时的web服务。（实现http-server的功能）","text":"live-server模块的作用 实现热插拔hot socketing(修改文件之后，浏览器能够自动刷新) 当服务启动时，自动打开所在的项目。(实现opener的功能) 快速搭建临时的web服务。（实现http-server的功能） 我们主要使用1与2，3用express或者其他web框架。 安装可以直接使用全局安装的方法1npm install -g live-server 使用在package.json的script下添加一个server字段的npm 脚本。123\"scripts\": &#123; \"server\": \"live-server ./ --port=9090\"&#125; 使用npm run server执行。等待一会之后，浏览器会自动打开。这样当你修改本地任何文件，浏览器都会自动立即同步（在内存层面，如果你想要发布代码，还是需要再次编译，否则修改之后的一些代码不会被改变！）。 继续学习官方链接https://www.npmjs.com/package/live-server","categories":[{"name":"网页开发","slug":"网页开发","permalink":"http://www.cvblogs.cn/categories/网页开发/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://www.cvblogs.cn/tags/Node-js/"}]},{"title":"web开发之性能分析火焰图","slug":"开发学习/web开发_性能分析火焰图","date":"2017-11-12T14:05:10.000Z","updated":"2017-12-12T04:45:52.592Z","comments":true,"path":"2017/11/12/开发学习/web开发_性能分析火焰图/","link":"","permalink":"http://www.cvblogs.cn/2017/11/12/开发学习/web开发_性能分析火焰图/","excerpt":"前言以下内容基本摘自阮一峰的网络博客-如何读懂火焰图篇，只做个人学习笔记用。","text":"前言以下内容基本摘自阮一峰的网络博客-如何读懂火焰图篇，只做个人学习笔记用。 perf命令Linux 系统原生提供的性能分析工具，会返回 CPU 正在执行的函数名以及调用栈（stack）。通常，它的执行频率是 99Hz（每秒99次），如果99次都返回同一个函数名，那就说明 CPU 这一秒钟都在执行同一个函数，可能存在性能问题。1sudo perf record -F 99 -p 13204 -g -- sleep 30 上面的代码中，perf record表示记录，-F 99表示每秒99次，-p 13204是进程号，即对哪个进程进行分析，-g表示记录调用栈，sleep 30则是持续30秒。运行后会产生一个庞大的文本文件。如果一台服务器有16个 CPU，每秒抽样99次，持续30秒，就得到 47,520 个调用栈，长达几十万甚至上百万行。为了便于阅读，perf record命令可以统计每个调用栈出现的百分比，然后从高到低排列。1sudo perf report -n --stdio 由于是文本文件极其不易阅读所以才有了火焰图。 火焰图火焰图是基于 perf 结果产生的 SVG 图片，用来展示 CPU 的调用栈。y 轴表示调用栈，每一层都是一个函数。调用栈越深，火焰就越高，顶部就是正在执行的函数，下方都是它的父函数。x 轴表示抽样数，如果一个函数在 x 轴占据的宽度越宽，就表示它被抽到的次数多，即执行的时间长。注意，x 轴不代表时间，而是所有的调用栈合并后，按字母顺序排列的。 火焰图就是看顶层的哪个函数占据的宽度最大。只要有”平顶”（plateaus），就表示该函数可能存在性能问题。 Node 应用的火焰图1perf record -F 99 -p `pgrep -n node` -g -- sleep 30 具体的操作过程参考此教程 浏览器的火焰图Chrome 浏览器可以生成页面脚本的火焰图，用来进行 CPU 分析。打开开发者工具，切换到 Performance 面板。然后，点击&quot;录制&quot;按钮，开始记录数据。这时，可以在页面进行各种操作，然后停止&quot;录制&quot;。浏览器的火焰图与标准火焰图有两点差异： 它是倒置的（即调用栈最顶端的函数在最下方）； x 轴是时间轴，而不是抽样次数。","categories":[{"name":"网页开发","slug":"网页开发","permalink":"http://www.cvblogs.cn/categories/网页开发/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://www.cvblogs.cn/tags/Node-js/"}]},{"title":"错误修改profile文件引起的重复登录问题解决方法","slug":"开发学习/错误修改profile文件引起的重复登录问题解决方法","date":"2017-11-10T14:15:26.000Z","updated":"2017-12-12T04:46:01.357Z","comments":true,"path":"2017/11/10/开发学习/错误修改profile文件引起的重复登录问题解决方法/","link":"","permalink":"http://www.cvblogs.cn/2017/11/10/开发学习/错误修改profile文件引起的重复登录问题解决方法/","excerpt":"前言今天为了安装go错误修改了/etc/profile文件，导致reboot的时候一直循环登录。最终通过搜索解决了问题。这里记录一下。","text":"前言今天为了安装go错误修改了/etc/profile文件，导致reboot的时候一直循环登录。最终通过搜索解决了问题。这里记录一下。 解决方法整个问题的关键是利用超级管理员权限进行修改前面被我修改错的的etc/profile文件。但是我的用户是普通用户根本就切换不了。su命令是报一堆错误。正确的做法如下： alt+ctl+shft+f1-6进入tty界面 用普通用户账号登录(我的是普通用户，如果是root账号则直接进入步骤4) 执行export PATH=/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin 正常用vim修改/etc/profile，完整命令如下：sudo vim /etc/profile 使之起效source /etc/profile 最后用alt+ctl+shft+f7命令回到图形化界面，正常登录。 结束语操作系统真有趣：）","categories":[{"name":"网页开发","slug":"网页开发","permalink":"http://www.cvblogs.cn/categories/网页开发/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.cvblogs.cn/tags/Linux/"}]},{"title":"解决Mackeeper流氓软件引起的Chrome广告弹窗","slug":"开发学习/解决Mackeeper流氓软件引起的Chrome广告弹窗","date":"2017-11-10T09:27:26.000Z","updated":"2017-12-12T04:46:12.836Z","comments":true,"path":"2017/11/10/开发学习/解决Mackeeper流氓软件引起的Chrome广告弹窗/","link":"","permalink":"http://www.cvblogs.cn/2017/11/10/开发学习/解决Mackeeper流氓软件引起的Chrome广告弹窗/","excerpt":"前言昨天，准确说应该是今早一点多的时候。不知道是怎么了，在下了YouTube一个推荐高效率App的视频中的软件之后，Chrome总是在我使用过程中弹窗MacKeeper的病毒广告。（主要下载了视频中推荐的几个软件：Hidden Me以及另外一个忘记了叫什么的管理Display的…发现并不好用，尽管他说的多么的好。其实自己用脚本完全能写的出来。这里暂且不表：）。然后，今天在使用过程中实在是不能忍了，于是乎。就上网查了一下。发现果然是中了套路，貌似还有点深。于是乎，就将自己解决的过程记录一下。并且调整了我解决问题的过程。我认为最关键的步骤被提前了。我始终认为是那几个步骤奏效的。","text":"前言昨天，准确说应该是今早一点多的时候。不知道是怎么了，在下了YouTube一个推荐高效率App的视频中的软件之后，Chrome总是在我使用过程中弹窗MacKeeper的病毒广告。（主要下载了视频中推荐的几个软件：Hidden Me以及另外一个忘记了叫什么的管理Display的…发现并不好用，尽管他说的多么的好。其实自己用脚本完全能写的出来。这里暂且不表：）。然后，今天在使用过程中实在是不能忍了，于是乎。就上网查了一下。发现果然是中了套路，貌似还有点深。于是乎，就将自己解决的过程记录一下。并且调整了我解决问题的过程。我认为最关键的步骤被提前了。我始终认为是那几个步骤奏效的。 更新方法发现下面的内容并不能根本解决问题，最后禁用了几个插件才解决了。以及删除了/Library/下的一些内容。 删除最近下载的软件不管问题是不是它引起的。反正我已经不打算用了。猎奇心理害死人啊。也有说是Lantern的问题。反正我也关了…. 删除启动项命令行打开启动项所在的两个目录：open /Library/LaunchDaemons以及open /Library/LaunchAgents删除掉近期的项目。我记得我主要是删除了一个com.pandasmite.plist的文件。起初用文本编辑器打开时，觉得还挺正常的。记得用一个字段是设置了一个3600。现在怀疑是脚本开启的间隔…（我也不想复现了…）。我是在执行了这些之后才不再弹窗的。顺便，你还可以删除其他一些你不想看到的开机自启动项目。比在用户和群组中管理自启动项目要方便一些。有的时候一些自启动项目并不在那里！ 应用商店下载EasyFind这是知乎上推荐的一个全盘搜索的软件，搜MacKeeper，不用区分大小写。果然找到两个，删除掉。顺便清空垃圾箱。 重启感觉解决这个问题，我电脑重启了四五次。感觉把这么久以来所有的重启次数都用完了！中间以为自己成功却没有的感觉真的是让人崩溃：）流氓软件真的可怕。 结束语：一些思考有说其利用的是DNS劫持。比较同意这个观点。它发起的第一个请求的网址似乎是一个app.yyys.com之类的，然后会定向到另一个网站，最后再定向到广告页面。其实说是lantern搞得鬼，我觉得也有可能。但是我之前用似乎都是好好的。反正现在已经不用烦恼了。话说，Mac系统不需要担心病毒却要担心流氓软件。好多人都是安装XPlayer的时候中招。幸亏我当时是安装的Moivst。","categories":[{"name":"网页开发","slug":"网页开发","permalink":"http://www.cvblogs.cn/categories/网页开发/"}],"tags":[{"name":"测试","slug":"测试","permalink":"http://www.cvblogs.cn/tags/测试/"}]},{"title":"linux之环境变量","slug":"开发学习/linux之环境变量","date":"2017-11-10T09:27:26.000Z","updated":"2017-12-10T12:31:13.267Z","comments":true,"path":"2017/11/10/开发学习/linux之环境变量/","link":"","permalink":"http://www.cvblogs.cn/2017/11/10/开发学习/linux之环境变量/","excerpt":"","text":"环境变量环境变量是指系统环境变量，对所有用户起作用，而用户环境变量只对当前用户起作用 由于一般情况下，我们的电脑只有一个主用户，所以在其中任何一个配置即可，当然以防万一你也可以只在系统环境变量下配置。 用户变量和系统变量的区别在于权限和实例。 系统变量则不同，任何时候都只有一套，不会随用户登录状况发生变化。","categories":[{"name":"网页开发","slug":"网页开发","permalink":"http://www.cvblogs.cn/categories/网页开发/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.cvblogs.cn/tags/Linux/"}]},{"title":"linux之curl添加Https","slug":"开发学习/linux_curl添加Https","date":"2017-11-09T14:55:11.000Z","updated":"2017-12-12T04:46:31.583Z","comments":true,"path":"2017/11/09/开发学习/linux_curl添加Https/","link":"","permalink":"http://www.cvblogs.cn/2017/11/09/开发学习/linux_curl添加Https/","excerpt":"前言系统时Ubuntu 16.04 今天有需要使用curl命令down一些https的内容。提示Protocol https not supported or disabled in libcurl。用curl -V一看发现支持的协议果然缺了https…上网查了一些资料，历经坎坷。总算最后解决了问题。整理备忘一下。","text":"前言系统时Ubuntu 16.04 今天有需要使用curl命令down一些https的内容。提示Protocol https not supported or disabled in libcurl。用curl -V一看发现支持的协议果然缺了https…上网查了一些资料，历经坎坷。总算最后解决了问题。整理备忘一下。 openssl可以用openssl version -a确认一下openssl是否已经安装，如果没有则需要下载安装。因为如果curl要支持https，就必须先安装openssl。 安装方法可以有两种方法进行安装。我用了第二种方法。 方法一12sudo apt-get install openssl sudo apt-get install libssl-dev 我试了并不好用。提示我安装libssl-dev安装的依赖包有版本冲突…遂放弃。 方法二到openssl官网下载压缩包 http://www.openssl.org/source/ 我这里下载的是openssl-1.0.1em.tar.gz123456tar zxvf openssl-1.0.1q ./config shared #（安装的默认路径是/usr/local/ssl，如果你想更改目录，请加上–prefix=/yourpath）这一步对后面正常覆盖安装curl更新协议非常关键 make make test sudo make install#必须用root权限安装，因为之前不看log...导致，一直以为自己安装是正确的 vim /etc/ld.so.conf在文件末尾加入 /usr/local/ssl/lib，刷新动态库配置用openssl version -a测试，可以正常log出相关信息。 curl记住自己之前安装openssl的路径。可以使用which openssl查看，我的在/etc/lib/openssl?有点记不太清了..123tar zxvf curl-7.30.0.tar.gz cd curl-7.30.0/ ./configure –with-ssl=/etc/lib/openssl#（我这里没有配置prefix选项，直接将curl安装到默认的目录/usr/local） config之后，会有以下信息打出，可以在Protocols一行确认一下是否引入了协议。要是没有就得再仔细找找问题。如果一切顺利，使用make之后再sudo make install。最后使用curl -V进行验证。 引用链接 curl 不支持 https ubuntu 14.04下安装openssl 结束语尽管距离解决完问题还没有一天但是还是有点忘记了具体的细节。因此备记一下还是有点必要的。另外，发现，本来想用echo $?来筛查错误命令返回码。但是发现有的命令不管错误还是正确总是返回0:）","categories":[{"name":"网页开发","slug":"网页开发","permalink":"http://www.cvblogs.cn/categories/网页开发/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.cvblogs.cn/tags/Linux/"}]},{"title":"web开发之NPM学习笔记","slug":"开发学习/web开发_NPM学习笔记","date":"2017-11-08T15:47:10.000Z","updated":"2017-12-10T13:08:07.644Z","comments":true,"path":"2017/11/08/开发学习/web开发_NPM学习笔记/","link":"","permalink":"http://www.cvblogs.cn/2017/11/08/开发学习/web开发_NPM学习笔记/","excerpt":"前言介绍了一些基本的概念，介绍了一些基本的npm操作。以及最后介绍了一下包的概念及相关管理操作等。","text":"前言介绍了一些基本的概念，介绍了一些基本的npm操作。以及最后介绍了一下包的概念及相关管理操作等。 什么是NPM？NPM(Node.js Packages Manager),是Node.js官方提供的一个包管理工具，用于Node.js包的发布、传播、依赖控制。因此，本质上它也是用Node.js写的一个包罢了。类似的还有：Bower。NPM对Node.js项目的意义。就像pip之于python，gem之于Ruby，pear之于PHP。它的一个很重要的作用就是：将开发者从繁琐的包管理工作（版本、依赖等）中解放出来，更加专注于功能的开发。 NPM的下载安装NPM跟随Node.js一起安装在全局，不需要单独安装。可以利用如下命令，查看一些相关信息：1234npm help #查看npm命令列表npm -l #查看各个命令的简单用法npm -v #查看npm 的版本npm config list -l #查看npm的配置 NPM使用npm initinit```用来初始化生成一个新的 ```package.json``` 文件。它会向用户提问一系列问题，如果你觉得不用修改默认配置，一路回车就可以了。123如果使用了``` -f```（代表```force```）、```-y```（代表```yes```），则跳过提问阶段，直接生成一个新的 ```package.json``` 文件。```consolenpm init -y npm setset```用来设置环境变量12345```consolenpm set init-author-name &apos;Your name&apos;npm set init-author-email &apos;Your email&apos;npm set init-author-url &apos;http://yourdomain.com&apos;npm set init-license &apos;MIT&apos; 上面命令等于为init```设置了默认值，以后执行```npm init```的时候，`package.json`的作者姓名、邮件、主页、许可证字段就会自动写入预设的值。这些信息会存放在用户主目录的` ~/.npmrc`文件，使得用户不用每个项目都输入。如果某个项目有不同的设置，可以针对该项目运行` npm config`。123456789### npm info`npm info`命令可以查看每个模块的具体信息。比如，查看 `underscore` 模块的信息。`npm info underscore`上面命令返回一个` JavaScript` 对象，包含了 `underscore` 模块的详细信息。这个对象的每个成员，都可以直接从 `info` 命令查询。```consolenpm info underscore descriptionnpm info underscore homepagenpm info underscore version npm searchnpm search命令用于搜索npm 仓库，它后面可以跟字符串，也可以跟正则表达式。npm search &lt;搜索词&gt; npm listnpm list 命令以树形结构列出当前项目安装的所有模块，以及它们依赖的模块。123npm list #加上 global 参数，会列出全局安装的模块npm list -global#npm list 命令也可以列出单个模块npm list underscore npm install使用npm 安装包的命令格式为：npm [install/i] [package_name] 本地模式和全局模式npm在默认情况下会从 NPM 搜索或下载包，将包安装到当前目录的 node_modules 子目录下。 如果你熟悉 Ruby 的 gem 或者 Python 的 pip ，你会发现 npm 与它们的行为不同， gem 或 pip 总是以全局模式安装，使包可以供所有的程序使用，而 npm 默认会把包安装到当前目录下。这反映了 npm 不同的设计哲学。如果把包安装到全局，可以提供程序的重复利用程度，避免同样的内容的多分副本，但坏处是难以处理不同的版本依赖。如果把包安装到当前目录，或者说本地，则不会有不同程序依赖不同版本的包的冲突问题，同时还减轻了包作者的 API 兼容性压力，但缺陷则是同一个包可能会被安装许多次。 我们在使用 supervisor 的时候使用了 npm install -g supervisor 命令，就是以全局模式安装 supervisor 。 这里注意一点的就是，supervisor 必须安装到全局，如果你不安装到全局，错误命令会提示你安装到全局。如果不想安装到默认的全局，也可以自己修改全局路径到当前路径 npm config set prefix &quot;路径&quot;安装完以后就可以用 supervisor 来启动服务了。supervisor 可以帮助你实现这个功能，它会监视你对代码的驱动，并自动重启 Node 。 一般来说，全局安装只适用于工具模块，比如 eslint 和 gulp 。关于使用全局模式，多数时候并不是因为许多程序都有可能用到了它，为了减少多重副本而使用全局模式，而是因为 本地模式不会注册 PATH 环境变量。“本地安装”指的是将一个模块下载到当前项目的 node_modules 子目录，然后只有在项目目录之中，才能调用这个模块。 本地模式和全局模式的特点如下： 模式 可通过 require 使用 注册 PATH 本地模式 是 否 全局模式 否 是 123$ npm install &lt;package name&gt;# 本地安装$ sudo npm install -global &lt;package name&gt;# 全局安装$ sudo npm install -g &lt;package name&gt; npm install也支持直接输入Github 代码库地址。12$ npm install git://github.com/package/path.git$ npm install git://github.com/package/path.git#0.1.0 安装之前，npm install 会先检查，node_modules 目录之中是否已经存在指定模块。如果存在，就不再重新安装了，即使远程仓库已经有了一个新版本，也是如此。 如果你希望，一个模块不管是否安装过， npm 都要强制重新安装，可以使用-f 或--force 参数。1$ npm install &lt;packageName&gt; --force 安装不同版本install 命令总是安装模块的最新版本，如果要安装模块的特定版本，可以在模块名后面加上 @ 和版本号。123$ npm install sax@latest$ npm install sax@0.1.1$ npm install sax@\"&gt;=0.1.0 &lt;0.2.0\" install 命令可以使用不同参数，指定所安装的模块属于哪一种性质的依赖关系，即出现在 packages.json 文件的哪一项中。 –save：模块名将被添加到 dependencies，可以简化为参数-S。–save-dev：模块名将被添加到 devDependencies，可以简化为参数-D。 12345$ npm install sax --save$ npm install node-tap --save-dev# 或者$ npm install sax -S$ npm install node-tap -D dependencies 依赖这个可以说是我们 npm 核心一项内容，依赖管理，这个对象里面的内容就是我们这个项目所依赖的 js 模块包。下面这段代码表示我们依赖了 markdown-it 这个包，版本是 ^8.1.0 ，代表最小依赖版本是 8.1.0 ，如果这个包有更新，那么当我们使用 npm install 命令的时候， npm 会帮我们下载最新的包。当别人引用我们这个包的时候，包内的依赖包也会被下载下来。123&quot;dependencies&quot;: &#123; &quot;markdown-it&quot;: &quot;^8.1.0&quot;&#125; devDependencies 开发依赖在我们开发的时候会用到的一些包，只是在开发环境中需要用到，但是在别人引用我们包的时候，不会用到这些内容，放在devDependencies的包，在别人引用的时候不会被 npm 下载。1234567891011&quot;devDependencies&quot;: &#123; &quot;autoprefixer&quot;: &quot;^6.4.0&quot;, &quot;babel-preset-es2015&quot;: &quot;^6.0.0&quot;, &quot;babel-preset-stage-2&quot;: &quot;^6.0.0&quot;, &quot;babel-register&quot;: &quot;^6.0.0&quot;, &quot;webpack&quot;: &quot;^1.13.2&quot;, &quot;webpack-dev-middleware&quot;: &quot;^1.8.3&quot;, &quot;webpack-hot-middleware&quot;: &quot;^2.12.2&quot;, &quot;webpack-merge&quot;: &quot;^0.14.1&quot;, &quot;highlightjs&quot;: &quot;^9.8.0&quot;&#125; 当你有了一个完整的 package.json文件的时候，就可以让人一眼看出来，这个模块的基本信息，和这个模块所需要依赖的包。我们可以通过 npm install 就可以很方便的下载好这个模块所需要的包。 npm install 默认会安装 dependencies 字段和 devDependencies 字段中的所有模块，如果使用--production 参数，可以只安装 dependencies 字段的模块。123$ npm install --production# 或者$ NODE_ENV=production npm install 一旦安装了某个模块，就可以在代码中用require 命令加载这个模块。12var backbone = require('backbone')console.log(backbone.VERSION) npm runnpm 不仅可以用于模块管理，还可以用于执行脚本。package.json 文件有一个 scripts 字段，可以用于指定脚本命令，供 npm 直接调用。package.json 文件内容：123456789101112&#123; \"name\": \"myproject\", \"devDependencies\": &#123; \"jshint\": \"latest\", \"browserify\": \"latest\", \"mocha\": \"latest\" &#125;, \"scripts\": &#123; \"lint\": \"jshint **.js\", \"test\": \"mocha test/\" &#125;&#125; scripts 脚本顾名思义，就是一些脚本代码，可以通过 npm run script-key 来调用，例如在这个 package.json 的文件夹下使用 npm run dev 就相当于运行了 node build/dev-server.js 这一段代码。使用 scripts 的目的就是为了把一些要执行的代码合并到一起，使用 npm run 来快速的运行，方便省事。npm run 是 npm run-script 的缩写，一般都使用前者，但是后者可以更好的反应这个命令的本质。12345678910// 脚本\"scripts\": &#123; \"dev\": \"node build/dev-server.js\", \"build\": \"node build/build.js\", \"docs\": \"node build/docs.js\", \"build-docs\": \"npm run docs &amp; git checkout gh-pages &amp; xcopy /sy dist\\\\* . &amp; git add . &amp; git commit -m 'auto-pages' &amp; git push &amp; git checkout master\", \"build-publish\": \"rmdir /S /Q lib &amp; npm run build &amp;git add . &amp; git commit -m auto-build &amp; npm version patch &amp; npm publish &amp; git push\", \"lint\": \"eslint --ext .js,.vue src\"&#125; npm run 如果不加任何参数，直接运行，会列出 package.json 里面所有可以执行的脚本命令。npm 内置了两个命令简写， npm test 等同于执行 npm run test ，npm start 等同于执行 npm run start。1\"build\": \"npm run build-js &amp;&amp; npm run build-css\" 上面的写法是先运行 npm run build-js ，然后再运行 npm run build-css ，两个命令中间用 &amp;&amp; 连接。如果希望两个命令同时平行执行，它们中间可以用 &amp; 连接。 写在scripts 属性中的命令，也可以在 node_modules/.bin 目录中直接写成 bash 脚本。下面是一个 bash 脚本。1234#!/bin/bashcd site/mainbrowserify browser/main.js | uglifyjs -mc &gt; static/bundle.js 假定上面的脚本文件名为 build.sh ，并且权限为可执行，就可以在 scripts 属性中引用该文件。1\"build-js\": \"bin/build.sh\" pre- 和 post- 脚本npm run 为每条命令提供了 pre- 和 post- 两个钩子（ hook ）。以 npm run lint 为例，执行这条命令之前， npm 会先查看有没有定义 prelint 和 postlint 两个钩子，如果有的话，就会先执行npm run prelint ，然后执行npm run lint ，最后执行 npm run postlint 。 12345678910111213&#123; \"name\": \"myproject\", \"devDependencies\": &#123; \"eslint\": \"latest\" \"karma\": \"latest\" &#125;, \"scripts\": &#123; \"lint\": \"eslint --cache --ext .js --ext .jsx src\", \"test\": \"karma start --log-leve=error karma.config.js --single-run=true\", \"pretest\": \"npm run lint\", \"posttest\": \"echo 'Finished running tests'\" &#125;&#125; 上面代码是一个 package.json 文件的例子。如果执行 npm test，会按下面的顺序执行相应的命令。123pretesttestposttest 如果执行过程出错，就不会执行排在后面的脚本，即如果 prelint 脚本执行出错，就不会接着执行 lint 和 postlint 脚本。 npm binnpm bin 命令显示相对于当前目录的，Node 模块的可执行脚本所在的目录（即 .bin 目录）。12$ npm bin # 项目根目录下执行./node_modules/.bin 创建全局链接 npm linknpm 提供了一个有趣的命令npm link，它的功能是在本地包和全局包之间创建符号链接。我们说过使用全局模式安装的包不能直接通过 require 使用。但通过 npm link 命令可以打破这一限制。举个例子，我们已经通过 npm install -g express 安装了 express ，这时在工程的目录下运行命令：npm link express ./node_modules/express -&gt; /user/local/lib/node_modules/express我们可以在 node_modules 子目录中发现一个指向安装到全局的包的符号链接。通过这种方法，我们就可以把全局包当做本地包来使用了。除了将全局的包链接到本地以外，使用 npm link 命令还可以将本地的包链接到全局。使用方法是在包目录（package.json 所在目录）中运行 npm link 命令。如果我们要开发一个包，利用这种方法可以非常方便地在不同的工程间进行测试。 创建包包是在模块基础上更深一步的抽象，Node 的包类似于 C/C++ 的函数库或者 Java 、.Net 的类库。它将某个独立的功能封装起来，用于发布、更新、依赖管理和版本控制。Node 根据 CommonJS 规范实现了包机制，开发了 npm 来解决包的发布和获取需求。Node 的包是一个目录，其中包含了一个 JSON 格式的包说明文件package.json。严格符合 CommonJS 规范的包应该具备以下特征： package.json 必须在包的顶层目录下； 二进制文件应该在 bin 目录下； JavaScript 代码应该在 lib 目录下； 文档应该在 doc 目录下； 单元测试应该在 test 目录下。 Node 对包的要求并没有这么严格，只要顶层目录下有 package.json，并符合一些规范即可。当然为了提高兼容性，我们还是建议你在制作包的时候，严格遵守 CommonJS 规范。 我们也可以把文件夹封装为一个模块，即所谓的包。包通常是一些模块的集合，在模块的基础上提供了更高层的抽象，相当于提供了一些固定接口的函数库。通过定制 package.json，我们可以创建更复杂，更完善，更符合规范的包用于发布。 Node 在调用某个包时，会首先检查包中 packgage.json 文件的 main 字段，将其作为包的接口模块，如果 package.json 或 main 字段不存在，会尝试寻找 index.js 或 index.node 作为包的接口。 package.json 是 CommonJS 规定的用来描述包的文件，完全符合规范的 package.json 文件应该含有以下字段： name: 包的名字，必须是唯一的，由小写英文字母、数字和下划线组成，不能包含空格。 description: 包的简要说明。 version: 符合语义化版本识别规范的版本字符串。 keywords: 关键字数组，通常用于搜索。 maintainers: 维护者数组，每个元素要包含 name 、 email(可选)、 web(可选)字段。 contributors: 贡献者数组，格式与 maintainers 相同。包的作者应该是贡献者数组的第一个元素。 bugs: 提交 bug 的地址，可以是网址或者电子邮件地址。 licenses: 许可证数组，每个元素要包含 type （许可证的名称）和 url（链接到许可证文本的地址）字段。 repositories: 仓库托管地址数组，每个元素要包含 type （仓库的类型，如 git）、URL（仓库的地址）和 path（相对于仓库的路径，可选）字段。 dependencies: 包的依赖，一个关联数组，由包名称和版本号组成。 包的发布通过使用npm init 可以根据交互式回答产生一个符合标准的 package.json。创建一个index.js 作为包的接口,一个简单的包就制作完成了。在发布前,我们还需要获得一个账号用于今后维护自己的包,使用 npm adduser 根据提示完成账号的创建完成后可以使用 npm whoami 检测是否已经取得了账号。接下来,在 package.json 所在目录下运行 npm publish，稍等片刻就可以完成发布了，打开浏览器，访问NPM搜索 就可以找到自己刚刚发布的包了。现在我们可以在世界的任意一台计算机上使用 npm install neveryumodule命令来安装它。如果你的包将来有更新,只需要在 package.json 文件中修改 version 字段,然后重新使用 npm publish命令就行了。如果你对已发布的包不满意，可以使用 npm unpublish 命令来取消发布。 需要说明的是： json 文件不能有注释 参考链接npm模块管理器by 阮一峰","categories":[{"name":"网页开发","slug":"网页开发","permalink":"http://www.cvblogs.cn/categories/网页开发/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://www.cvblogs.cn/tags/Node-js/"}]},{"title":"linux之Shell命令的状态码","slug":"开发学习/linux_Shell命令的状态码","date":"2017-11-07T17:59:10.000Z","updated":"2017-12-12T04:46:44.206Z","comments":true,"path":"2017/11/08/开发学习/linux_Shell命令的状态码/","link":"","permalink":"http://www.cvblogs.cn/2017/11/08/开发学习/linux_Shell命令的状态码/","excerpt":"前言记得我们写程序时常常会return一个状态码(exit status/codes)。经常，我都是乱来的。最常见就是返回0。如果出错返回负数，正确操作但是根据状态码来确定之后操作的时候就是返回正数。今天看到有说Shell也有返回状态码一说（并且十分严谨），想想也对，如果Shell的命令状态码不严谨。那不就乱套了吗..这篇文章就简单梳理一下。","text":"前言记得我们写程序时常常会return一个状态码(exit status/codes)。经常，我都是乱来的。最常见就是返回0。如果出错返回负数，正确操作但是根据状态码来确定之后操作的时候就是返回正数。今天看到有说Shell也有返回状态码一说（并且十分严谨），想想也对，如果Shell的命令状态码不严谨。那不就乱套了吗..这篇文章就简单梳理一下。 退出状态码是一个 0 ~ 255 之间的整数值，在命令结束运行时由命令传给shell。你可以捕捉这个值并在脚本中使用。 查看状态码Linux 使用了$? 专属变量来保存上个执行的命令的退出状态码。你必须在要查看的命令之后马上查看或使用$?变量。它的值会变成shell中执行的最后一条命令的退出状态码。 注意：$?是变量。所以要在控制台打印它。不能直接输入：$?,而是应该要使用echo这样的命令打印到控制台。 Linux 状态码的意义默认状态下，shell脚本会以脚本中的最后一个命令作为退出状态码。所以一般情况下，在shell脚本中以 exit 命令的值来指定shell命令的退出状态码。但是退出状态码的范围是 0 ~ 255, 退出值超出这个范围将会执行取模运算。例如通过exit 命令指定返回值为300，经过取模运算，那么退出状态码就为44.| Code | Description || :—: | :———————————–: || 0 | 命令成功结束 || 1 | 通用未知错误 || 2 | 误用shell命令 || 126 | 命令不可执行 || 127 | 没找到命令 || 128 | 无效退出参数 || 128+x | Linux 信号x的严重错误 || 130 | Linux 信号2 的严重错误，即命令通过SIGINT（Ctrl＋Ｃ）终止 || 255 | 退出状态码越界 | 用法说明exit命令用于退出当前shell，在shell脚本中可以终止当前脚本执行。常用参数格式：exit n退出。设置退出码为n。（Cause the shell to exit with a status of n.）格式：exit退出。退出码不变，即为最后一个命令的退出码。（If n is omitted, the exit status is that of the last command executed. ） 引用 Shell中的特殊变量$?-查看上一条Shell命令的退出状态码（exit status） shell 程序 返回码 退出码 Linux Shell 编程常见规则及退出状态码","categories":[{"name":"网页开发","slug":"网页开发","permalink":"http://www.cvblogs.cn/categories/网页开发/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.cvblogs.cn/tags/Linux/"}]},{"title":"python之批处理命名文件","slug":"开发学习/python_Python 批处理命名文件","date":"2017-11-07T05:53:10.000Z","updated":"2017-12-12T04:46:55.705Z","comments":true,"path":"2017/11/07/开发学习/python_Python 批处理命名文件/","link":"","permalink":"http://www.cvblogs.cn/2017/11/07/开发学习/python_Python 批处理命名文件/","excerpt":"前言最近经常上油管下东西，用的在线的网站”Youtube Multi Downloader Online”解析下载，还是蛮好用的（需要翻墙）。链接地址。就是每次下载下来视频都会带上前缀序号。有点烦人（取消勾选Add prefix order number还是不管用）。就打算用脚本语言处理一下。选了Python，可惜学了个半桶水，这么简单的东西，却总是在要用的时候，忘记该怎么写…索性整理出来备记一下。","text":"前言最近经常上油管下东西，用的在线的网站”Youtube Multi Downloader Online”解析下载，还是蛮好用的（需要翻墙）。链接地址。就是每次下载下来视频都会带上前缀序号。有点烦人（取消勾选Add prefix order number还是不管用）。就打算用脚本语言处理一下。选了Python，可惜学了个半桶水，这么简单的东西，却总是在要用的时候，忘记该怎么写…索性整理出来备记一下。 涉及的知识 字符串处理： 字符串查找 字符串切片 字符串拼接 基本的文件操作： 找出当前目录下的文件 重命名文件源码12345678#coding=utf-8import osdirf = \"/Users/Zoking/Downloads/graffle\"#文件所在目录indwx = \"0\" #删除的内容标志，需要区别for file in os.listdir(dirf): #列出dirf目录下的所有文件 if file.find(indwx) == 0: #找到需要删除的位置 nfile = file[3:len(file)] #切片 os.rename(os.path.join(dirf,file),os.path.join(dirf,nfile))#重命名文件rename(旧，新) 结束语感觉自己真的是心贪术不专，需要好好梳理一下！","categories":[{"name":"网页开发","slug":"网页开发","permalink":"http://www.cvblogs.cn/categories/网页开发/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.cvblogs.cn/tags/Python/"}]},{"title":"XMind Pro 8 Update5 下载破解安装指南 - 以Mac为例","slug":"开发学习/XMind-Pro-8-Update5-下载破解安装指南-以Mac为例","date":"2017-11-06T21:17:30.000Z","updated":"2017-11-06T21:21:21.000Z","comments":true,"path":"2017/11/07/开发学习/XMind-Pro-8-Update5-下载破解安装指南-以Mac为例/","link":"","permalink":"http://www.cvblogs.cn/2017/11/07/开发学习/XMind-Pro-8-Update5-下载破解安装指南-以Mac为例/","excerpt":"","text":"前言&emsp;&emsp;当前时间：2017年11月7日，此方法适用所有终端平台[Mac Win Linux]，只不过略有不同(例如一些文件的位置，但是还是能够在网上找到的)，由于笔者手头需要安装在Mac下，因此以Mac为例子讲解。 官网下载安装包 xmind官方地址：可能会比较慢 百度网盘地址：可能会很快失效 国内网站的版本是不行的(即xmind.cn以及你所搜到的最多的makeding上的)，已经被国内的二道贩子公司修改过了，所以是一定不可能破解的，要去英文官网下载。才能用补丁破解。 补丁下载破解 点击下载XMindCrack.jar：可能会很快实效 移动XMindCrack.jar到xmind安装目录文件夹下a. Finder–&gt;应用程序–&gt;XMind–&gt;右键–&gt;包内容–&gt;Contents–&gt;Eclipseb. 在XMind.ini 文末追加 -javaagent:/Applications/XMind.app/Contents/Eclipse/XMindCrack.jara. 注意此处最好添加绝对路径，并且一定不要安装在随手会被删除的地方:) 修改计算机的hosts文件,防止需要重复注册（即防止“流氓验证”）a. 打开Spotlight搜索：/private/etc/b. 选择在Finder中打开c. d. 下拉找到hosts,拷贝到其他地方用文本编辑器打开，对照着文件前面的格式，末尾追加:127.0.0.1 www.xmind.net 断网(其实已经不需要了，但是最好还是断网) 打开软件，邮箱任意即可，填写序列号1XAka34A2rVRYJ4XBIU35UZMUEEF64CMMIYZCK2FZZUQNODEKUHGJLFMSLIQMQUCUBXRENLK6NZL37JXP4PZXQFILMQ2RG5R7G4QNDO3PSOEUBOCDRYSSXZGRARV6MGA33TN2AMUBHEL4FXMWYTTJDEINJXUAV4BAYKBDCZQWVF3LWYXSDCXY546U3NBGOI3ZPAP2SO3CSQFNB7VVIY123456789012345 结束语&emsp;&emsp;这是我安装的最坎坷的一个软件（为此，我居然花了将近七个小时从10:00pm–05:00am），只能说XMind.cn实在是在防盗版这块做的很强大…以及他们的营销…&emsp;&emsp;分享给有需要的人。&emsp;&emsp;另外，如果你觉得这篇文章确实帮助到了你。可以通过下面的微信支付给我打赏:)谢谢。","categories":[{"name":"网页开发","slug":"网页开发","permalink":"http://www.cvblogs.cn/categories/网页开发/"}],"tags":[{"name":"测试","slug":"测试","permalink":"http://www.cvblogs.cn/tags/测试/"}]},{"title":"一些容易被我忘记的控制台命令以及快捷键","slug":"开发学习/一些容易被我忘记的控制台命令以及快捷键","date":"2017-11-05T11:47:26.000Z","updated":"2017-12-10T12:29:07.201Z","comments":true,"path":"2017/11/05/开发学习/一些容易被我忘记的控制台命令以及快捷键/","link":"","permalink":"http://www.cvblogs.cn/2017/11/05/开发学习/一些容易被我忘记的控制台命令以及快捷键/","excerpt":"","text":"一些容易被我忘记的控制台命令1234cd - #返回上一个访问的目录cat 文件名(|less) #在终端下查看文件cp 文件名 目标目录 #将文件拷贝到目标目录下control+d #中断a.out运行 一些浏览器快捷键1cmd + 鼠标点击 #在新标签页打开点击的链接","categories":[{"name":"网页开发","slug":"网页开发","permalink":"http://www.cvblogs.cn/categories/网页开发/"}],"tags":[{"name":"测试","slug":"测试","permalink":"http://www.cvblogs.cn/tags/测试/"}]},{"title":"大学专业课程简单总结","slug":"日常总结/个人总结_大学专业课程简单总结","date":"2017-11-03T17:32:10.000Z","updated":"2017-12-10T12:34:30.908Z","comments":true,"path":"2017/11/04/日常总结/个人总结_大学专业课程简单总结/","link":"","permalink":"http://www.cvblogs.cn/2017/11/04/日常总结/个人总结_大学专业课程简单总结/","excerpt":"前言&emsp;&emsp;这里就忽略掉一些有的没的的课了。如编译原理、计算机组成原理等。主要内容有：数据结构、算法、计算机网络、操作系统、数据库。","text":"前言&emsp;&emsp;这里就忽略掉一些有的没的的课了。如编译原理、计算机组成原理等。主要内容有：数据结构、算法、计算机网络、操作系统、数据库。 说说数据结构&emsp;&emsp;前段时间计算机专业外语课时，老师提到她无法区分：数据结构和数据类型的差别。惊觉，似乎我也是一知半解，之前根本没有这样的意识去好好的认识它们。不过还是很快的想到一个答案：数据结构（或者叫数据关系更恰当一些，总要有三种）： 1. 1对1（数组、链表、队列、栈为代表的） 2. 1对N（树） 3. N对N（图） 4. 可能还存在没有关系的：集合... 数据类型： 5. 基本数据类型：整型、浮点型、字符型、字符串型、布尔型（有些编程语言还有未定义类型...） 6. 自定义类型：针对基本数据类型结合数据结构进行封装得到的数据类型 &emsp;&emsp;针对数据结构，感觉还是要增加自己的理解才行（以上也是个人理解，可能不是很准确）。不能死记硬背，否则面试时也无法答出面试官抛出的问题。 说说算法&emsp;&emsp;感觉自己在实际做项目中基本不考虑算法的分析（根本上，我们写的也不是算法而是业务罢了）。但是依旧觉得这门课程时分的重要。但是也是异常困难的。大学这段时间，几乎每个学年我都想要好好的去学习算法知识。但是每每以失败告终。尽管考试成绩不错，我始终无法做到遇到一个问题设计出一个优秀的算法去解决。根本上我没有建立起利用算法套路解题的思路！非常遗憾。&emsp;&emsp;基本的算法： 0. 递归 1. 分治 2. 回溯 3. 贪心 4. 枚举 5. 动态规划 &emsp;&emsp;这段也是凭借记忆…可能非常不正确，反正我是一样都没掌握清楚。写个动态规划根本不懂该如何下手。还是得靠练习啊！ 说说计算机网络&emsp;&emsp;学校里的计算机网络只教授原理，总觉得它们都这么的粗糙。我所理解的网络还停留在HTTP的网站上。而不是，背后的网络。所以一开始观念就不对，因此也就学的半桶水了。不过作为应用层的HTTP的确很强大。以及传输层的TCP协议（三次握手、四次挥手建立可靠的面向连接的传输）。&emsp;&emsp;但是，应用层的HTTP是无连接的。因此，要通过服务器端的Session机制以及客户端的Cookies机制进行维护连接。 说说操作系统&emsp;&emsp;操作系统!=Windows。作为计算机专业的学生，知道操作系统不止一个是多么的关键。但是，即使知道这些，作为一个小白，我该如何能够去一次性去体验一把呢？毕竟实践出真知嘛。最简单的办法就是通过安装虚拟机（推荐VirtualBox），运行镜像系统文件来达到体验的目的。 1. Windows 2. Linux：Ubuntu、DeepIn、Kylin、CentOS、Mint、Red Hat... 3. Unix：MacOS（之前天真的以为Unix == MacOS...） &emsp;&emsp;这些系统镜像都很好获得，VirtualBox的安装方式也只需下一步。体验一下其他操作系统，对于以后的学习可能会比较深刻。绝对是有好处的。按我说，计算机专业的第一门专业课：C语言当时就应该用Ubuntu上实验课。&emsp;&emsp;针对大学时教授的基础知识，总觉得太过粗糙，暂未感受到它的魅力。 说说数据库&emsp;&emsp;SQL和NoSQL也是在这段时间得到了解的。以前的世界里一直只有关系型数据库（虽然学的也不好），但是一直有疑问，研究数据库的人在研究什么？不是已经有数据库产品可供使用了嘛？并且性能也不错。为什么还要去研究？有什么值得研究的呢？经过简单了解，真的觉得自己以前是井底之蛙。&emsp;&emsp;总算理解老师说的：MySQL、Oracle这些只是数据库产品的意思。它只是数据库的冰山一角。虽然你最早看到的是它。但是它却远远不止这些。近期主要接触的是NoSQL：简单的Nedb以及较为复杂的MongoDb。以及最近几天接触的时序性数据库TSDB！姿势水平得到了一定的提升。&emsp;&emsp;我觉得这一切的基础，除了建立最一般的概念。可能更多的还是会和之前的关系型数据库那一套有点关系。 结束语&emsp;&emsp;感觉自己有点话唠，主要还是吐槽。大概是写不了代码只好来写点Markdown求个心理安慰吧。","categories":[{"name":"网页开发","slug":"网页开发","permalink":"http://www.cvblogs.cn/categories/网页开发/"}],"tags":[{"name":"测试","slug":"测试","permalink":"http://www.cvblogs.cn/tags/测试/"}]},{"title":"web开发之开发总结","slug":"日常总结/web开发_学习工作简单总结","date":"2017-11-03T17:19:11.000Z","updated":"2017-12-10T13:09:51.034Z","comments":true,"path":"2017/11/04/日常总结/web开发_学习工作简单总结/","link":"","permalink":"http://www.cvblogs.cn/2017/11/04/日常总结/web开发_学习工作简单总结/","excerpt":"前言&emsp;&emsp;最近接触了一些新知识，主要是Web开发以及以后研究生要接触的东西。整体而言，对两个领域都非常的有兴趣。但是，这两个的技术栈确是非常不同的。取舍之间。究竟该做到怎样的平衡才能对以后的学习工作有所帮助是非常关键的。&emsp;&emsp;以下内容更多的是自己的琐碎思考。有对自己目前学到的Web开发知识的总结，也有关于研究生内容学习的简单介绍。","text":"前言&emsp;&emsp;最近接触了一些新知识，主要是Web开发以及以后研究生要接触的东西。整体而言，对两个领域都非常的有兴趣。但是，这两个的技术栈确是非常不同的。取舍之间。究竟该做到怎样的平衡才能对以后的学习工作有所帮助是非常关键的。&emsp;&emsp;以下内容更多的是自己的琐碎思考。有对自己目前学到的Web开发知识的总结，也有关于研究生内容学习的简单介绍。 新技术的魅力&emsp;&emsp;“铁打的技术，流水的框架。” 基础的基础&emsp;&emsp;HTML5、CSS3、Javascript&emsp;&emsp;HTML5是一种标记语言，通过HTTP协议(目前是1.1版本)在网络上传输。它定义了一个网页的框架。现在的Web开发已经很少使用原生的HTML去写网页。而是通过封装(利用原生HTML的Frameset的概念)，利用模板引擎进行更高效的书写网页。&emsp;&emsp;CSS3定义了样式。一张网页好不好看是由元素(HTML定义)的样式所决定的。现在的技术（例如：Sass和Less等）通过引入编译的概念进行高效的书写。&emsp;&emsp;Javascript作为一种脚本语言。基本上你可以利用它完成任何事情。但是在Node.js等框架没有被写出来以前，工作于前端主要用于控制一些简单的交互。而之后引入的其他技术（JQuery、AJAX）使其在Web开发中的作用越来越重。&emsp;&emsp;通常情况下，（针对一般的前端工作人员）基本不自己写这些样式。而是通过引入第三方库进行更高效的开发。各家互联网公司基本都维护着自己的一套前端框架。这也是为什么前面会说“铁打的技术，流水的框架。”&emsp;&emsp;因此，在学习这些东西用这些东西的时候一定要学会站在前人的肩膀上解决问题。 说说Node.js那一套&emsp;&emsp;Node作为一个框架可以说是非常的灵活，的确有种搭积木玩代码的感觉。但是，也不得不让人担心它的性能。它究竟适合的是什么类型的系统开发。&emsp;&emsp;在学习Node的过程中，我的确感受到了它的包容和强大。通过它认识了很多有趣的实际Web开发过程中（尚未参与生产）可能会使用的工具以及工作的流程和环境。&emsp;&emsp;主要是建立Web应用的话是用Express.js。然后利用模板引擎实现前后端的分离。 说说Python&amp;&amp;Vue&amp;&amp;Django那一套&emsp;&emsp;不是非常的了解，但是Python和Javascript一样都是脚本语言。它也很强大。以上是Python做Web开发的一套。具体还未了解。&emsp;&emsp;其实Python我也是一个半吊子。不过真的是一门强大的语言啊。以后的工作也很大程度上会使用它。 一些框架&emsp;&emsp;还未怎么了解，但是却是很不错的一些东西。 Bootstrap React Semantic Angular 未来的研究MedIA&emsp;&emsp;算是新兴的交叉学科？结合的是医学、物理、视觉以及机器学习的东西。&emsp;&emsp;主要是通过曹P的那次机会才有机会认识到这个有趣的东西，其实做曹CH的项目接触图像处理，感觉对很多东西都有兴趣并建立了概念。之后做东西能够代入情景也就接受很多。&emsp;&emsp;IIT的Deboot老师真的是一个好老师！如果我们专业的老师都能是这个水平授课该有多好！（其实，曹C和冯ZL都算是了，还有栗W。）&emsp;&emsp;简单梳理一下目前都学了什么： 医学：中国医科大学的30课、IIT的前五课基础医学影像概念 视觉：主要是弗罗里达的课程 图像处理：吴福朝 机器学习：吴恩达、李飞飞前六课、Ian Goodfellow &emsp;&emsp;任重而道远，似乎每一项我都有接触，但是真正让我干嘛。我可能还是干不好！其实仔细想想，我真正去研究有可能也只是一年的时间？我有可能真的通过目前的一点一点积累，最终达到发表会议的目标吗？真的很难！之前订的研究计划一项都没完成。可是已经十一月了。感觉一切都是瞎搞。 结束语&emsp;&emsp;基本上，这些东西的学习我都很大程度上依赖于视频教程以及一些基本的教材wiki。如果真正想要去巩固，真的是得逼自己一把。找开源的项目做一做。&emsp;&emsp;其实真的说出来，这些似乎也没多少东西。但是的的确确。需要建立一个知识图谱一般的印象！没有梳理之前还觉得有多么的复杂。看来以后有必要建立一点点的知识结构了！否则根本不知道自己到达什么水平，也就三分钟热度的放弃了！","categories":[{"name":"网页开发","slug":"网页开发","permalink":"http://www.cvblogs.cn/categories/网页开发/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://www.cvblogs.cn/tags/Node-js/"}]},{"title":"工作开发中的一些工具","slug":"日常总结/个人总结_工作开发中的一些工具","date":"2017-11-03T17:08:10.000Z","updated":"2017-12-10T12:34:59.362Z","comments":true,"path":"2017/11/04/日常总结/个人总结_工作开发中的一些工具/","link":"","permalink":"http://www.cvblogs.cn/2017/11/04/日常总结/个人总结_工作开发中的一些工具/","excerpt":"前言&emsp;&emsp;聊点浏览器的认识以及编程工具的认识以及一些概念的了解。","text":"前言&emsp;&emsp;聊点浏览器的认识以及编程工具的认识以及一些概念的了解。 业务的基础&emsp;&emsp;尽管上过软件工程课，但是对于只会念PPT和只会划水的我来说。通过最近一段时间的学习。终于搞清楚的一些业务概念。 业务的对象：2B（to Business）、2C（to Customer）和2G（to Government） 系统的架构：B/S（Browser/Server）、C/S（Client/Server） 说说浏览器&emsp;&emsp;在这之前，我只听说过浏览器内核这个概念。也只是简单的使用Firefox浏览网页（并不深度是用，只听说Firefox蛮好用，但是自己却一直用着Edge或者后来的Safari以及Chrome）。也听说过Opera浏览器的小巧（依旧未尝试）。正因为内核的不同导致的在兼容性上存在很多问题，特别是令人闻风丧胆的IE6兼容问题。所做的笔记有点忘记了，这里简单罗列划分一下。&emsp;&emsp;主要有四类： Edge为首的IE系列（QQ、360…） Chrome、Safari系列 Firefox… Opera… 使用一个浏览器的Tips&emsp;&emsp;浏览器的插件使浏览器的性价比得到提高。因此，当我们想要使用一个浏览器。我们应当要善于利用搜索引擎查询自己的需要对应的各家浏览器的插件都有哪些。或者直接搜索那种别人整理的插件top列表进行安装。好的插件大大提升我们的用户体验和工作效率。 说说编程工具&emsp;&emsp;也许是用了一段时间的Linux、Mac，由于学校的课业需要。不同的课设作业，不同的语言环境不同的IDE，尽管做了挺多项目（虽然大部分还是拿着别人的东西改改改）。但是，发现自己依旧没有能够熟练的去使用IDE。一个IDE安装配置时是什么样子。可以保证，我用它完成工作之后就会清除使用它的记忆。于是乎，三年时间。工具换了很多，可是使用工具的效率依旧是低于正常水平。这一点，从提升个人能力甚至是业务能力都是有害的。 我用过的IDE以及编辑器&emsp;&emsp;简单梳理一下我都用过哪些IDE和编辑器，其实依靠强大的插件，有些编辑器堪比IDE，应付简单的编程绰绰有余。只不过非常可惜当时自己不会用罢了。一些技术推荐的帖子也只是喊个名号，像我这种小白于是也就只闻其声不见其人。因此即使安装上，也依旧还是别人家的东西。&emsp;&emsp;使用工具，一定要提前花上一天时间。去了解一个工具具体应该怎么用。 我用过的IDE VS2013-&gt;VS2017：C、C++ （主要是拿Cocos-2dx写的游戏）、 C# Eclipse：纯粹的Java开发，只用一个Java Swig… XCode：C、C++、尽管大一、大二尝试学习iOS开发，但是失败（总结可能是课业的问题，现在已经没有兴趣了）。 IDEA：一直没搞懂，是直接念大写字母好还是念成英文单词好。主要用于Java Web以及现在做的前端开发（目标IDE了，插件等功能都很好用） 我用过的编辑器 Notepad++：在Windows上用于编辑文本，可惜根本就没有发挥它的性能。 Sublime Text 3：之前也只是纯粹的用它读写文件，感觉自己真的是傻到爆炸。目前来说，算是打算用它了。也在慢慢的养成肌肉记忆的能力。 Vim：强大的编辑器。有了配置文件（GitHub拿的大佬的），体验真的是超级无敌棒。 Atom：今天刚认识的一个跨平台编辑器。似乎也很棒的样子。GitHub公司的。 其他提升效率的工具&emsp;&emsp;每次真正发挥出一个工具的效率的时候都感觉自己之前都白白浪费了许多的时间。 Office办公软件：其实它们都是一套的。所以掌握一个就可以推广开来。 好用的OneNote笔记：暂时还未发现有什么不好的地方。而且今天使用打印PDF到当前位置功能。简直感叹自己真他妈是个傻逼。连这个都他妈不会用！但是可能后期需要购买空间吧？因为免费的空间只有5G。 PhotoShop：算不上工作应用。但是很好玩，但是还是时间比较短了。希望以后能够更多的去使用！ 百度脑图：真的不错的一款在线思维导图应用。比起ProcessOn，大概就是免费的空间了。老实说，感觉自己并没有真正发挥它的功效啊！ lantern：翻墙工具！GitHub下载。相见恨晚啊。 另外大概就是用好快捷键了233 结束语&emsp;&emsp;似乎自己真的认识到很多的东西，但是，更实在的是：自己想要深入的去发展却很难做到。最终怕是自己的技能树点的太大，但是主干却很细。因此坚定下来做偏全栈的工作真的很有趣，但是也让人担心以后的前程。&emsp;&emsp;感觉自己应该要好好的去规划一下究竟应该怎么更好的学习了。","categories":[{"name":"网页开发","slug":"网页开发","permalink":"http://www.cvblogs.cn/categories/网页开发/"}],"tags":[{"name":"测试","slug":"测试","permalink":"http://www.cvblogs.cn/tags/测试/"}]},{"title":"医学影像技术概述:X-ray、CT、MRI","slug":"理论学习/media-image-intro","date":"2017-10-30T16:36:18.000Z","updated":"2017-10-30T16:42:42.000Z","comments":true,"path":"2017/10/31/理论学习/media-image-intro/","link":"","permalink":"http://www.cvblogs.cn/2017/10/31/理论学习/media-image-intro/","excerpt":"前言&emsp;&emsp;近年来，医学影像分析(Medical Image Analysis)作为一个新兴的交叉学科，结合医学影像以及计算机视觉和机器学习技术在学术界和工业界都得到了广泛的关注。对于以后要从事该领域的研究来说，形成对医学影像的结构性认识是非常有必要的。本节内容结合2004年中国医科大学-医学影像网络课程中前几讲关于目前常用的医学影像技术的原理等内容，做一个简单的梳理和介绍。","text":"前言&emsp;&emsp;近年来，医学影像分析(Medical Image Analysis)作为一个新兴的交叉学科，结合医学影像以及计算机视觉和机器学习技术在学术界和工业界都得到了广泛的关注。对于以后要从事该领域的研究来说，形成对医学影像的结构性认识是非常有必要的。本节内容结合2004年中国医科大学-医学影像网络课程中前几讲关于目前常用的医学影像技术的原理等内容，做一个简单的梳理和介绍。 常用医学影像技术及成像特点&emsp;&emsp;目前常用的医学影像技术主要有三类： X射线成像(X-ray)：经济简便、应用广泛。常用作胸部病变的基本检查方法 CT(电子计算机断层扫描:Computed Tomography)：易于发现病变、显示病变特征。增强扫描以了解病变的血供情况。 US(超声成像:UltraSound) MRI(磁共振:Magnetic Resonance Image)：多用于纵膈和肺门病变的诊断X射线成像&emsp;&emsp;本小节简单分析了一下过去普通X线成像以及现在常用的数字X线成像技术。产生以及成像特点&emsp;&emsp;X线是在真空管内通过高速行进的电子流轰击钨靶时产生。与X线成像相关的四个特性： 穿透性：X线成像的基础（吸收与衰减，穿透与管电压，厚度与密度） 荧光效应：透视的基础 摄影效应：通过胶片感光剩余的X线形成潜影后经由显定影液处理后产生黑、白图像。 电离效应(生物效应)：是其被用作癌症放疗的基础 &emsp;&emsp;X线图像特点为灰阶图像(白:高密度，灰:软组织，黑:低密度)，反映人体组织结构的解刨及病理状态。缺点是影像重叠、放大、失真。 X线检查技术 普通检查:荧光检查、X线摄影 特殊检查:软线摄影、放大摄影、荧光摄影、记波摄影 造影检查:需要打造影剂，通常对人体有一定损害。造影剂按阴阳性分为两大类。 数字X线成像&emsp;&emsp;将普通X线摄影装置同计算机结合，使得X线信息由模拟信息转换为数字信息。现在大部分采用的X线成像方式均是数字式。通过数字X线成像技术，得到的数字信号可以通过调节窗宽窗位观察不同组织的情况。还可以对图像的局部进行放大分析。&emsp;&emsp;它的优点就是数字化。也是目前医学影像计算这个新兴学科发展的基础。 CT成像&emsp;&emsp;需要注意的是，CT也是属于放射性质的医学检查。不同的是其是对人体的断面(通常是轴位，也就是横切面)进行扫描得到。因此，当我们拿到一张CT片子的时候需要建立一种立体的感觉。 常见概念&emsp;&emsp;三个重要的概念：体素、矩阵和像素。常用的空间分辨率为:512x512。另外需要注意的是其密度分辨率常用灰阶表示。 常用临床CT检查技术 平扫 静脉增强造影 动态增强扫描 三维重建 造影CT CT血管造影(CTA) CT透视 MRI磁共振&emsp;&emsp;与前两者的成像原理有很大的不同。也叫核磁共振nMRI，通常省略了nuclear的n。 基本内容&emsp;&emsp;利用原子核在磁场内所产生的信号经过重建形成影像的一种技术(因此不可以在做核磁共振的时候体内藏有金属物质或者让金属物质靠近磁场)。对神经系统和软组织有很好的显示能力。利用的是不同组织的T1时间和T2时间不同(特点：反映组织间的信号强度，灰阶成像)。不同的扫描序列和成像参数如下： T1加权像:反映组织间T1的差别，有利于观察解刨结构。 T2加权像:反映组织间T2的差别，显示病变组织好。 质子加权像 自旋回波(SE) 梯度回波(GE) 平面回波 磁共振检查技术&emsp;&emsp;根据调节参数，主要有以下几种基于MR的检查技术。值得关注的是进来针对神经影像中的fMRI的研究。 平扫(T1WI、T2WI、PDWI) 增强(T1WI) 动态增强(Dynamic MR) 磁共振血管造影(MRA) 脂肪抑制成像(STIR) 水抑制成像(FLAIR) 水成像(MRCP、MRU、MRM) 灌注成像(Perfusion) 弥散成像(Diffusion) 功能成像(function MR) 医学影像计算MIC的兴起&emsp;&emsp;前面介绍了几种常用的医学影像计算。通过它们能够获取到关于人体组织的影像。可以借助这些影像技术，医生通过分析病人影像，在不解刨正常人体的情况下，得出更科学的医学论断。然而医学影像的特殊性(同病异影、异病同影)造成人工分析时，由于个人的经验不足等问题导致其常常出现误诊、漏诊的情况。&emsp;&emsp;随着人工智能的发展，我们考虑是否可以借助计算机视觉的技术和机器学习的技术来通过计算机计算达到辅助诊断的目的。以提高影像诊断的正确率。而也正是因为医学影像同病异影、异病同影的特殊性，所以就要求我们在数据处理时还要结合临床表现的数据进行多模态的分析。同时，对于在辅助诊断过程中，提出多个疾病的概率占比也是非常有必要的。这些也是目前MIC中的热点研究方向。 结束语&emsp;&emsp;在学习了这几讲内容之后，对之后所要从事的内容有了更深入的了解，也激起了我对医学影像计算研究的热情。好几次产生这样一种心情：如果要写很酷的应用的话，不过几年，新旧技术更迭就会被人们遗忘，或者不过几年现在可以被称为酷的东西也只不过是一个小烟花，可能只有一瞬的灿烂，但是却无法产生任何影响。但是，如果是做医学方向的新兴研究，至少所做的内容说不好会对人类的健康有所帮助？&emsp;&emsp;记得以前在某博上看到一个硕士前辈说过为什么当初执意读研执意读计算机视觉方向时提到过(原话忘了，但是大意如下)：“参与学术研究是我们作为人类参与人类进度最简单的方法，至少希望通过自己的一点点努力，能够对后来人有一点点的帮助也是有意义的。”&emsp;&emsp;不忘初心，方得始终。希望也能够通过自己的努力，对后来人有一点点的帮助。对人类的进步有一点点帮助。 引用 中国医科大学-医学影像网络公开课","categories":[{"name":"医学影像计算","slug":"医学影像计算","permalink":"http://www.cvblogs.cn/categories/医学影像计算/"}],"tags":[{"name":"课程总结","slug":"课程总结","permalink":"http://www.cvblogs.cn/tags/课程总结/"}]},{"title":"读书笔记:Ian Goodfellow《深度学习》第六章","slug":"理论学习/deep-learning-ian-goodfellow-chap6-bp","date":"2017-09-26T13:10:04.000Z","updated":"2017-10-01T07:54:09.000Z","comments":true,"path":"2017/09/26/理论学习/deep-learning-ian-goodfellow-chap6-bp/","link":"","permalink":"http://www.cvblogs.cn/2017/09/26/理论学习/deep-learning-ian-goodfellow-chap6-bp/","excerpt":"前言&emsp;&emsp;今天看Ian Goodfellow的《深度学习》第六章，讲到神经网络的概念。其从前馈神经网络讲到基于微分的链式法则。然后讲到基于反向传播的神经网络的数学基础。老实说，看完之后，虽然笔记记了三、四页。但是还是很懵逼。在李飞飞的CS231n课程中也提到了关于反向神经网络是如何得出的。但是始终没能做到完全吸收理解。总觉得其理论支撑非常虚。&emsp;&emsp;记得看Andrew采访Hilton的时候，也谈到了反向传播(Error Back Propagation)这个概念。这里暂时不追溯历史了。简单总结一下自己接下来学习到的关于反向传播的内容。可能有些地方理解不到位。后面也在慢慢修正自己的理解。","text":"前言&emsp;&emsp;今天看Ian Goodfellow的《深度学习》第六章，讲到神经网络的概念。其从前馈神经网络讲到基于微分的链式法则。然后讲到基于反向传播的神经网络的数学基础。老实说，看完之后，虽然笔记记了三、四页。但是还是很懵逼。在李飞飞的CS231n课程中也提到了关于反向神经网络是如何得出的。但是始终没能做到完全吸收理解。总觉得其理论支撑非常虚。&emsp;&emsp;记得看Andrew采访Hilton的时候，也谈到了反向传播(Error Back Propagation)这个概念。这里暂时不追溯历史了。简单总结一下自己接下来学习到的关于反向传播的内容。可能有些地方理解不到位。后面也在慢慢修正自己的理解。 基础概念&emsp;&emsp;在分析算法之前，先来梳理一下几个算法中的基础概念。 神经元&emsp;&emsp;神经网络中的结点被称为神经元。他们之间通常通过带权重的边进行有向连接。 输入层、隐藏层、输出层&emsp;&emsp;由输入结点组成的层称为输入层。由输出结点组成的层称为输出层。中间的结点组成的各层统称为隐藏层(其对外界不可见，似乎被隐藏了起来)。 激活函数&emsp;&emsp;通常选用sigmoid函数，又称Logistic函数作为激活函数。关于sigmoid函数的性质，这篇博客总结的不错。&emsp;&emsp;其主要作用是，提供网络的非线性建模能力。否则你的网络中的结点之间都是线性关系，不论设置多少隐藏层学习的效果都是一样的。&emsp;&emsp;关于激活函数的讨论有很多。这篇文章总结的很不错。其中还提到了一个代价函数的概念。 损失函数或叫代价函数&emsp;&emsp;BP算法中，提到了一个关于残差的概念。发现很多地方都利用残差对算法进行优化。也有将其称为敏感度；残差可以看做是对偏置参数b的导数，偏置变化多少，残差就变化多少，残差就是偏置的变化率。当误差大的时候，权重更新就快，当误差小的时候，权重的更新就慢。 正向传播、反向传播&emsp;&emsp;正向传播时，输入样本从输入层进入网络，经隐层逐层传递至输出层，如果输出层的实际输出与期望输出(导师信号)不同，则转至误差反向传播；如果输出层的实际输出与期望输出(导师信号)相同，结束学习算法。&emsp;&emsp;反向传播时，将输出误差(期望输出与实际输出之差)按原通路反传计算，通过隐层反向，直至输入层，在反传过程中将误差分摊给各层的各个单元，获得各层各单元的误差信号，并将其作为修正各单元权值的根据。这一计算过程使用梯度下降法完成，在不停地调整各层神经元的权值和阈值后，使误差信号减小到最低限度。 算法缺陷 局部极小值 权值过多 算法终止策略 过拟合 引用 多层神经网络BP算法 原理及推导 BP算法与公式推导 神经网络——BP算法 BP 算法之一种直观的解释 BP算法_百度百科 结束语&emsp;&emsp;阅读文章过程中，看到有说神经网络还有很多分支，如深度神经网络，脉冲神经网络等，并说脉冲神经网络被称为第三代神经网络。这里实在是不知道，留作以后再了解。&emsp;&emsp;感觉可以这么理解，如果不引入反向传播，在正向传播中，你也可以得到一个答案。但是这个答案有可能不是最好的。因此，你可以利用这个结果误差进行反向指导。而反向指导所利用的一个重要的数学基础知识就是基于函数微分的链式规则(chain rule)。通过这个误差不断的修正权重矩阵的各个权重以及每层设置的偏置。&emsp;&emsp;最后发现自己看书实在是囫囵吞枣，作者的千分之一都没能领悟啊。后续再添加程序实现以及相关数学推导。","categories":[{"name":"深度学习","slug":"深度学习","permalink":"http://www.cvblogs.cn/categories/深度学习/"}],"tags":[{"name":"学习总结","slug":"学习总结","permalink":"http://www.cvblogs.cn/tags/学习总结/"}]},{"title":"数学基础：矩阵范数及latex公式编辑","slug":"理论学习/basic-math","date":"2017-09-25T08:22:10.000Z","updated":"2017-09-25T12:21:30.000Z","comments":true,"path":"2017/09/25/理论学习/basic-math/","link":"","permalink":"http://www.cvblogs.cn/2017/09/25/理论学习/basic-math/","excerpt":"前言&emsp;&emsp;在学习过程中，发现似乎在最优化问题上常常通过范数进行计算。于是，这里简单梳理一下关于范数的基础知识。范数是数学中的一个基本概念(经常能看到它的身影，只不过它利用$\\parallel \\cdot \\parallel $符号进行表示，使我们不易认出它。举个例子：我们常使用的，一维世界中，衡量两点间的距离就是使用的1范数)，范数属于线性代数、泛函分析中的内容。掌握范数的基础知识对于以后的研究工作很有必要。&emsp;&emsp;其常常被用来度量某个向量空间（或矩阵）中的每个向量的长度或大小。这里，我们将只讨论矩阵范数相关的内容。","text":"前言&emsp;&emsp;在学习过程中，发现似乎在最优化问题上常常通过范数进行计算。于是，这里简单梳理一下关于范数的基础知识。范数是数学中的一个基本概念(经常能看到它的身影，只不过它利用$\\parallel \\cdot \\parallel $符号进行表示，使我们不易认出它。举个例子：我们常使用的，一维世界中，衡量两点间的距离就是使用的1范数)，范数属于线性代数、泛函分析中的内容。掌握范数的基础知识对于以后的研究工作很有必要。&emsp;&emsp;其常常被用来度量某个向量空间（或矩阵）中的每个向量的长度或大小。这里，我们将只讨论矩阵范数相关的内容。 范数的基本性质&emsp;&emsp;任何范数都必须满足以下三个性质: 非负性 齐次性 三角不等式&emsp;&emsp;矩阵范数还需满足相容性：$\\parallel {XY} \\parallel $$\\leq $$\\parallel X \\parallel $$\\parallel Y \\parallel$。因此也称其为相容范数。 常用的三种$p$范数推导出的矩阵范数1-范数&emsp;&emsp;也叫列和范数，A每一列元素绝对值之和的最大值。&emsp;&emsp;其中，&emsp;&emsp;其余类似. 2-范数&emsp;&emsp;谱范数，即$A^H$ * $A$特征值$\\lambda_i$中最大者$\\lambda_1$的平方根，其中$A^H$为$A$的转置共轭矩阵. ∞-范数：&emsp;&emsp;（行和范数，A每一行元素绝对值之和的最大值） (其中$\\sum \\parallel a_{1j} \\parallel $ 为第一行元素绝对值的和，其余类似); 其它的p-范数&emsp;&emsp;没有很简单的表达式。对于$p$-范数而言，可以证明:&emsp;&emsp;其中p和q是共轭指标。简单的情形可以直接验证：&emsp;&emsp;一般情形则需要利用: 引用 百度百科 CSDN Markdown简明教程3-表格和公式 机器学习中常见的字母解析及MarkDown代码 结束语&emsp;&emsp;才发现不总结真的不行，又把之前学过的知识忘记了。总之，在图像处理中，矩阵范数这个概念真的非常重要。&emsp;&emsp;另外针对markdown中数学公式的书写真的是一大硬伤。需要花时间好好学习一下$latex$的语法。才发现百度百科里的公式都不是正规的$latex$书写的。&emsp;&emsp;从四点开始写总结，八点才写完…$latex$公式真可怕。生产力杀手啊…最后还是靠的在线编辑器…","categories":[{"name":"图像处理","slug":"图像处理","permalink":"http://www.cvblogs.cn/categories/图像处理/"}],"tags":[{"name":"数学基础","slug":"数学基础","permalink":"http://www.cvblogs.cn/tags/数学基础/"}]},{"title":"孟宁《软件工程C实战》实验报告2","slug":"理论学习/software-engineering-exp2","date":"2017-09-23T16:45:35.000Z","updated":"2017-09-23T16:59:44.000Z","comments":true,"path":"2017/09/24/理论学习/software-engineering-exp2/","link":"","permalink":"http://www.cvblogs.cn/2017/09/24/理论学习/software-engineering-exp2/","excerpt":"前言&emsp;&emsp;本篇博文是孟宁老师的Mooc网课的实验报告内容。实验主要是关于字符串的处理，需要对字符串函数熟悉，可以减少自己造轮子。非常有意义的实验！","text":"前言&emsp;&emsp;本篇博文是孟宁老师的Mooc网课的实验报告内容。实验主要是关于字符串的处理，需要对字符串函数熟悉，可以减少自己造轮子。非常有意义的实验！ 实验内容&emsp;&emsp;设计实现一个迷你命令行解析小程序。 实验代码&emsp;&emsp;重新看自己的代码，发现写的还是很糟糕的。例如，函数没有采用驼峰式等。等到下回有机会改进把。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/************************************************************************* &gt; File Name: MiniCmd.c &gt; Author: Qin Zhong &gt; Mail: zhongqin0820@163.com &gt; Created Time: 2017年09月16日 星期六 16时01分33秒 ************************************************************************/#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#define MAXN 128void PrintHelp()&#123; printf(\"help cmd list\\n\"); printf(\"------------------------------------------------------\\n\"); printf(\"help for help list\\n\"); printf(\"quit for exit this program\\n\\n\");&#125;void ErrorCmdPrint()&#123; printf(\"error cmd\\n\\n\"); PrintHelp();&#125;int main()&#123; char cmd[MAXN]; memset(cmd,0,sizeof(char)*MAXN); while(1) &#123; gets(cmd); if(strcmp(cmd,\"help\") == 0) &#123; PrintHelp(); &#125; else if(strcmp(cmd,\"quit\") == 0) &#123; printf(\"bye~\\n\"); exit(0); &#125; else if(strcmp(cmd,\"clear\") == 0) &#123; system(\"cls\"); &#125; else if(strstr(cmd,\"hello\") != NULL) &#123; printf(\"你好,%s\\n\",cmd); &#125; else if(strcmp(cmd,\"null\") == 0) &#123; printf(\"null\\n\"); &#125; else if(strstr(cmd,\"whois\") != NULL) &#123; printf(\"me\\n\"); &#125; else &#123; ErrorCmdPrint(); &#125; &#125; return 0;&#125; 课程链接软件工程（C编码实践篇） 结束语&emsp;&emsp;其实上周就开始做了，但是还是太懒了..最近又忙，看了第三课老师的讲解，发现自己还是想简单了。另外，代码到底用tab还是空格对于程序美观真的很重要..","categories":[{"name":"软件工程","slug":"软件工程","permalink":"http://www.cvblogs.cn/categories/软件工程/"}],"tags":[{"name":"实验报告","slug":"实验报告","permalink":"http://www.cvblogs.cn/tags/实验报告/"}]},{"title":"假期工作总结","slug":"理论学习/summer-summary","date":"2017-09-19T17:11:25.000Z","updated":"2017-10-30T16:41:31.000Z","comments":true,"path":"2017/09/20/理论学习/summer-summary/","link":"","permalink":"http://www.cvblogs.cn/2017/09/20/理论学习/summer-summary/","excerpt":"前言&emsp;&emsp;假期主要分为两部分。7月在学校作生产实习。8月自主学习一些机器学习、计算机视觉相关的基础知识。絮絮叨叨，发现总结真的是一项耗费时间的事情。","text":"前言&emsp;&emsp;假期主要分为两部分。7月在学校作生产实习。8月自主学习一些机器学习、计算机视觉相关的基础知识。絮絮叨叨，发现总结真的是一项耗费时间的事情。 生产实习&emsp;&emsp;课程班级：机器学习班。主要内容为： python 语言的学习及相关科学计算包的基础使用 机器学习部分：图像的特征提取(颜色直方图、共生矩阵、HoG、SIFT等）、监督学习算法(二分类、线性回归、逻辑回归、SVM)的API调用、无监督学习算法(K-means、神经网络的训练) 图像处理部分：显著特征提取、生成掩膜进行显著抠图(这部分主要由我负责，使用的是grabcut…) 最后进行图像分类challenge：我们组用的神经网络的方法 &emsp;&emsp;由于我上课中间出去中大夏令营一周，导致没有赶上机器学习部分的课程。 自主学习理论部分&emsp;&emsp;这部分，自己主要一开始看的是udacity上乔治亚理工的视觉MOOC，当时数学基础还没复习。导致没看懂相关讲解的内容。现在回想起来，老师的确上的很好。能够从数学的角度去分析算法。可惜只跟到了Lesson13(印象中)。期间也看了udacity上其他的视觉或者图像处理相关的MOOC。觉得自己吸收有点困难。遂放弃。&emsp;&emsp;转而学习了UCF的课程，老师的口音很有趣。缓缓道来的感觉。但是，精力有限，直到现在依旧没能接着做它的PA。总结也只很水的做了两篇。通过这门课程，发现，自己之前尝试学习视觉相关的知识一直很困难的主要原因：1、手头没有很好的资源以及合理的先导知识和时间分配 2、对于一些东西，感觉自己容易陷入其中。无法站在框架之上去架构自己的知识。最后导致自己只听了个炮响。又由于我们没有开设相关课程，没有考试，没有实验代码或者甚至项目留下印证。等到回过头来，发现自己什么也不会。&emsp;&emsp;在结束生产实习后，凑巧在翻阅博客的过程中，了解到台大李宏毅老师的机器学习课程，跟着学了几课。又觉得《线性代数》非常重要，于是学习了李的另一门公开课《线性代数》。李采用中英文结合的方式授课，我感觉这种授课方式非常的好，正是我所欠缺的，借助这门课补充复习了一下一些线性代数的英文专有名词等。&emsp;&emsp;学习这些，让我越来越觉得数学的重要性。于是找到了吴福朝老师的《计算机视觉中的数学方法》。这本书，虽然只读了前两篇的内容。但是却收获很多。&emsp;&emsp;期间，经同学介绍，看周志华的《机器学习》。这本书，我卡在了第二章就没有接着读了。因为我当时觉得自己得先上点课有了视听基础之后，去读这本书才能事半功倍。于是，就开始看吴恩达老师的《机器学习》MOOC。&emsp;&emsp;关于吴恩达老师的《机器学习》系列教程，我觉得上的很好。而且我觉得自己至少对一些内容有了了解。前段时间恰好他的系列教程和网易合作发布。于是就看了以下他关于《深度学习》的几课。然后，我了解到李飞飞教授和她实验室下的ImageNet以及她也在今年上的一门公开课《视觉检测中的卷积神经网络》(不知这里翻译是否有错，还请斧正)。然后现在主要就是空闲时候会安排学习这门课的内容。&emsp;&emsp;又根据吴的访谈视频知道了Ian的《深度学习》书，看了其中的一些章节。特别是数学部分。感觉自己看完，有了更好的掌握和理解。期间也重新翻阅老师的那篇字典学习的论文，发现有了基础之后又有了新的理解。 实现部分&emsp;&emsp;断断续续，这段时间完成了我们大创的系统。项目发布在了GitHub。&emsp;&emsp;其他基本上没实现出什么，有的也是调库。说实在，我很疑惑。究竟有无必要去自己手写一个SIFT之类的。&emsp;&emsp;其他不相关的，大概是通过这段时间自己有意识的参与一些课程的实践。加强Linux环境下的工具使用。以及关于GitHub的使用。&emsp;&emsp;一直有这样的计划，想要去掌握GPU编程。但是实践的东西真的很费时间，更何况手头也无硬件设备支持。更别提其他基础实验都无法完成，常常就导致一些计划的搁置。&emsp;&emsp;更不相关的大概就是自己关于前端内容的一些学习。这是出于我目前的规划考虑的。我觉得自己既然选择了读专硕，在两年毕业后(实际上我觉得也就一年半有余)，如果我未能在”学术”上取得一定的成就，至少我也要有一点竞争力，感觉前端这块需要很烂大街，但是还是缺那种有架构能力的前端，希望自己到时候会是一个全栈。并且，我觉得这门技术的掌握，如果以后要做项目也是很容易的。 结束语&emsp;&emsp;这段时间，感觉自己的确收获挺多。学习的效果比想象中的好一些。没有压力的学习真的是一件很舒服的事情。偶尔，也在思考自己毕设该做什么。自己研究生究竟该研究什么。记得自己之前初生牛犊不怕虎，说过希望自己能够在研究生时期有机会发顶会、顶刊。突然觉得，自己虽然会为此花费精力，但是现在觉得这是一件很困难的事情（虽然本来也不容易）。&emsp;&emsp;感觉自己还是更倾向去做东西。之所以这么渴望去了解学习这个学科的内容，也是因为一直想要实现自己脑海中的那个idea。希望自己能够不忘初心，方得始终。","categories":[{"name":"学习周报","slug":"学习周报","permalink":"http://www.cvblogs.cn/categories/学习周报/"}],"tags":[{"name":"学习总结","slug":"学习总结","permalink":"http://www.cvblogs.cn/tags/学习总结/"}]},{"title":"孟宁《软件工程C实战》实验报告1","slug":"理论学习/software-engineering-exp1","date":"2017-09-09T15:52:16.000Z","updated":"2017-09-09T16:20:10.000Z","comments":true,"path":"2017/09/09/理论学习/software-engineering-exp1/","link":"","permalink":"http://www.cvblogs.cn/2017/09/09/理论学习/software-engineering-exp1/","excerpt":"前言&emsp;&emsp;本篇博文是孟宁老师的Mooc网课的实验报告内容。实验主要是熟悉Linux环境下的vim编辑器以及关于git的实验，对于有相关经验的同学来说，较为简单。但是正是这样的小实验使得学习的人在实验过程中加深对相关工具的使用！非常有意义的实验！","text":"前言&emsp;&emsp;本篇博文是孟宁老师的Mooc网课的实验报告内容。实验主要是熟悉Linux环境下的vim编辑器以及关于git的实验，对于有相关经验的同学来说，较为简单。但是正是这样的小实验使得学习的人在实验过程中加深对相关工具的使用！非常有意义的实验！ 实验内容&emsp;&emsp;即使从来没有使用的人，参照实验大纲，也能够很顺利的完成实验内容。(可能在配置Git的时候，会占用过多的时间！)&emsp;&emsp;虽然不是第一次使用GitHub，但是，依旧没能够记住git push命令的使用…&emsp;&emsp;虽然这次的代码量真的非常有限，但是也能够学习到一些关于vim使用的技巧！ 实验代码&emsp;&emsp;本次实验代码非常简单，关键应该是那些命令行的使用！12345#include&lt;stdio.h&gt;int main()&#123; printf(\"hello world!\\n\"); return 0;&#125; 课程链接软件工程（C编码实践篇） 结束语&emsp;&emsp;非常感谢孟老师能够提供这样一门课程以供我们练习。作为一名已经修读过软件工程的大四学生而言！觉得这门课程的设计非常的合理！很遗憾知道的晚了！","categories":[{"name":"软件工程","slug":"软件工程","permalink":"http://www.cvblogs.cn/categories/软件工程/"}],"tags":[{"name":"实验报告","slug":"实验报告","permalink":"http://www.cvblogs.cn/tags/实验报告/"}]},{"title":"读书笔记:吴福朝《计算机视觉中的数学方法》","slug":"理论学习/maths-in-CV","date":"2017-09-09T13:39:26.000Z","updated":"2017-09-09T16:21:15.000Z","comments":true,"path":"2017/09/09/理论学习/maths-in-CV/","link":"","permalink":"http://www.cvblogs.cn/2017/09/09/理论学习/maths-in-CV/","excerpt":"前言&emsp;&emsp;已经看完这本书的前两篇的内容，第三篇是关于”模型估计”的。本书在网上直接搜索书名即可找到公开的资源以供下载。本文也在文末提供了免费的资源下载链接。","text":"前言&emsp;&emsp;已经看完这本书的前两篇的内容，第三篇是关于”模型估计”的。本书在网上直接搜索书名即可找到公开的资源以供下载。本文也在文末提供了免费的资源下载链接。 内容有感&emsp;&emsp;老实说，我是绝望的。数学基础实在太差了。过程中，一度放弃，靠着毅力以及skip reading才翻完前两篇的内容。笔记做了20几页。在FoxitReader上，这本书也被我圈圈画画的不成样子。可是不知道怎么回事，感觉自己真的是学不透它的概念啊… 《射影几何》篇&emsp;&emsp;本篇的内容可以说是做计算机视觉最基础的理论了，必须掌握的内容。期间，提到一个自标定理论，遥遥记得自己当初选择这个专业就是想做一款假延时的拍照应用，这么多年过去了，我一直以为自己要实现的就是摄像机的标定(至少基础算法应该要是这个)，可是读了此章内容才发现并不是这么回事。还记得读到: “所谓自标定，是指仅从埸景的多幅图像来确定摄像机内参数，这种方法不需精密加工的标定块。” 的时候，我整个人都是崩溃的。期间又想到自己毕设究竟想做什么，是做一个服务东大课堂的应用还是实现自己一直想实现的这个idea(虽然能想见后者的困难度：好似一个连自己都不懂需求是什么的产品经理告诉手下的码农，我的需求可能是这个云云。不幸的是，我自己恰恰又是那个苦逼的实现者…)&emsp;&emsp;本篇的内容，在阅读过程中，也发现了，自己在学习UCF课程的时候，压根其实就没有听懂人家背后的数学知识。读本篇内容时常让我有种：哦，原来教授的意思是这个不是那个啊…后期还需要反复咀嚼一二。 《矩阵张量》篇&emsp;&emsp;吴教授的书的章节命名很对一个强迫症患者的口味。本篇的内容前半部分讲矩阵，后半部分讲张量。前半部分的矩阵中所说的各种矩阵分解的方法，其中的奇异值分解(因为数学不好，总觉得这些专有名词很吓人，阅读之下，发现也就那么回事。)不过，我知道要做到真正的理解和消化为我所用还是需要仔细的品味阅读的。至于后半部分所提到的张量则是让我大开眼界！虽然没有佐证，但我猜：Google的Tensorflow估计就是基于这个Tensor(张量)而来！How amazing!有种感觉，又距离想要知道的内容更近一步了！= = 资源链接计算机视觉中的数学方法(吴福朝) 结束语&emsp;&emsp;这本书的确值得一读，但我想，如果在我大三甚者更早之前能够接触到了解到这本书，我的理解能有我现在多吗？就好像我之前的每次尝试，似乎总是失败的收尾。就好像即使某种意义上，我完成了UCF的CV网课，但我依旧对自己是否真正掌握这些知识心虚不已…但是，可以肯定的是，这本书在以后读来(预计下个月重读)，将又会有很多的收获。期待下回能够补充更读到的属于自己的更专业的关于本书的解读！ &emsp;&emsp;革命尚未成功，同志还需努力。","categories":[{"name":"图像处理","slug":"图像处理","permalink":"http://www.cvblogs.cn/categories/图像处理/"}],"tags":[{"name":"数学基础","slug":"数学基础","permalink":"http://www.cvblogs.cn/tags/数学基础/"}]},{"title":"机器学习相关基础名词：有监督、半监督、无监督","slug":"理论学习/machine-learning-basic1","date":"2017-09-05T15:06:27.000Z","updated":"2017-09-09T16:16:42.000Z","comments":true,"path":"2017/09/05/理论学习/machine-learning-basic1/","link":"","permalink":"http://www.cvblogs.cn/2017/09/05/理论学习/machine-learning-basic1/","excerpt":"前言&emsp;&emsp;学习机器学习有几周了…也了解了一些基础名词，梳理以下，下回再有人逼叨逼的也不懵了。","text":"前言&emsp;&emsp;学习机器学习有几周了…也了解了一些基础名词，梳理以下，下回再有人逼叨逼的也不懵了。 基础概念有监督&emsp;&emsp;样本带有标签的训练集合。通常特征维度为$n+1$，因为特征向量中，多出来的一维表示的是样本标签。 半监督&emsp;&emsp;有监督与无监督的折衷，当我们在用机器学习算法学习一个函数(模型)去拟合数据集的时候，数据集大多数情况下并不理想。毕竟人工标注的成本太高，而我们的数据集通常情况下是很大的。与其毫无”目的”的学习，这时候我们让部分未标注的数据集合充作训练集合进行训练。学习得到的模型效果会更好些。 无监督&emsp;&emsp;训练样本不带有标签的训练集合作为输入的学习算法。如：聚类问题 其它分类器(Classifier)&emsp;&emsp;问题的输出只有一个。要么是要么不是。 回归&emsp;&emsp;分为线性回归、逻辑回归(修正线性回归带来的过拟合问题)。问题的输出是线性的，可能是可能不是。可以进行多分类。 神经网络&emsp;&emsp;参考神经元模型设计：输入层，隐藏层(可以有多层)，输出层。与字典学习作为机器学习的两大分支。 字典学习&emsp;&emsp;将训练集合的特征提取，集合成一个码本进行表示。与神经网络同属于复杂模型学习方法。 稀疏表示&emsp;&emsp;通常情况下，我们的特征的维数很大。这就带来一个问题：计算量的提高。为了平衡算法的时间效率。需要将特征降维后，稀疏表示。如KSVD算法就是将特征矩阵进行奇异值分解得到降维后的特征矩阵进行表示。 推荐学习材料 周志华《机器学习》 斯坦福大学吴恩达《机器学习入门》 台湾大学李宏毅《机器学习入门》 结束语&emsp;&emsp;看着这些概念解释，在想还是写代码比较好些…太水了…说了一堆废话。图个心安。推荐的材料太懒了，链接暂时不放了。自己一搜就有，实在找不到底下评论吧。总结来说，还是自己实践太少。即使大四琐事还是一堆(可能和自己太懒以及太笨有关系。羡慕那些脑瓜好使的人。以及动手能力很强的人。)","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://www.cvblogs.cn/categories/机器学习/"}],"tags":[{"name":"基础概念","slug":"基础概念","permalink":"http://www.cvblogs.cn/tags/基础概念/"}]},{"title":"UCF-CV课程总结:边缘检测","slug":"理论学习/UCF-CVClass-Summary1","date":"2017-09-04T11:50:56.000Z","updated":"2017-09-05T15:48:24.000Z","comments":true,"path":"2017/09/04/理论学习/UCF-CVClass-Summary1/","link":"","permalink":"http://www.cvblogs.cn/2017/09/04/理论学习/UCF-CVClass-Summary1/","excerpt":"前言&emsp;&emsp;这篇博文是本人学习UCF计算机视觉公开课的课程知识梳理系列文章的第二篇。本篇博文主要介绍边缘检测章节的内容。","text":"前言&emsp;&emsp;这篇博文是本人学习UCF计算机视觉公开课的课程知识梳理系列文章的第二篇。本篇博文主要介绍边缘检测章节的内容。 课程内容相关先导知识&emsp;&emsp;边缘一般是指图像在某一局部强度剧烈变化的区域。强度变化一般有两种情况(横轴表示空间变化，纵轴表示灰度变化，虚线表示边缘)：&emsp;&emsp;&emsp;&emsp;边缘检测的任务：找到具有阶跃变化或者屋顶变化的像素点的集合。&emsp;&emsp;最直观的想法就是求微分。 对于第一种情况：一阶微分的峰值为边缘点，二阶微分的零点为边缘点。 对于第二种情况：一阶微分的零点为边缘点，二阶微分的峰值为边缘点。 &emsp;&emsp;一般可将边缘分为水平边缘、垂直边缘和对角线边缘。&emsp;&emsp;由于边缘检测的算法主要是基于图像强度(采用差分的方法来进行计算)的一阶和二阶导数。&emsp;&emsp;但导数通常对噪声敏感，因此必须采用滤波器来改善与噪声有关的边缘检测器的性能。常见的滤波方法主要有高斯滤波，即采用离散化的高斯函数产生一组归一化的高斯核。 一般边缘检测过程&emsp;&emsp;1. 滤波：改善与噪声有关的边缘检测器的性能&emsp;&emsp;2. 增强：将图像灰度点邻域强度值有显著变化的点凸显出来(可通过计算梯度幅值来确定)&emsp;&emsp;3. 检测：常用的方法是通过阈值化方法来检测 边缘检测器介绍(Edge Detector)&emsp;&emsp;课程中讲述到的检测器包括：&emsp;&emsp; Prewitt and Sobel Edge Detector&emsp;&emsp;属于离散微分算子 (discrete differentiation operator)。利用差分求出$x,y$方向上的梯度，求解梯度的大小，阈值化梯度的大小找到边缘。 Prewitt算子&emsp;&emsp;结合了差分运算与邻域平均的方法。其卷积模板如下： Sobel算子&emsp;&emsp;与prewitt算子类似，但考虑到了相邻不同像素点的影响程度是不同的，所以采用加权平均。 Marr Hildreth Edge Detector-LoG&emsp;&emsp;基本步骤： 用高斯器滤波原图像去除噪声 拉普拉斯滤波后的图像(求$x,y$二阶导) 找到零点(边缘点)，重复步骤2直到全部找到 &emsp;&emsp;laplacian算子是一些使用二阶微分的算子，实际上就是梯度的散度(可以利用DoG近似求解LoG降低算法时间复杂度的数量级?可以增强对比度！)LoG计算：不同计算方法，时间复杂度不同 一个2D laplacian算子(n{2}) 四个1D的算子组合而成(4n) &emsp;&emsp;由于 Laplacian使用了图像梯度，它内部的代码其实是调用了 Sobel 算子的 Canny&emsp;&emsp;是一种求最优边缘检测的一套方法。是一种先平滑再求导的方法。&emsp;&emsp;最优边缘检测的三个主要评价标准： 低错误率: 标识出尽可能多的实际边缘，同时尽可能的减少噪声产生的误报。 高定位性: 标识出的边缘要与图像中的实际边缘尽可能接近。 最小响应: 图像中的边缘只能标识一次，并且可能存在的图像噪声不应标识为边缘。 &emsp;&emsp;特别注意第4步！排除非边缘像素， 仅仅保留了一些细线条(候选边缘). 程序实现1234567891011121314151617181920212223242526i = imread('lena.png');%读入原图像A = fspecial('gaussian');%高斯滤波器i = filter2(A, i) / 255;%高斯滤波并归一化(/255)figure;imshow(i);%显示图像imwrite(i,'lena_0.jpg');%保存图像%prewitt方法a = edge(i, 'prewitt');figure;imshow(a);imwrite(a,'lena_1.jpg');%sobel方法a = edge(i, 'sobel');figure;imshow(a);imwrite(a,'lena_2.jpg');%marr hildreth方法(LoG)a = edge(i, 'log');figure;imshow(a);imwrite(a,'lena_3.jpg');%canny方法a = edge(i, 'canny');figure;imshow(a);imwrite(a,'lena_4.jpg'); 引用 边缘检测算法 【OpenCV入门教程之十二】OpenCV边缘检测：Canny算子,Sobel算子,Laplace算子,Scharr滤波器合辑 结束语&emsp;&emsp;一如既往，写文章对于我真的是一件万分困难的事情，基本上只能达到通顺的要求。翻来覆去也就只能用那几个markdown语法。排版也不甚美观。但我相信，坚持下去，总有一天，我能写出自己的内容。","categories":[{"name":"计算机视觉","slug":"计算机视觉","permalink":"http://www.cvblogs.cn/categories/计算机视觉/"}],"tags":[{"name":"课程总结","slug":"课程总结","permalink":"http://www.cvblogs.cn/tags/课程总结/"}]},{"title":"UCF-CV课程总结:概述、滤波及Matlab使用","slug":"理论学习/UCF-CVClass-Summary","date":"2017-09-01T09:20:40.000Z","updated":"2017-09-05T15:48:24.000Z","comments":true,"path":"2017/09/01/理论学习/UCF-CVClass-Summary/","link":"","permalink":"http://www.cvblogs.cn/2017/09/01/理论学习/UCF-CVClass-Summary/","excerpt":"前言&emsp;&emsp;从八月开始，断断续续学习这门课程。从一开始Coursera上乔治亚理工的CV课和CP课继而到UCF的CV课。算是入门了这门课程，为以后的研究工作打下了一些基础。虽然，我的数学基础在很大程度上限制着我的吸收消化。但是，始终相信，有志者事竟成这个道理。&emsp;&emsp;课程资源地址：UCF-CAP 5415 - Computer Vision学习过程中，可以参照课程日程表安排学习时间。适当的加强强度。(由于时间问题，本人只完成了小部分实验…最好还是要做做实验的。)","text":"前言&emsp;&emsp;从八月开始，断断续续学习这门课程。从一开始Coursera上乔治亚理工的CV课和CP课继而到UCF的CV课。算是入门了这门课程，为以后的研究工作打下了一些基础。虽然，我的数学基础在很大程度上限制着我的吸收消化。但是，始终相信，有志者事竟成这个道理。&emsp;&emsp;课程资源地址：UCF-CAP 5415 - Computer Vision学习过程中，可以参照课程日程表安排学习时间。适当的加强强度。(由于时间问题，本人只完成了小部分实验…最好还是要做做实验的。) &emsp;&emsp;虽然在onenote上针对每节课都已经做了笔记，但是发现，自己只是将教授PPT中的内容摘抄了出来。这里借助博客简单梳理一下这门课中学习到的内容(事实上，其中的每一课都值得另起一篇去详细介绍)，顺便提升自己的写作能力总结能力。&emsp;&emsp;我发现，本文的长度大大超过了预期。因此，基于”2-8准则”(实则我实在无法做到一小时完成这个工作)，计划每篇此类总结文章以两到三课为一篇文章去总结课程内容。 课程内容&emsp;&emsp;整门课内容设计较为合理，作为重实现轻理论(少数学细节推导，乔治亚理工的课程较侧重于数学细节)大军中的一员，接受度良好。在课程主页上还有参考资料(免费，开放下载)以及CV领域的顶刊顶会的官网链接等信息。 Lecture1 CVIntroduction&emsp;&emsp;第一课是关于计算机视觉中基础知识的介绍以及整个课程会接触到的内容的学习。了解计算机视觉所研究的是从二维图像中得到三维世界的语意信息。&emsp;&emsp;在这个过程中，常常将图像当作一个函数$f(x,y)$,它是一个离散的关于像素点的函数。常用一个矩阵表示一张图像，其元素是0(黑)～255(白)的灰度值。分辨率则是由图像的像素长宽确定(屏幕的分辨率通常是固定的，但是可以向下调整，分辨率越高图像越细腻)。还介绍了图片的格式(不同的格式只是压缩编码的方式不同)。也介绍了视频的基本属性。依照人眼的构造，视频帧数每秒30帧就可以达到流畅的基本要求。&emsp;&emsp;现今的射影设备都是基于孔洞模型(Pin Hole)进行射影变换。&emsp;&emsp;三维空间中的点$(x,y,z)$通过镜片投影到图像平面上的点$(x,y)$&emsp;&emsp;由以上这个模型，我们就很容易想到：应该如何通过二维图像恢复被摄物体在三维世界中的几何信息呢？&emsp;&emsp;这里不再细展开。以及，CV的应用有哪些：&emsp;&emsp;作为基础知识的简单入门，第一节课还是很不错的。至少罗列的那些应用光是看那些演示视频，想到自己也有机会去实现。光想想就能振奋人心。 Lecture2 Filtering&emsp;&emsp;第二节课是CV领域最最基础的一个概念–滤波(Filtering)。我的第一篇博文整理的就是关于滤波操作的知识(虽然大部分是copy的别人的总结…)。&emsp;&emsp;首先，当你拿到一张图像，一定要区分清楚它究竟是:1.二值的(Binary)、2.灰度的(Gray Scale)还是3.彩色的(Color)。&emsp;&emsp;1.二值图像矩阵元素要么是0要么是1&emsp;&emsp;2.灰度图像，Scale范围通常(0~255)&emsp;&emsp;3.彩色图像较为复杂，通常在RGB空间下分为3个通道(R-Red、G-Green、B-Blue)&emsp;&emsp;因为这些值元素的存在，引入一个图像直方图去直观描述它的比重信息。&emsp;&emsp;&emsp;&emsp;由于各种内外界不稳定因素的干扰，图像并不总是”干净”的,总是有这样那样的噪声(通常高频信息是噪声-变化明显，变现的特征就是高频信息)。噪声叠加原图像得到被污染后的图像。(高斯噪声即噪声的分布符合高斯分布！)&emsp;&emsp;&emsp;&emsp;接着为引入滤波的概念，介绍了基本的数学运算：求导(Derivative，包括连续的和离散的即查分：向前、向后、中心，接着从一维引申到二维（图像是一个二维矩阵），接着提到了相关(Correlation)以及卷积(Convolution))以及求均值(Average/Mean)。&emsp;&emsp;并且，还提到了掩膜(Mask)的概念。&emsp;&emsp;高斯分布的重要意义：&emsp;&emsp;&emsp;&emsp;由于之前的文章已经梳理过，这里不再赘述。第二节结束。目前，我们已经了解了一些基本知识和基本运算(Matlab由库函数实现，推荐使用。) Matlab Tutorial&emsp;&emsp;作为课程的辅助章节，本节内容介绍Matlab的基本使用，作为Matlab的简单入门还是很有必要学习的。助教教授的内容都很实用。(对于没有接触过Matlab的人来说，通过学习本节可以完成基本编程任务。推荐观看。另外，斯坦福的吴恩达教授也在其机器学习视频中教授过Matlab的简单操作使用。也可以参考学习。) 结束语&emsp;&emsp;写博客真是一项锻炼能力的活，花了一个半小时才写完两节课的简单梳理总结。这进度我也是醉了！看来，以后应该利用碎片化的闲暇时间一点点完成。否则太占用学习时间了！","categories":[{"name":"计算机视觉","slug":"计算机视觉","permalink":"http://www.cvblogs.cn/categories/计算机视觉/"}],"tags":[{"name":"课程总结","slug":"课程总结","permalink":"http://www.cvblogs.cn/tags/课程总结/"}]},{"title":"图像处理基础-滤波(filtering)","slug":"理论学习/image-processing-operation1","date":"2017-08-11T11:39:53.000Z","updated":"2017-09-05T15:48:24.000Z","comments":true,"path":"2017/08/11/理论学习/image-processing-operation1/","link":"","permalink":"http://www.cvblogs.cn/2017/08/11/理论学习/image-processing-operation1/","excerpt":"","text":"前言&emsp;&emsp;本文介绍图像处理基础知识滤波(filtering)相关知识。在图像处理中，你经常能够看到它的身影。对于学习图像处理，理解滤波背后的数学知识非常重要。 &emsp;&emsp;滤波分为基于空间域滤波(spatial filtering)与基于频率域滤波(frequency filtering)。二者的目的都是为了改善图像质量。篇幅有限，此篇文章先介绍空间滤波。 空间滤波(Spatial Filtering)&emsp;&emsp;空间滤波操作有时候也被叫做卷积滤波，或者干脆叫卷积(convolution)(离散的卷积，不是微积分里连续的卷积);常常需要用一个滤波器(filter)做空间滤波操作;滤波器也有很多名字:卷积模版(template)、卷积核(kernel)、掩模(mask)、窗口(window)等。 &emsp;&emsp;空间滤波可以分为线性滤波(linear filter)和非线性滤波(non-linear filter)。非线性滤波常见的有中值滤波、最大值滤波等，相当于自定义一个函数，在数学上由于不满足线性变换因此叫做非线性滤波。这里不细研究它。 &emsp;&emsp;线性滤波通常是：将模版覆盖区域内的元素，以模版中对应位置元素为权值，进行累加。与卷积操作类似的，还有一种数学操作叫做协相关(cross-correlatioin)，它们都可以看作是基于矩阵内积的操作。具有平移不变性(shift-invariant)。 &emsp;&emsp;二者的区别：卷积和协相关的差别是，卷积需要先对滤波矩阵进行180度的翻转，但如果矩阵是对称的，那么两者就没有什么差别了。实际上，在信号处理领域，卷积有广泛的意义，而且有其严格的数学定义，但在这里不关注这个。2D卷积需要4个嵌套循环(4-double loop)，所以它并不快，除非我们使用很小的卷积核。这里一般使用3x3或者5x5。而且，对于滤波器，也有一定的规则要求： 1）滤波器的大小应该是奇数，这样它才有一个中心，例如3x3，5x5或者7x7。有中心了，也有了半径的称呼，例如5x5大小的核的半径就是2。 2）滤波器矩阵所有的元素之和应该要等于1，这是为了保证滤波前后图像的亮度保持不变。当然了，这不是硬性要求了。 3）如果滤波器矩阵所有元素之和大于1，那么滤波后的图像就会比原图像更亮，反之，如果小于1，那么得到的图像就会变暗。如果和为0，图像不会变黑，但也会非常暗。 4）对于滤波后的结构，可能会出现负数或者大于255的数值。对这种情况，我们将他们直接截断到0和255之间即可。对于负数，也可以取绝对值。 卷积核(Convolution Kernel)&emsp;&emsp;定义不同的卷积核与原图像做卷积操作，可以产生不同的效果。滤波与模糊的概念区分。模糊是人为感受到的现象，通过滤波操作可以呈现。 什么都不做&emsp;&emsp;滤波器矩阵所有元素之和为1，保证滤波前后图像的亮度保持不变。这个滤波器啥也没有做，得到的图像和原图是一样的。因为只有中心点的值是1。邻域点的权值都是0，对滤波后的取值没有任何影响。 图像锐化滤波器(Sharpness Filter)&emsp;&emsp;图像的锐化和边缘检测很像，首先找到边缘，然后把边缘加到原来的图像上面，这样就强化了图像的边缘，使图像看起来更加锐利了。这两者操作统一起来就是锐化滤波器了，也就是在边缘检测滤波器的基础上，再在中心的位置加1，这样滤波后的图像就会和原始的图像具有同样的亮度了，但是会更加锐利。 &emsp;&emsp;我们把核加大，就可以得到更加精细的锐化效果 &emsp;&emsp;下面的滤波器会更强调边缘。 &emsp;&emsp;主要是强调图像的细节。最简单的3x3的锐化滤波器如下： &emsp;&emsp;实际上是计算当前点和周围点的差别，然后将这个差别加到原来的位置上。另外，中间点的权值要比所有的权值和大于1，意味着这个像素要保持原来的值。 边缘检测(Edge Detection)&emsp;&emsp;我们要找水平的边缘：需要注意的是，这里矩阵的元素和是0，所以滤波后的图像会很暗，只有边缘的地方是有亮度的。 &emsp;&emsp;相当于做差分(differencing)，求导的离散版本，有向前差分(forward differencing)，向后差分(backward differencing)，中心差分(central differencing)。 &emsp;&emsp;下面的滤波器可以找到垂直方向的边缘，这里像素上和下的像素值都使用 &emsp;&emsp;再下面这个滤波器可以找到45度的边缘：取-2不为了什么，只是为了让矩阵的元素和为0而已。 &emsp;&emsp;那下面这个滤波器就可以检测所有方向的边缘。 &emsp;&emsp;为了检测边缘，我们需要在图像对应的方向计算梯度。用下面的卷积核来卷积图像，就可以了。但在实际中，这种简单的方法会把噪声也放大了。另外，需要注意的是，矩阵所有的值加起来要是0。 浮雕(Embossing Filter)&emsp;&emsp;浮雕滤波器可以给图像一种3D阴影的效果。只要将中心一边的像素减去另一边的像素就可以了。这时候，像素值有可能是负数，我们将负数当成阴影，将正数当成光，然后我们对结果图像加上128的偏移。这时候，图像大部分就变成灰色了。 &emsp;&emsp;下面是45度的浮雕滤波器 &emsp;&emsp;只要加大滤波器，就可以得到更加夸张的效果了 均值模糊(Box Filter/Averaging)&emsp;&emsp;我们可以将当前像素和它的四邻域的像素一起取平均，然后再除以5，或者直接在滤波器的5个地方取0.2的值即可，如下图 &emsp;&emsp;可以看到，这个模糊还是比较温柔的，我们可以把滤波器变大，这样就会变得粗暴了：注意要将和再除以13. &emsp;&emsp;如果你想要更模糊的效果，加大滤波器的大小即可。或者对图像应用多次模糊也可以。 高斯模糊(Gaussian Filter)&emsp;&emsp;均值模糊很简单，但不是很平滑。高斯模糊就有这个优点，所以被广泛用在图像降噪上。特别是在边缘检测之前，都会用来移除细节。高斯滤波器是一个低通滤波器。 运动模糊(Motion Blur)&emsp;&emsp;运动模糊可以通过只在一个方向模糊达到，例如下面9x9的运动模糊滤波器。注意，求和结果要除以9。 &emsp;&emsp;这个效果就好像，摄像机是从左上角移动的右下角。 自己手写的卷积函数虽然Matlab已经封装了一个函数con2()作卷积操作，但是还是要自己手写一下加深理解。下面是UCF计算机视觉网课的作业。4层循环。因为边缘效应通常情况下需要补0。还是Matlab新手，代码一点都不elegant，没有借鉴意义。1234567891011121314151617function [] = pa1()m_img = imread('PA1/balloon.jpg');m_kernel = rand(5,5);[r1, c1, cc1] = size(m_img);[r2, c2] = size(m_kernel);for i = r2+1:r1 for j = c2+1:c1 sump = 0; for k = 1:r2 for l = 1:c2 sump = m_img(i-k, j-l) * m_kernel(k,l); end; end; outQ(i,j) = sump; end;endimshow(outQ);wait(0); Matlab中用imfilter()实现线性空间滤波&emsp;&emsp;最常用的是这句：1imfilter(f, w, 'replicate') %相关滤波，默认边界外围填充0，造成黑边，使用'replicate'复制边缘像素，消除边缘效应，输出大小与输入图像f相同. &emsp;&emsp;imfilter()默认是相关算子，在做真正的卷积之前可以先将核旋转180°(除非你指定了滤波模式为’conv’)，rotated_filter=flipud(fliplr(filter))1234567891011121314imfilter(f, w, filtering_mode, boundary_options, size_options)f:图像w:滤波模版filtering_mode:滤波模式 &apos;corr&apos;:相关滤波。[默认值] &apos;conv&apos;:卷积滤波。boundary_options:边界选项 P:(没有引号)边界外围补充0。[默认值] &apos;replicate&apos;:边界外围复制边界值 &apos;symmetric&apos;:边界外围使用边界镜像 &apos;circular&apos;:图像的大小通过讲图像处理为二维周期函数的一个周期来扩展（这是什么？）size_options:大小选项 &apos;same&apos;:输出大小与输入图像f大小相同。[默认值] &apos;full&apos;:输出与扩展（填充）后的图像大小相同。 总结 规范用语，在滑窗操作、计算图像梯度等场合，不要使用“卷积”，而要使用“滤波”或者“协相关”。因为，我们通常讲的卷积，在这几个操作中其实是协相关，那就不要用卷积这个词以避免引起混淆。 不同的滤波器产生的效果不同，滤波器的定义有讲究。经常会看到一些人名命名的算子。比如用作边缘检测，拉普拉斯(Laplacian)算子、Canny算子。观察它们的算子内容，结合卷积核的定义规则。你会发现其实就那么回事。不要被复杂的学术名词给弄懵逼了。 GPU实现代替CPU实现，CPU实现需要四重循环，时间代价太大，性能不好。GPU使用特定的数据结构直接进行计算降低时间代价。 这是我的第一篇博文，本来是想好好写的，发现写博文真的是一项技术活。话到嘴边，憋不出一个字。 参考引用 图像卷积与滤波的一些知识点 图像卷积、相关以及在MATLAB中的操作","categories":[{"name":"图像处理","slug":"图像处理","permalink":"http://www.cvblogs.cn/categories/图像处理/"}],"tags":[{"name":"数学基础","slug":"数学基础","permalink":"http://www.cvblogs.cn/tags/数学基础/"}]},{"title":"开发测试","slug":"开发学习/hello-world","date":"2017-08-05T11:11:50.000Z","updated":"2017-08-13T19:08:00.000Z","comments":true,"path":"2017/08/05/开发学习/hello-world/","link":"","permalink":"http://www.cvblogs.cn/2017/08/05/开发学习/hello-world/","excerpt":"","text":"博客正在完善中&emsp;&emsp;稍安勿躁","categories":[{"name":"网页开发","slug":"网页开发","permalink":"http://www.cvblogs.cn/categories/网页开发/"}],"tags":[{"name":"测试","slug":"测试","permalink":"http://www.cvblogs.cn/tags/测试/"}]}]}