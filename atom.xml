<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CVBlogs</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.cvblogs.cn/"/>
  <updated>2017-09-09T16:20:10.000Z</updated>
  <id>http://www.cvblogs.cn/</id>
  
  <author>
    <name>Zhong Qin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>孟宁《软件工程C实战》实验报告1</title>
    <link href="http://www.cvblogs.cn/2017/09/09/software-engineering-exp1/"/>
    <id>http://www.cvblogs.cn/2017/09/09/software-engineering-exp1/</id>
    <published>2017-09-09T15:52:16.000Z</published>
    <updated>2017-09-09T16:20:10.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&emsp;&emsp;本篇博文是孟宁老师的<a href="https://mooc.study.163.com/course/USTC-1000002006#/info" target="_blank" rel="external">Mooc网课</a>的实验报告内容。实验主要是熟悉Linux环境下的vim编辑器以及关于git的实验，对于有相关经验的同学来说，较为简单。但是正是这样的小实验使得学习的人在实验过程中加深对相关工具的使用！<u>非常有意义的实验！</u></p>
<a id="more"></a>
<h3 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h3><p>&emsp;&emsp;即使从来没有使用的人，参照实验大纲，也能够很顺利的完成实验内容。(可能在配置Git的时候，会占用过多的时间！)<br><img src="http://ou5rpeic9.bkt.clouddn.com/seexp1_1.png" alt="github使用及创建编译运行部分"><br><br>&emsp;&emsp;虽然不是第一次使用GitHub，但是，依旧没能够记住<code>git push</code>命令的使用…<br><br><img src="http://ou5rpeic9.bkt.clouddn.com/seexp1_2.png" alt="github push命令使用"><br><br>&emsp;&emsp;虽然这次的代码量真的非常有限，但是也能够学习到一些关于vim使用的技巧！<br><br><img src="http://ou5rpeic9.bkt.clouddn.com/seexp1_3.png" alt="代码截图"></p>
<h3 id="实验代码"><a href="#实验代码" class="headerlink" title="实验代码"></a>实验代码</h3><p>&emsp;&emsp;本次实验代码非常简单，关键应该是那些命令行的使用！<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"hello world!\n"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="课程链接"><a href="#课程链接" class="headerlink" title="课程链接"></a>课程链接</h3><p><a href="https://mooc.study.163.com/course/USTC-1000002006#/info" target="_blank" rel="external">软件工程（C编码实践篇）</a></p>
<h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>&emsp;&emsp;非常感谢孟老师能够提供这样一门课程以供我们练习。作为一名已经修读过软件工程的大四学生而言！觉得这门课程的设计非常的合理！很遗憾知道的晚了！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;本篇博文是孟宁老师的&lt;a href=&quot;https://mooc.study.163.com/course/USTC-1000002006#/info&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Mooc网课&lt;/a&gt;的实验报告内容。实验主要是熟悉Linux环境下的vim编辑器以及关于git的实验，对于有相关经验的同学来说，较为简单。但是正是这样的小实验使得学习的人在实验过程中加深对相关工具的使用！&lt;u&gt;非常有意义的实验！&lt;/u&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="软件工程" scheme="http://www.cvblogs.cn/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="实验报告" scheme="http://www.cvblogs.cn/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记:吴福朝《计算机视觉中的数学方法》</title>
    <link href="http://www.cvblogs.cn/2017/09/09/maths-in-CV/"/>
    <id>http://www.cvblogs.cn/2017/09/09/maths-in-CV/</id>
    <published>2017-09-09T13:39:26.000Z</published>
    <updated>2017-09-09T16:21:15.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&emsp;&emsp;已经看完这本书的前两篇的内容，第三篇是关于”模型估计”的。本书在网上直接搜索书名即可找到公开的资源以供下载。本文也在文末提供了免费的资源下载链接。</p>
<a id="more"></a>
<h3 id="内容有感"><a href="#内容有感" class="headerlink" title="内容有感"></a>内容有感</h3><p><br>&emsp;&emsp;老实说，我是绝望的。数学基础实在太差了。过程中，一度放弃，靠着毅力以及skip reading才翻完前两篇的内容。笔记做了20几页。在FoxitReader上，这本书也被我圈圈画画的不成样子。可是不知道怎么回事，感觉自己真的是学不透它的概念啊…</p>
<h4 id="《射影几何》篇"><a href="#《射影几何》篇" class="headerlink" title="《射影几何》篇"></a>《射影几何》篇</h4><p><br>&emsp;&emsp;本篇的内容可以说是做计算机视觉最基础的理论了，必须掌握的内容。期间，提到一个<b>自标定理论</b>，遥遥记得自己当初选择这个专业就是想做一款假延时的拍照应用，这么多年过去了，我一直以为自己要实现的就是摄像机的标定(至少基础算法应该要是这个)，可是读了此章内容才发现并不是这么回事。还记得读到:</p>
<blockquote>
<p>“所谓自标定，是指仅从埸景的多幅图像来确定摄像机内参数，这种方法不需精密加工的标定块。”</p>
</blockquote>
<p><br>的时候，我整个人都是崩溃的。期间又想到自己毕设究竟想做什么，是做一个服务东大课堂的应用还是实现自己一直想实现的这个idea(虽然能想见后者的困难度：好似一个连自己都不懂需求是什么的产品经理告诉手下的码农，我的需求可能是这个云云。不幸的是，我自己恰恰又是那个苦逼的实现者…)<br><br>&emsp;&emsp;本篇的内容，在阅读过程中，也发现了，自己在学习UCF课程的时候，压根其实就没有听懂人家背后的数学知识。读本篇内容时常让我有种：哦，原来教授的意思是这个不是那个啊…后期还需要反复咀嚼一二。</p>
<h4 id="《矩阵张量》篇"><a href="#《矩阵张量》篇" class="headerlink" title="《矩阵张量》篇"></a>《矩阵张量》篇</h4><p><br>&emsp;&emsp;吴教授的书的章节命名很对一个强迫症患者的口味。本篇的内容前半部分讲矩阵，后半部分讲张量。前半部分的矩阵中所说的各种矩阵分解的方法，其中的奇异值分解(因为数学不好，总觉得这些专有名词很吓人，阅读之下，发现也就那么回事。)不过，我知道要做到真正的理解和消化为我所用还是需要仔细的品味阅读的。至于后半部分所提到的张量则是让我大开眼界！虽然没有佐证，但我猜：Google的Tensorflow估计就是基于这个Tensor(张量)而来！How amazing!有种感觉，又距离想要知道的内容更近一步了！= =</p>
<h3 id="资源链接"><a href="#资源链接" class="headerlink" title="资源链接"></a>资源链接</h3><p><a href="http://download.csdn.net/download/wxqfree/1430305" target="_blank" rel="external">计算机视觉中的数学方法(吴福朝)</a></p>
<h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>&emsp;&emsp;这本书的确值得一读，但我想，如果在我大三甚者更早之前能够接触到了解到这本书，我的理解能有我现在多吗？就好像我之前的每次尝试，似乎总是失败的收尾。就好像即使某种意义上，我完成了UCF的CV网课，但我依旧对自己是否真正掌握这些知识心虚不已…但是，可以肯定的是，这本书在以后读来(预计下个月重读)，将又会有很多的收获。期待下回能够补充更读到的属于自己的更专业的关于本书的解读！</p>
<blockquote>
<p>&emsp;&emsp;革命尚未成功，同志还需努力。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;已经看完这本书的前两篇的内容，第三篇是关于”模型估计”的。本书在网上直接搜索书名即可找到公开的资源以供下载。本文也在文末提供了免费的资源下载链接。&lt;/p&gt;
    
    </summary>
    
      <category term="图像处理" scheme="http://www.cvblogs.cn/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
    
      <category term="数学基础" scheme="http://www.cvblogs.cn/tags/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>机器学习相关基础名词：有监督、半监督、无监督</title>
    <link href="http://www.cvblogs.cn/2017/09/05/machine-learning-basic1/"/>
    <id>http://www.cvblogs.cn/2017/09/05/machine-learning-basic1/</id>
    <published>2017-09-05T15:06:27.000Z</published>
    <updated>2017-09-09T16:16:42.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&emsp;&emsp;学习机器学习有几周了…也了解了一些基础名词，梳理以下，下回再有人逼叨逼的也不懵了。</p>
<a id="more"></a>
<h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><h4 id="有监督"><a href="#有监督" class="headerlink" title="有监督"></a>有监督</h4><p>&emsp;&emsp;样本带有标签的训练集合。通常特征维度为$n+1$，因为特征向量中，多出来的一维表示的是样本标签。</p>
<h4 id="半监督"><a href="#半监督" class="headerlink" title="半监督"></a>半监督</h4><p>&emsp;&emsp;有监督与无监督的折衷，当我们在用机器学习算法学习一个函数(模型)去拟合数据集的时候，数据集大多数情况下并不理想。毕竟人工标注的成本太高，而我们的数据集通常情况下是很大的。与其毫无”目的”的学习，这时候我们让部分未标注的数据集合充作训练集合进行训练。学习得到的模型效果会更好些。</p>
<h4 id="无监督"><a href="#无监督" class="headerlink" title="无监督"></a>无监督</h4><p>&emsp;&emsp;训练样本不带有标签的训练集合作为输入的学习算法。如：聚类问题</p>
<h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><h5 id="分类器-Classifier"><a href="#分类器-Classifier" class="headerlink" title="分类器(Classifier)"></a>分类器(Classifier)</h5><p>&emsp;&emsp;问题的输出只有一个。要么是要么不是。</p>
<h5 id="回归"><a href="#回归" class="headerlink" title="回归"></a>回归</h5><p>&emsp;&emsp;分为线性回归、逻辑回归(修正线性回归带来的过拟合问题)。问题的输出是线性的，可能是可能不是。可以进行多分类。</p>
<h5 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h5><p>&emsp;&emsp;参考神经元模型设计：输入层，隐藏层(可以有多层)，输出层。与字典学习作为机器学习的两大分支。</p>
<h5 id="字典学习"><a href="#字典学习" class="headerlink" title="字典学习"></a>字典学习</h5><p>&emsp;&emsp;将训练集合的特征提取，集合成一个码本进行表示。与神经网络同属于复杂模型学习方法。</p>
<h6 id="稀疏表示"><a href="#稀疏表示" class="headerlink" title="稀疏表示"></a>稀疏表示</h6><p>&emsp;&emsp;通常情况下，我们的特征的维数很大。这就带来一个问题：计算量的提高。为了平衡算法的时间效率。需要将特征降维后，稀疏表示。如KSVD算法就是将特征矩阵进行奇异值分解得到降维后的特征矩阵进行表示。</p>
<h3 id="推荐学习材料"><a href="#推荐学习材料" class="headerlink" title="推荐学习材料"></a>推荐学习材料</h3><ol>
<li><a href="">周志华《机器学习》</a></li>
<li><a href="">斯坦福大学吴恩达《机器学习入门》</a></li>
<li><a href="">台湾大学李宏毅《机器学习入门》</a></li>
</ol>
<h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>&emsp;&emsp;看着这些概念解释，在想还是写代码比较好些…太水了…说了一堆废话。图个心安。推荐的材料太懒了，链接暂时不放了。自己一搜就有，实在找不到底下评论吧。总结来说，还是自己实践太少。即使大四琐事还是一堆(可能和自己太懒以及太笨有关系。羡慕那些脑瓜好使的人。以及动手能力很强的人。)</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;学习机器学习有几周了…也了解了一些基础名词，梳理以下，下回再有人逼叨逼的也不懵了。&lt;/p&gt;
    
    </summary>
    
      <category term="机器学习" scheme="http://www.cvblogs.cn/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="基础概念" scheme="http://www.cvblogs.cn/tags/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>UCF-CV课程总结:边缘检测</title>
    <link href="http://www.cvblogs.cn/2017/09/04/UCF-CVClass-Summary1/"/>
    <id>http://www.cvblogs.cn/2017/09/04/UCF-CVClass-Summary1/</id>
    <published>2017-09-04T11:50:56.000Z</published>
    <updated>2017-09-05T15:48:24.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&emsp;&emsp;这篇博文是本人学习UCF计算机视觉公开课的课程知识梳理系列文章的第二篇。本篇博文主要介绍<u>边缘检测</u>章节的内容。</p>
<a id="more"></a>
<h3 id="课程内容"><a href="#课程内容" class="headerlink" title="课程内容"></a>课程内容</h3><h4 id="相关先导知识"><a href="#相关先导知识" class="headerlink" title="相关先导知识"></a>相关先导知识</h4><p>&emsp;&emsp;边缘一般是指图像在某一局部强度剧烈变化的区域。强度变化一般有两种情况(横轴表示空间变化，纵轴表示灰度变化，虚线表示边缘)：<br><br><img src="http://ou5rpeic9.bkt.clouddn.com/%E4%B8%80%E9%98%B6%E5%AF%BC%E6%95%B0" alt="阶跃变化：向亮渐变的过程">&emsp;&emsp;<img src="http://ou5rpeic9.bkt.clouddn.com/%E4%BA%8C%E9%98%B6%E5%AF%BC%E6%95%B0" alt="屋顶变化：由暗到亮再变暗的过程"><br><br>&emsp;&emsp;边缘检测的任务：找到具有阶跃变化或者屋顶变化的像素点的集合。<br><br>&emsp;&emsp;最直观的想法就是<b>求微分</b>。</p>
<ul>
<li>对于第一种情况：一阶微分的峰值为边缘点，二阶微分的零点为边缘点。</li>
<li>对于第二种情况：一阶微分的零点为边缘点，二阶微分的峰值为边缘点。</li>
</ul>
<p><br>&emsp;&emsp;一般可将边缘分为水平边缘、垂直边缘和对角线边缘。<br><br>&emsp;&emsp;由于边缘检测的算法主要是<b>基于图像强度</b>(采用差分的方法来进行计算)的一阶和二阶导数。<br><br>&emsp;&emsp;但导数通常对噪声敏感，因此必须采用滤波器来改善与噪声有关的边缘检测器的性能。常见的滤波方法主要有<b>高斯滤波</b>，即采用离散化的高斯函数产生一组<b>归一化</b>的高斯核。</p>
<h4 id="一般边缘检测过程"><a href="#一般边缘检测过程" class="headerlink" title="一般边缘检测过程"></a>一般边缘检测过程</h4><p>&emsp;&emsp;1. 滤波：改善与噪声有关的边缘检测器的性能<br><br>&emsp;&emsp;2. 增强：将图像灰度点邻域强度值有显著变化的点凸显出来(可通过计算梯度幅值来确定)<br><br>&emsp;&emsp;3. 检测：常用的方法是通过阈值化方法来检测</p>
<h4 id="边缘检测器介绍-Edge-Detector"><a href="#边缘检测器介绍-Edge-Detector" class="headerlink" title="边缘检测器介绍(Edge Detector)"></a>边缘检测器介绍(Edge Detector)</h4><p>&emsp;&emsp;课程中讲述到的检测器包括：<br><br>&emsp;&emsp;<img src="http://ou5rpeic9.bkt.clouddn.com/%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B%E5%99%A8%E5%88%86%E7%B1%BB.png" alt="边缘检测器分类"></p>
<h5 id="Prewitt-and-Sobel-Edge-Detector"><a href="#Prewitt-and-Sobel-Edge-Detector" class="headerlink" title="Prewitt and Sobel Edge Detector"></a>Prewitt and Sobel Edge Detector</h5><p>&emsp;&emsp;属于离散微分算子 (discrete differentiation operator)。利用差分求出$x,y$方向上的梯度，求解梯度的大小，阈值化梯度的大小找到边缘。</p>
<h6 id="Prewitt算子"><a href="#Prewitt算子" class="headerlink" title="Prewitt算子"></a>Prewitt算子</h6><p>&emsp;&emsp;结合了差分运算与邻域平均的方法。其卷积模板如下：<br><br><img src="http://ou5rpeic9.bkt.clouddn.com/Prewitt%E6%A3%80%E6%B5%8B%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="Prewitt Operator"></p>
<h6 id="Sobel算子"><a href="#Sobel算子" class="headerlink" title="Sobel算子"></a>Sobel算子</h6><p>&emsp;&emsp;与prewitt算子类似，但考虑到了相邻不同像素点的影响程度是不同的，所以采用加权平均。<br><br><img src="http://ou5rpeic9.bkt.clouddn.com/Sobel%E6%A3%80%E6%B5%8B%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="Sobel Operator"></p>
<h5 id="Marr-Hildreth-Edge-Detector-LoG"><a href="#Marr-Hildreth-Edge-Detector-LoG" class="headerlink" title="Marr Hildreth Edge Detector-LoG"></a>Marr Hildreth Edge Detector-LoG</h5><p>&emsp;&emsp;基本步骤：</p>
<ol>
<li>用高斯器滤波原图像去除噪声</li>
<li>拉普拉斯滤波后的图像(求$x,y$二阶导)</li>
<li>找到零点(边缘点)，重复步骤2直到全部找到</li>
</ol>
<p><br><img src="http://ou5rpeic9.bkt.clouddn.com/%E6%A2%AF%E5%BA%A6%E7%AC%A6%E5%8F%B7%E5%92%8C%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E7%AC%A6%E5%8F%B7%E7%9A%84%E5%8C%BA%E5%88%AB.png" alt="求梯度与拉普拉斯符号的区别"><br><br>&emsp;&emsp;laplacian算子是一些使用二阶微分的算子，实际上就是梯度的散度(可以利用DoG近似求解LoG降低算法时间复杂度的数量级?可以增强对比度！)<br><br>LoG计算：不同计算方法，时间复杂度不同</p>
<ol>
<li>一个2D laplacian算子(n{2})</li>
<li>四个1D的算子组合而成(4n)</li>
</ol>
<p><br><img src="http://ou5rpeic9.bkt.clouddn.com/LoG%20Operator" alt="LoG算子"><br><br>&emsp;&emsp;由于 Laplacian使用了图像梯度，它内部的代码其实是调用了 Sobel 算子的</p>
<h5 id="Canny"><a href="#Canny" class="headerlink" title="Canny"></a>Canny</h5><p>&emsp;&emsp;是一种求最优边缘检测的一套方法。是一种<b>先平滑再求导</b>的方法。<br><br>&emsp;&emsp;最优边缘检测的三个主要评价标准：</p>
<ol>
<li><b>低错误率</b>: 标识出尽可能多的实际边缘，同时尽可能的减少噪声产生的误报。</li>
<li><b>高定位性</b>: 标识出的边缘要与图像中的实际边缘尽可能接近。</li>
<li><b>最小响应</b>: 图像中的边缘只能标识一次，并且可能存在的图像噪声不应标识为边缘。</li>
</ol>
<p><br><img src="http://ou5rpeic9.bkt.clouddn.com/Canny%E7%AE%97%E6%B3%95%E6%B1%82%E8%A7%A3%E6%AD%A5%E9%AA%A4.png" alt="Canny算法求解步骤"><br><br>&emsp;&emsp;特别注意第4步！排除非边缘像素， 仅仅保留了一些细线条(候选边缘).</p>
<h4 id="程序实现"><a href="#程序实现" class="headerlink" title="程序实现"></a>程序实现</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">i</span> = imread(<span class="string">'lena.png'</span>);<span class="comment">%读入原图像</span></div><div class="line">A = fspecial(<span class="string">'gaussian'</span>);<span class="comment">%高斯滤波器</span></div><div class="line"><span class="built_in">i</span> = filter2(A, <span class="built_in">i</span>) / <span class="number">255</span>;<span class="comment">%高斯滤波并归一化(/255)</span></div><div class="line">figure;</div><div class="line">imshow(<span class="built_in">i</span>);<span class="comment">%显示图像</span></div><div class="line">imwrite(<span class="built_in">i</span>,<span class="string">'lena_0.jpg'</span>);<span class="comment">%保存图像</span></div><div class="line"><span class="comment">%prewitt方法</span></div><div class="line">a = edge(<span class="built_in">i</span>, <span class="string">'prewitt'</span>);</div><div class="line">figure;</div><div class="line">imshow(a);</div><div class="line">imwrite(a,<span class="string">'lena_1.jpg'</span>);</div><div class="line"><span class="comment">%sobel方法</span></div><div class="line">a = edge(<span class="built_in">i</span>, <span class="string">'sobel'</span>);</div><div class="line">figure;</div><div class="line">imshow(a);</div><div class="line">imwrite(a,<span class="string">'lena_2.jpg'</span>);</div><div class="line"><span class="comment">%marr hildreth方法(LoG)</span></div><div class="line">a = edge(<span class="built_in">i</span>, <span class="string">'log'</span>);</div><div class="line">figure;</div><div class="line">imshow(a);</div><div class="line">imwrite(a,<span class="string">'lena_3.jpg'</span>);</div><div class="line"><span class="comment">%canny方法</span></div><div class="line">a = edge(<span class="built_in">i</span>, <span class="string">'canny'</span>);</div><div class="line">figure;</div><div class="line">imshow(a);</div><div class="line">imwrite(a,<span class="string">'lena_4.jpg'</span>);</div></pre></td></tr></table></figure>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ol>
<li><a href="http://blog.csdn.net/xiahn1a/article/details/42141429" target="_blank" rel="external">边缘检测算法</a></li>
<li><a href="">【OpenCV入门教程之十二】OpenCV边缘检测：Canny算子,Sobel算子,Laplace算子,Scharr滤波器合辑</a></li>
</ol>
<h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p><br>&emsp;&emsp;一如既往，写文章对于我真的是一件万分困难的事情，基本上只能达到通顺的要求。翻来覆去也就只能用那几个markdown语法。排版也不甚美观。但我相信，坚持下去，总有一天，我能写出自己的内容。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;这篇博文是本人学习UCF计算机视觉公开课的课程知识梳理系列文章的第二篇。本篇博文主要介绍&lt;u&gt;边缘检测&lt;/u&gt;章节的内容。&lt;/p&gt;
    
    </summary>
    
      <category term="计算机视觉" scheme="http://www.cvblogs.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="课程总结" scheme="http://www.cvblogs.cn/tags/%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>UCF-CV课程总结:概述、滤波及Matlab使用</title>
    <link href="http://www.cvblogs.cn/2017/09/01/UCF-CVClass-Summary/"/>
    <id>http://www.cvblogs.cn/2017/09/01/UCF-CVClass-Summary/</id>
    <published>2017-09-01T09:20:40.000Z</published>
    <updated>2017-09-05T15:48:24.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&emsp;&emsp;从八月开始，断断续续学习这门课程。从一开始Coursera上乔治亚理工的CV课和CP课继而到UCF的CV课。算是入门了这门课程，为以后的研究工作打下了一些基础。虽然，我的数学基础在很大程度上限制着我的吸收消化。但是，始终相信，有志者事竟成这个道理。<br><br>&emsp;&emsp;课程资源地址：<a href="http://crcv.ucf.edu/courses/CAP5415/Fall2012/" target="_blank" rel="external">UCF-CAP 5415 - Computer Vision</a>学习过程中，可以参照课程日程表安排学习时间。适当的加强强度。(由于时间问题，本人只完成了小部分实验…最好还是要做做实验的。)</p>
<a id="more"></a>
<p><br>&emsp;&emsp;虽然在onenote上针对每节课都已经做了笔记，但是发现，自己只是将教授PPT中的内容摘抄了出来。这里借助博客<u>简单梳理一下这门课中学习到的内容</u>(事实上，其中的每一课都值得另起一篇去详细介绍)，顺便提升自己的写作能力总结能力。<br><br>&emsp;&emsp;我发现，本文的长度大大超过了预期。因此，基于”2-8准则”(实则我实在无法做到一小时完成这个工作)，计划每篇此类总结文章以两到三课为一篇文章去总结课程内容。</p>
<h3 id="课程内容"><a href="#课程内容" class="headerlink" title="课程内容"></a>课程内容</h3><p>&emsp;&emsp;整门课内容设计较为合理，作为重实现轻理论(少数学细节推导，乔治亚理工的课程较侧重于数学细节)大军中的一员，接受度良好。在课程主页上还有参考资料(免费，开放下载)以及CV领域的顶刊顶会的官网链接等信息。</p>
<h4 id="Lecture1-CVIntroduction"><a href="#Lecture1-CVIntroduction" class="headerlink" title="Lecture1 CVIntroduction"></a>Lecture1 CVIntroduction</h4><p>&emsp;&emsp;第一课是关于计算机视觉中基础知识的介绍以及整个课程会接触到的内容的学习。了解计算机视觉所研究的是从二维图像中得到三维世界的语意信息。<br><br><img src="http://ou5rpeic9.bkt.clouddn.com/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E9%A2%86%E5%9F%9F.png" alt="The Ability of Computer to See"><br><br>&emsp;&emsp;在这个过程中，常常将图像当作一个函数$f(x,y)$,它是一个离散的关于像素点的函数。常用一个矩阵表示一张图像，其元素是0(黑)～255(白)的灰度值。分辨率则是由图像的像素长宽确定(屏幕的分辨率通常是固定的，但是可以向下调整，分辨率越高图像越细腻)。还介绍了图片的格式(不同的格式只是压缩编码的方式不同)。也介绍了视频的基本属性。依照人眼的构造，视频帧数每秒30帧就可以达到流畅的基本要求。<br><br>&emsp;&emsp;现今的射影设备都是基于孔洞模型(Pin Hole)进行射影变换。<br><br><img src="http://ou5rpeic9.bkt.clouddn.com/2Pin%20Hole%20Model.png" alt="Pin Hole Model"><br><br>&emsp;&emsp;三维空间中的点$(x,y,z)$通过镜片投影到图像平面上的点$(x,y)$<br><br>&emsp;&emsp;由以上这个模型，我们就很容易想到：应该如何通过二维图像恢复被摄物体在三维世界中的几何信息呢？<br><br><img src="http://ou5rpeic9.bkt.clouddn.com/3%E4%BB%8E%E4%BA%8C%E7%BB%B4%E5%9B%BE%E5%83%8F%E6%81%A2%E5%A4%8D%E4%B8%89%E7%BB%B4%E4%BF%A1%E6%81%AF.png" alt="三维重构理论"><br><br>&emsp;&emsp;这里不再细展开。以及，CV的应用有哪些：<br><br><img src="http://ou5rpeic9.bkt.clouddn.com/4CV%20Applicatioin.png" alt="CV Application"><br><br>&emsp;&emsp;作为基础知识的简单入门，第一节课还是很不错的。至少罗列的那些应用光是看那些演示视频，想到自己也有机会去实现。光想想就能振奋人心。</p>
<h4 id="Lecture2-Filtering"><a href="#Lecture2-Filtering" class="headerlink" title="Lecture2 Filtering"></a>Lecture2 Filtering</h4><p>&emsp;&emsp;第二节课是CV领域最最基础的一个概念–滤波(Filtering)。我的<a href="https://cvblogs.cn/2017/08/11/image-processing-operation1/" target="_blank" rel="external">第一篇博文</a>整理的就是关于滤波操作的知识(虽然大部分是copy的别人的总结…)。<br><br>&emsp;&emsp;首先，当你拿到一张图像，一定要区分清楚它究竟是:1.二值的(Binary)、2.灰度的(Gray Scale)还是3.彩色的(Color)。<br><br>&emsp;&emsp;1.二值图像矩阵元素要么是0要么是1<br><br>&emsp;&emsp;2.灰度图像，Scale范围通常(0~255)<br><br>&emsp;&emsp;3.彩色图像较为复杂，通常在RGB空间下分为3个通道(R-Red、G-Green、B-Blue)<br><br>&emsp;&emsp;因为这些值元素的存在，引入一个图像直方图去直观描述它的比重信息。<br><br>&emsp;&emsp;<img src="http://ou5rpeic9.bkt.clouddn.com/5%E7%9B%B4%E6%96%B9%E5%9B%BE.png" alt="直方图"><br><br>&emsp;&emsp;由于各种内外界不稳定因素的干扰，图像并不总是”干净”的,总是有这样那样的噪声(通常高频信息是噪声-变化明显，变现的特征就是高频信息)。噪声叠加原图像得到被污染后的图像。(高斯噪声即噪声的分布符合高斯分布！)<br><br>&emsp;&emsp;<img src="http://ou5rpeic9.bkt.clouddn.com/6%E5%99%AA%E5%A3%B0%E6%9D%A5%E6%BA%90.png" alt="噪声来源"><br><br>&emsp;&emsp;接着为引入滤波的概念，介绍了基本的数学运算：求导(Derivative，包括连续的和离散的即查分：向前、向后、中心，接着从一维引申到二维（图像是一个二维矩阵），接着提到了相关(Correlation)以及卷积(Convolution))以及求均值(Average/Mean)。<br><br>&emsp;&emsp;<img src="http://ou5rpeic9.bkt.clouddn.com/7%E4%BA%8C%E7%BB%B4%E6%B1%82%E5%AF%BC%28%E6%A2%AF%E5%BA%A6%29.png" alt="求导(梯度)">并且，还提到了掩膜(Mask)的概念。<br><br>&emsp;&emsp;高斯分布的重要意义：<br><br>&emsp;&emsp;<img src="http://ou5rpeic9.bkt.clouddn.com/8%E9%AB%98%E6%96%AF%E6%A8%A1%E5%9E%8B%E5%B1%9E%E6%80%A7.png" alt="高斯属性"><br><br>&emsp;&emsp;由于之前的文章已经梳理过，这里不再赘述。第二节结束。目前，我们已经了解了一些基本知识和基本运算(Matlab由库函数实现，推荐使用。)</p>
<h4 id="Matlab-Tutorial"><a href="#Matlab-Tutorial" class="headerlink" title="Matlab Tutorial"></a>Matlab Tutorial</h4><p>&emsp;&emsp;作为课程的辅助章节，本节内容介绍Matlab的基本使用，作为Matlab的简单入门还是很有必要学习的。助教教授的内容都很实用。(对于没有接触过Matlab的人来说，通过学习本节可以完成基本编程任务。推荐观看。另外，斯坦福的吴恩达教授也在其机器学习视频中教授过Matlab的简单操作使用。也可以参考学习。)</p>
<h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>&emsp;&emsp;写博客真是一项锻炼能力的活，花了一个半小时才写完两节课的简单梳理总结。这进度我也是醉了！看来，以后应该利用碎片化的闲暇时间一点点完成。否则太占用学习时间了！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;从八月开始，断断续续学习这门课程。从一开始Coursera上乔治亚理工的CV课和CP课继而到UCF的CV课。算是入门了这门课程，为以后的研究工作打下了一些基础。虽然，我的数学基础在很大程度上限制着我的吸收消化。但是，始终相信，有志者事竟成这个道理。&lt;br&gt;&lt;br&gt;&amp;emsp;&amp;emsp;课程资源地址：&lt;a href=&quot;http://crcv.ucf.edu/courses/CAP5415/Fall2012/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;UCF-CAP 5415 - Computer Vision&lt;/a&gt;学习过程中，可以参照课程日程表安排学习时间。适当的加强强度。(由于时间问题，本人只完成了小部分实验…最好还是要做做实验的。)&lt;/p&gt;
    
    </summary>
    
      <category term="计算机视觉" scheme="http://www.cvblogs.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="课程总结" scheme="http://www.cvblogs.cn/tags/%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>图像处理基础-滤波(filtering)</title>
    <link href="http://www.cvblogs.cn/2017/08/11/image-processing-operation1/"/>
    <id>http://www.cvblogs.cn/2017/08/11/image-processing-operation1/</id>
    <published>2017-08-11T11:39:53.000Z</published>
    <updated>2017-09-05T15:48:24.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&emsp;&emsp;本文介绍图像处理基础知识滤波(filtering)相关知识。在<a href="https://www.wikiwand.com/zh/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86" target="_blank" rel="external">图像处理</a>中，你经常能够看到它的身影。对于学习图像处理，理解滤波背后的数学知识非常重要。</p>
<p>&emsp;&emsp;滤波分为<u>基于空间域滤波</u>(spatial filtering)与<u>基于频率域滤波</u>(frequency filtering)。二者的目的都是为了改善图像质量。篇幅有限，此篇文章先介绍空间滤波。</p>
<h3 id="空间滤波-Spatial-Filtering"><a href="#空间滤波-Spatial-Filtering" class="headerlink" title="空间滤波(Spatial Filtering)"></a>空间滤波(Spatial Filtering)</h3><p>&emsp;&emsp;空间滤波操作有时候也被叫做<font color="#0099ff">卷积滤波</font>，或者干脆叫卷积(convolution)(离散的卷积，不是微积分里连续的卷积);常常需要用一个<font color="#0099ff">滤波器</font>(filter)做空间滤波操作;滤波器也有很多名字:<font color="#0099ff">卷积模版(template)</font>、<font color="#0099ff">卷积核(kernel)</font>、<font color="#0099ff">掩模(mask)</font>、<font color="#0099ff">窗口(window)</font>等。</p>
<p>&emsp;&emsp;空间滤波可以分为<font color="#0099ff">线性滤波(linear filter)</font>和<font color="#0099ff">非线性滤波(non-linear filter)</font>。非线性滤波常见的有中值滤波、最大值滤波等，相当于自定义一个函数，在数学上由于不满足线性变换因此叫做非线性滤波。这里不细研究它。</p>
<p>&emsp;&emsp;<font color="#0099ff">线性滤波</font>通常是：将模版覆盖区域内的元素，以模版中对应位置元素为权值，进行累加。与卷积操作类似的，还有一种数学操作叫做协相关(cross-correlatioin)，<u>它们都可以看作是基于矩阵内积的操作</u>。具有<font color="#0099ff">平移不变性(shift-invariant)</font>。</p>
<p><img src="http://ou5rpeic9.bkt.clouddn.com/cross-correlation%E6%96%87%E5%AD%97%E8%A7%A3%E9%87%8A.png" alt="Cross-Correlation"></p>
<p>&emsp;&emsp;<font color="#0099ff">二者的区别：</font><u>卷积和协相关的差别是，卷积需要先对滤波矩阵进行<font color="#0099ff">180度的翻转</font>，但如果矩阵是对称的，那么两者就没有什么差别了</u>。实际上，在信号处理领域，卷积有广泛的意义，而且有其严格的数学定义，但在这里不关注这个。2D卷积需要4个嵌套循环(4-double loop)，所以它并不快，除非我们使用很小的卷积核。这里一般使用3x3或者5x5。而且，<u>对于滤波器，也有一定的规则要求</u>：</p>
<blockquote>
<p>1）滤波器的大小应该是奇数，这样它才有一个中心，例如3x3，5x5或者7x7。有中心了，也有了半径的称呼，例如5x5大小的核的半径就是2。</p>
<p>2）滤波器矩阵所有的元素之和应该要等于1，这是为了保证滤波前后图像的亮度保持不变。当然了，这不是硬性要求了。</p>
<p>3）如果滤波器矩阵所有元素之和大于1，那么滤波后的图像就会比原图像更亮，反之，如果小于1，那么得到的图像就会变暗。如果和为0，图像不会变黑，但也会非常暗。</p>
<p>4）对于滤波后的结构，可能会出现负数或者大于255的数值。对这种情况，我们将他们直接截断到0和255之间即可。对于负数，也可以取绝对值。</p>
</blockquote>
<h3 id="卷积核-Convolution-Kernel"><a href="#卷积核-Convolution-Kernel" class="headerlink" title="卷积核(Convolution Kernel)"></a>卷积核(Convolution Kernel)</h3><p>&emsp;&emsp;定义不同的卷积核与原图像做卷积操作，可以产生不同的效果。滤波与模糊的概念区分。模糊是人为感受到的现象，通过滤波操作可以呈现。</p>
<h4 id="什么都不做"><a href="#什么都不做" class="headerlink" title="什么都不做"></a>什么都不做</h4><p>&emsp;&emsp;滤波器矩阵所有元素之和为1，保证滤波前后图像的亮度保持不变。这个滤波器啥也没有做，得到的图像和原图是一样的。因为只有中心点的值是1。邻域点的权值都是0，对滤波后的取值没有任何影响。</p>
<p><img src="http://ou5rpeic9.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-08-13%2014.50.25.png" alt=""></p>
<h4 id="图像锐化滤波器-Sharpness-Filter"><a href="#图像锐化滤波器-Sharpness-Filter" class="headerlink" title="图像锐化滤波器(Sharpness Filter)"></a>图像锐化滤波器(Sharpness Filter)</h4><p>&emsp;&emsp;图像的锐化和边缘检测很像，首先找到边缘，然后把边缘加到原来的图像上面，这样就强化了图像的边缘，使图像看起来更加锐利了。这两者操作统一起来就是锐化滤波器了，<u>也就是在边缘检测滤波器的基础上，再在中心的位置加1，这样滤波后的图像就会和原始的图像具有同样的亮度了，但是会更加锐利。</u></p>
<p><img src="http://ou5rpeic9.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-08-13%2014.50.44.png" alt=""></p>
<p>&emsp;&emsp;我们把核加大，就可以得到更加精细的锐化效果</p>
<p><img src="http://ou5rpeic9.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-08-13%2014.50.52.png" alt=""></p>
<p>&emsp;&emsp;下面的滤波器会更强调边缘。</p>
<p><img src="http://ou5rpeic9.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-08-13%2014.56.05.png" alt=""></p>
<p>&emsp;&emsp;主要是<u>强调图像的细节</u>。最简单的3x3的锐化滤波器如下：</p>
<p><img src="http://ou5rpeic9.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-08-13%2014.53.58.png" alt=""></p>
<p>&emsp;&emsp;实际上是计算当前点和周围点的差别，然后将这个差别加到原来的位置上。另外，<u>中间点的权值要比所有的权值和大于1，意味着这个像素要保持原来的值。</u></p>
<h4 id="边缘检测-Edge-Detection"><a href="#边缘检测-Edge-Detection" class="headerlink" title="边缘检测(Edge Detection)"></a>边缘检测(Edge Detection)</h4><p>&emsp;&emsp;我们要找水平的边缘：<u>需要注意的是，这里矩阵的元素和是0，所以滤波后的图像会很暗</u>，只有边缘的地方是有亮度的。</p>
<p><img src="http://ou5rpeic9.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-08-13%2014.59.54.png" alt=""></p>
<p>&emsp;&emsp;相当于做差分(differencing)，求导的离散版本，有向前差分(forward differencing)，向后差分(backward differencing)，中心差分(central differencing)。</p>
<p>&emsp;&emsp;下面的滤波器可以找到垂直方向的边缘，这里像素上和下的像素值都使用</p>
<p><img src="http://ou5rpeic9.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-08-13%2015.08.09.png" alt=""></p>
<p>&emsp;&emsp;再下面这个滤波器可以找到45度的边缘：取-2不为了什么，只是为了让矩阵的元素和为0而已。</p>
<p><img src="http://ou5rpeic9.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-08-13%2015.10.30.png" alt=""></p>
<p>&emsp;&emsp;那下面这个滤波器就可以检测所有方向的边缘。</p>
<p><img src="http://ou5rpeic9.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-08-13%2015.17.38.png" alt=""></p>
<p>&emsp;&emsp;为了检测边缘，我们需要在图像对应的方向计算梯度。用下面的卷积核来卷积图像，就可以了。但在实际中，这种简单的方法<u>会把噪声也放大</u>了。另外，需要注意的是，<u>矩阵所有的值加起来要是0</u>。</p>
<p><img src="http://ou5rpeic9.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-08-13%2015.21.07.png" alt=""></p>
<h4 id="浮雕-Embossing-Filter"><a href="#浮雕-Embossing-Filter" class="headerlink" title="浮雕(Embossing Filter)"></a>浮雕(Embossing Filter)</h4><p>&emsp;&emsp;浮雕滤波器可以给图像一种3D阴影的效果。只要将中心一边的像素减去另一边的像素就可以了。这时候，像素值有可能是负数，我们将负数当成阴影，将正数当成光，然后我们<u>对结果图像加上128的偏移</u>。这时候，图像大部分就变成灰色了。</p>
<p>&emsp;&emsp;下面是45度的浮雕滤波器</p>
<p><img src="http://ou5rpeic9.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-08-13%2015.25.28.png" alt=""></p>
<p>&emsp;&emsp;只要加大滤波器，就可以得到更加夸张的效果了</p>
<p><img src="http://ou5rpeic9.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-08-13%2015.27.12.png" alt=""></p>
<h4 id="均值模糊-Box-Filter-Averaging"><a href="#均值模糊-Box-Filter-Averaging" class="headerlink" title="均值模糊(Box Filter/Averaging)"></a>均值模糊(Box Filter/Averaging)</h4><p>&emsp;&emsp;我们可以将当前像素和它的四邻域的像素一起取平均，然后再除以5，或者直接在滤波器的5个地方取0.2的值即可，如下图</p>
<p><img src="http://ou5rpeic9.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-08-13%2015.29.23.png" alt=""></p>
<p>&emsp;&emsp;可以看到，这个模糊还是比较温柔的，我们可以把滤波器变大，这样就会变得粗暴了：<u>注意要将和再除以13.</u></p>
<p><img src="http://ou5rpeic9.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-08-13%2015.33.28.png" alt=""></p>
<p>&emsp;&emsp;如果你想要更模糊的效果，加大滤波器的大小即可。或者对图像应用<u>多次模糊</u>也可以。</p>
<h4 id="高斯模糊-Gaussian-Filter"><a href="#高斯模糊-Gaussian-Filter" class="headerlink" title="高斯模糊(Gaussian Filter)"></a>高斯模糊(Gaussian Filter)</h4><p>&emsp;&emsp;<u>均值模糊很简单，但不是很平滑。高斯模糊就有这个优点，所以被广泛用在图像降噪上。特别是在边缘检测之前，都会用来移除细节。高斯滤波器是一个低通滤波器。</u></p>
<h4 id="运动模糊-Motion-Blur"><a href="#运动模糊-Motion-Blur" class="headerlink" title="运动模糊(Motion Blur)"></a>运动模糊(Motion Blur)</h4><p>&emsp;&emsp;运动模糊可以通过只在一个方向模糊达到，例如下面9x9的运动模糊滤波器。注意，<u>求和结果要除以9。</u></p>
<p>&emsp;&emsp;这个效果就好像，摄像机是从左上角移动的右下角。</p>
<p><img src="http://ou5rpeic9.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-08-13%2015.41.32.png" alt=""></p>
<h3 id="自己手写的卷积函数"><a href="#自己手写的卷积函数" class="headerlink" title="自己手写的卷积函数"></a>自己手写的卷积函数</h3><p>虽然Matlab已经封装了一个函数con2()作卷积操作，但是还是要自己手写一下加深理解。下面是<a href="http://crcv.ucf.edu/courses/CAP5415/Fall2012/" target="_blank" rel="external">UCF计算机视觉网课</a>的作业。4层循环。因为<u>边缘效应</u>通常情况下需要补0。还是Matlab新手，代码一点都不elegant，没有借鉴意义。<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="params">[]</span> = <span class="title">pa1</span><span class="params">()</span></span></div><div class="line">m_img = imread(<span class="string">'PA1/balloon.jpg'</span>);</div><div class="line">m_kernel = <span class="built_in">rand</span>(<span class="number">5</span>,<span class="number">5</span>);</div><div class="line">[r1, c1, cc1] = <span class="built_in">size</span>(m_img);</div><div class="line">[r2, c2] = <span class="built_in">size</span>(m_kernel);</div><div class="line"><span class="keyword">for</span> <span class="built_in">i</span> = r2+<span class="number">1</span>:r1</div><div class="line">    <span class="keyword">for</span> <span class="built_in">j</span> = c2+<span class="number">1</span>:c1</div><div class="line">        sump = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> k = <span class="number">1</span>:r2</div><div class="line">            <span class="keyword">for</span> l = <span class="number">1</span>:c2</div><div class="line">                sump = m_img(<span class="built_in">i</span>-k, <span class="built_in">j</span>-l) * m_kernel(k,l);</div><div class="line">            <span class="keyword">end</span>;</div><div class="line">        <span class="keyword">end</span>;</div><div class="line">        outQ(<span class="built_in">i</span>,<span class="built_in">j</span>) = sump;</div><div class="line">    <span class="keyword">end</span>;</div><div class="line"><span class="keyword">end</span></div><div class="line">imshow(outQ);wait(<span class="number">0</span>);</div></pre></td></tr></table></figure></p>
<h3 id="Matlab中用imfilter-实现线性空间滤波"><a href="#Matlab中用imfilter-实现线性空间滤波" class="headerlink" title="Matlab中用imfilter()实现线性空间滤波"></a>Matlab中用imfilter()实现线性空间滤波</h3><p>&emsp;&emsp;最常用的是这句：<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">imfilter(f, w, <span class="string">'replicate'</span>) <span class="comment">%相关滤波，默认边界外围填充0，造成黑边，使用'replicate'复制边缘像素，消除边缘效应，输出大小与输入图像f相同.</span></div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;imfilter()默认是相关算子，在做真正的卷积之前可以先将核旋转180°(除非你指定了滤波模式为’conv’)，rotated_filter=flipud(fliplr(filter))<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">imfilter(f, w, filtering_mode, boundary_options, size_options)</div><div class="line">f:图像</div><div class="line">w:滤波模版</div><div class="line">filtering_mode:滤波模式</div><div class="line">    &apos;corr&apos;:相关滤波。[默认值]</div><div class="line">    &apos;conv&apos;:卷积滤波。</div><div class="line">boundary_options:边界选项</div><div class="line">    P:(没有引号)边界外围补充0。[默认值]</div><div class="line">    &apos;replicate&apos;:边界外围复制边界值</div><div class="line">    &apos;symmetric&apos;:边界外围使用边界镜像</div><div class="line">    &apos;circular&apos;:图像的大小通过讲图像处理为二维周期函数的一个周期来扩展（这是什么？）</div><div class="line">size_options:大小选项</div><div class="line">    &apos;same&apos;:输出大小与输入图像f大小相同。[默认值]</div><div class="line">    &apos;full&apos;:输出与扩展（填充）后的图像大小相同。</div></pre></td></tr></table></figure></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li><p>规范用语，在<font color="#0099ff">滑窗操作</font>、<font color="#0099ff">计算图像梯度</font>等场合，不要使用“卷积”，而要使用“滤波”或者“协相关”。因为，我们通常讲的卷积，在这几个操作中其实是协相关，那就不要用卷积这个词以<u>避免引起混淆</u>。</p>
</li>
<li><p>不同的滤波器产生的效果不同，滤波器的定义有讲究。经常会看到一些人名命名的算子。比如用作边缘检测，拉普拉斯(Laplacian)算子、Canny算子。观察它们的算子内容，结合卷积核的定义规则。你会发现其实就那么回事。不要被复杂的学术名词给弄懵逼了。</p>
</li>
<li><p>GPU实现代替CPU实现，CPU实现需要四重循环，时间代价太大，性能不好。GPU使用特定的数据结构直接进行计算降低时间代价。</p>
</li>
<li><p>这是我的第一篇博文，本来是想好好写的，发现写博文真的是一项技术活。话到嘴边，憋不出一个字。</p>
</li>
</ol>
<h3 id="参考引用"><a href="#参考引用" class="headerlink" title="参考引用"></a>参考引用</h3><ol>
<li><p><a href="http://blog.csdn.net/zouxy09/article/details/49080029" target="_blank" rel="external">图像卷积与滤波的一些知识点</a></p>
</li>
<li><p><a href="http://www.cnblogs.com/zjutzz/p/5661543.html" target="_blank" rel="external">图像卷积、相关以及在MATLAB中的操作</a></p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;本文介绍图像处理基础知识滤波(filtering)相关知识。在&lt;a href=&quot;https://www.wikiwa
    
    </summary>
    
      <category term="图像处理" scheme="http://www.cvblogs.cn/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
    
      <category term="数学基础" scheme="http://www.cvblogs.cn/tags/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>开发测试</title>
    <link href="http://www.cvblogs.cn/2017/08/05/hello-world/"/>
    <id>http://www.cvblogs.cn/2017/08/05/hello-world/</id>
    <published>2017-08-05T11:11:50.000Z</published>
    <updated>2017-08-13T19:08:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="博客正在完善中"><a href="#博客正在完善中" class="headerlink" title="博客正在完善中"></a>博客正在完善中</h1><font size="7">&emsp;&emsp;稍安勿躁</font>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;博客正在完善中&quot;&gt;&lt;a href=&quot;#博客正在完善中&quot; class=&quot;headerlink&quot; title=&quot;博客正在完善中&quot;&gt;&lt;/a&gt;博客正在完善中&lt;/h1&gt;&lt;font size=&quot;7&quot;&gt;&amp;emsp;&amp;emsp;稍安勿躁&lt;/font&gt;

    
    </summary>
    
      <category term="网页开发" scheme="http://www.cvblogs.cn/categories/%E7%BD%91%E9%A1%B5%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="测试" scheme="http://www.cvblogs.cn/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
</feed>
