<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CVBlogs</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.cvblogs.cn/"/>
  <updated>2017-12-12T04:36:49.789Z</updated>
  <id>http://www.cvblogs.cn/</id>
  
  <author>
    <name>Zhong Qin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>mxnet之简单线性回归源码解读</title>
    <link href="http://www.cvblogs.cn/2017/12/12/%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/mxnet-%E7%AE%80%E5%8D%95%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    <id>http://www.cvblogs.cn/2017/12/12/开发学习/mxnet-简单线性回归源码解读/</id>
    <published>2017-12-12T02:40:21.000Z</published>
    <updated>2017-12-12T04:36:49.789Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>此篇博文相关：<a href="http://zh.gluon.ai/chapter_supervised-learning/linear-regression-gluon.html" target="_blank" rel="external">线性回归 — 使用Gluon</a>中源码的解读。<br><a id="more"></a></p>
<h1 id="源码及注释解析"><a href="#源码及注释解析" class="headerlink" title="源码及注释解析"></a>源码及注释解析</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 设置迭代次数5次，每次迭代都完整取所有数据</span></div><div class="line">epochs = <span class="number">5</span></div><div class="line"><span class="comment"># 设置每次取数据的batch = 10，如例子中数据集是1000，则每次迭代都取100次数据，每次都取10个数据</span></div><div class="line">batch_size = <span class="number">10</span></div><div class="line"><span class="comment"># for循环迭代：共5次，range(epochs)模拟0，1，2，3，4</span></div><div class="line"><span class="keyword">for</span> e <span class="keyword">in</span> range(epochs):</div><div class="line">    <span class="comment">#每次迭代，初始的损失置为0</span></div><div class="line">    total_loss = <span class="number">0</span></div><div class="line">    <span class="comment"># 从data_iter迭代器中取数据，data_iter = gluon.data.Dataloader(dataset,batch_size,shuffle=True)</span></div><div class="line">    <span class="comment"># 上诉dataset = gluon.data.ArrayDataset(X,y)即由数据集X和其对应的标签y组成的数据集合</span></div><div class="line">    <span class="comment"># 因此，data_iter迭代器每次取出的data和label即batch_size个数据集对：X'和y'，直到取完所有数据，结束循环（1000/10=100次）</span></div><div class="line">    <span class="keyword">for</span> data, label <span class="keyword">in</span> data_iter:</div><div class="line">        <span class="comment"># 利用autograd.record()API自动记录梯度</span></div><div class="line">        <span class="keyword">with</span> autograd.record():</div><div class="line">            <span class="comment"># 输出等于将数据X传入你定义的模型net（可以这么理解：线性模型即是y'关于x的函数）</span></div><div class="line">            output = net(data)</div><div class="line">            <span class="comment"># 这里定义的损失函数是衡量真值label与有你的模型产生的预测值之间的误差。此处使用的是均方误差，你也可以换成你自己定义的其他损失函数</span></div><div class="line">            loss = square_loss(output, label)</div><div class="line">        <span class="comment"># 反向传播误差，这里可以将这个动作看作是一个信号，损失反向了，但是真正利用损失反向传播的却是接下来的trainer</span></div><div class="line">        loss.backward()</div><div class="line">        <span class="comment"># 传播了误差之后，我们还需要利用一些更新参数的方法对参数进行更新</span></div><div class="line">        <span class="comment"># 注意这里使用的是gluon提供的API:gluon.Trainer(net.collect_params,'使用的更新模型参数的方法名：如随机梯度下降',&#123;指定的学习率learning_rate:0.1是一个字典&#125;)</span></div><div class="line">        <span class="comment"># 如：trainer = gluon.Trainer(net.collect_params(),'sgd', &#123;'learning_rate': 0.1&#125;)</span></div><div class="line">        <span class="comment"># 最后利用trainer.step(batch_size)API反向更新模型参数w,b</span></div><div class="line">        trainer.step(batch_size)</div><div class="line">        <span class="comment"># 将每次训练的损失加入总损失（一共要加100次，直到迭代完成）。由于每次循环得到的是一个长度为batch_size的一维向量，但是总损失是标量。因此得利用asscalar()转化为标量进行操作</span></div><div class="line">        total_loss += nd.sum(loss).asscalar()</div><div class="line">    <span class="comment"># 打印出一次迭代的平均误差=总误差/样本数</span></div><div class="line">    print(<span class="string">"Epoch %d, average loss: %f"</span> % (e, total_loss/num_examples))</div></pre></td></tr></table></figure>
<h1 id="一些易混淆的名词"><a href="#一些易混淆的名词" class="headerlink" title="一些易混淆的名词"></a>一些易混淆的名词</h1><h2 id="模型定义"><a href="#模型定义" class="headerlink" title="模型定义"></a>模型定义</h2><p>可以这么通俗的理解：模型即是你定义的一个由数据集生成预测值的函数。在训练过程中，我们往模型中传入训练数据集得到的是一个预测值。我们无法知道这个预测值到底是对是错是好是坏。它只是单纯的对预测值的一个刻画。</p>
<h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><p>那么我们如何描述我们的模型是好是坏呢？这里就必须引入损失这个概念。所谓损失，单纯来讲就是预测值与真实值之间的误差。理想情况下，我们希望我们的损失是0或者接近于0。</p>
<h2 id="初始化模型参数"><a href="#初始化模型参数" class="headerlink" title="初始化模型参数"></a>初始化模型参数</h2><p>其实当我们在说模型的时候，我们通常不能很完整的说出：我们的模型具体是什么（我在想这可能是由于我们维度限制了我们的想象力= =）。也就是大部分模型无法解释清楚的。不像线性模型：我们可以这么定义：$y^’=wx+b$，然后我们可以这么解释：例如，w是斜率而b是截距。但是对于一些非线性的模型，里头的参数不再具有可解释性质。<br>因此，一般情况下，我们说我训练一个模型指的就是我训练了模型中的参数。例如：w和b就是我们通过训练线性模型得到的参数。<br>但是，想象一下，最初的时候，我们手上只有一些数据，以及数据对应的标签（真实值）。还是以线性模型为例子：我们定义了一个模型$y^’=wx+b$(目前，在不对w和b初始化的情况下，这两个也是变量)。因此，我们的模型就有了三个变量。但是我们只希望在给模型传入一个数据x的时候得到的是一个预测值$y^’$。<br>因此，我们就需要初始化我们的模型参数w和b。我们可以随机对其初始化，也可以指定一个参数（可能是从其他地方迁移学习过来的：其实就是按照数据集的关系的相似性，衡量照抄它的参数= =）。</p>
<h2 id="模型参数更新策略（优化）"><a href="#模型参数更新策略（优化）" class="headerlink" title="模型参数更新策略（优化）"></a>模型参数更新策略（优化）</h2><p>现在，我们的模型中只剩下一个变量$y^’$，我们可以输入一个数据得到一个预测值。我们通过比较预测值和真实值得到损失。但是，我们要如何更新我们的参数使得我们的模型在每一次迭代完所有数据之后。根据损失，能够调整模型参数！实现利用<strong>数据编程</strong>！<br>这里就有了反向传播以及随机梯度下降等的概念。反向传播传播的是损失（也叫残差），随机梯度中就是利用损失的反向梯度，往回走batch_size个样本损失的距离，使得参数得到更新。<code>param[:] = param - lr * param.grad</code>。这里lr就是学习率。<br>这样在进行下一次循环（此时还是在一次迭代，100次循环里头）的时候，我们的参数能够有所改进，使模型更拟合真实数据。也就是说话我们共循环更新了5*1000/10=500次参数！</p>
<h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>尽管不知道已经花了多少时间和精力取学习了多少机器学习相关的东西，但是感觉自己对于理论或者说这些专有名词，永远都不上心的样子。但是这样子真的是百害而无一利。直到我遇到了李沐老师团队的MXNet= =。决定一定要沉心静气学好理论并且动手实践！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;此篇博文相关：&lt;a href=&quot;http://zh.gluon.ai/chapter_supervised-learning/linear-regression-gluon.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;线性回归 — 使用Gluon&lt;/a&gt;中源码的解读。&lt;br&gt;
    
    </summary>
    
      <category term="机器学习" scheme="http://www.cvblogs.cn/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="MXNet" scheme="http://www.cvblogs.cn/tags/MXNet/"/>
    
  </entry>
  
  <entry>
    <title>python之高级语言特性：切片</title>
    <link href="http://www.cvblogs.cn/2017/12/11/%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/python-%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/"/>
    <id>http://www.cvblogs.cn/2017/12/11/开发学习/python-高级语言特性/</id>
    <published>2017-12-11T15:19:34.000Z</published>
    <updated>2017-12-12T04:39:54.535Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>由于最近大都使用Python作为主要的开发语言，并且以后也将长期使用（用于编程科学计算相关的内容）等。决定还是好好学习一下python。<br>以下内容是学习<a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431756919644a792ee4ead724ef7afab3f7f771b04f5000" target="_blank" rel="external">廖雪峰Python教程-切片</a>的笔记梳理。</p>
<a id="more"></a>
<h1 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h1><p>对这种经常取指定索引范围的操作，用循环十分繁琐，因此，Python提供了切片（Slice）操作符，能大大简化这种操作。<br><code>L[0:3]</code>表示，从索引<code>0</code>开始取，直到索引<code>3</code>为止，但<strong>不包括索引<code>3</code></strong>。即索引<code>0</code>，<code>1</code>，<code>2</code>，正好是<code>3</code>个元素。<br>如果第一个索引是<code>0</code>，还可以省略：<code>L[:3]</code><br>类似的，既然Python支持<code>L[-1]</code>取倒数第一个元素，那么它同样<strong>支持倒数切片</strong>:<code>L[-2:]</code>。记住倒数第一个元素的索引是<code>-1</code>。<br>什么都不写，只写<code>[:]</code>就可以原样复制一个<code>list</code><br>tuple也是一种list，唯一区别是tuple不可变。因此，tuple也可以用切片操作，只是操作的结果仍是tuple。<br>Python没有针对字符串的截取函数，只需要切片一个操作就可以完成，非常简单。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>切片利用的是<code>[(起始位置，如果是0可以被省略):(切片结束位置，如果是全部可以被省略):(截取数据的步长，如果不指定，连同前面的</code>:<code>可以被省略)]</code>。</p>
<h1 id="多维数组的切片"><a href="#多维数组的切片" class="headerlink" title="多维数组的切片"></a>多维数组的切片</h1><p>由于python不支持多维列表这一说（我们无法利用列表来模拟多维数组），因此我们得引入<code>numpy</code>进行转化。<br>也是前几个冒号组成范围，最后一个冒号是步长。如果省略则为1。</p>
<h1 id="引用链接"><a href="#引用链接" class="headerlink" title="引用链接"></a>引用链接</h1><p><a href="http://blog.csdn.net/lanchunhui/article/details/49493633" target="_blank" rel="external">Python 基础——range() 与 np.arange()</a><br><a href="http://old.sebug.net/paper/books/scipydoc/numpy_intro.html" target="_blank" rel="external">http://old.sebug.net/paper/books/scipydoc/numpy_intro.html</a><br><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431756919644a792ee4ead724ef7afab3f7f771b04f5000" target="_blank" rel="external">廖雪峰Python教程-切片</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;由于最近大都使用Python作为主要的开发语言，并且以后也将长期使用（用于编程科学计算相关的内容）等。决定还是好好学习一下python。&lt;br&gt;以下内容是学习&lt;a href=&quot;https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431756919644a792ee4ead724ef7afab3f7f771b04f5000&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;廖雪峰Python教程-切片&lt;/a&gt;的笔记梳理。&lt;/p&gt;
    
    </summary>
    
      <category term="网页开发" scheme="http://www.cvblogs.cn/categories/%E7%BD%91%E9%A1%B5%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Python" scheme="http://www.cvblogs.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>翻译：理解深度学习中的卷积操作</title>
    <link href="http://www.cvblogs.cn/2017/12/10/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/%E7%90%86%E8%A7%A3%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E5%8D%B7%E7%A7%AF%E6%93%8D%E4%BD%9C/"/>
    <id>http://www.cvblogs.cn/2017/12/10/理论学习/理解深度学习中的卷积操作/</id>
    <published>2017-12-09T17:18:18.000Z</published>
    <updated>2017-12-10T12:48:24.408Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>此文为译文，目的是让自己更好的理解卷积操作。原文地址：<a href="http://timdettmers.com/2015/03/26/convolution-deep-learning/" target="_blank" rel="external">Understanding Convolution in Deep Learning</a></p>
<p>非常fascinating的是作者关于卷积在卷积网络中的应用。之前从来没有想过，为啥卷积网络就卷积了呢？（不过似乎我一直也都是停留在对全连接网络的学习上= =）</p>
<a id="more"></a>
<h1 id="译文"><a href="#译文" class="headerlink" title="译文"></a>译文</h1><p>如今，卷积可能是深度学习中最重要的一个概念。卷积操作及卷积网络使深度学习在机器学习任务中表现靠前。但是，什么使得卷积操作如此强大呢？在这篇文章中我会解释卷积操作以及关联它的相关概念帮助你更完全的理解卷积。</p>
<p>虽然已有大量介绍卷积相关的深度学习的博文，但是我发现他们大都因为介绍了过多的不必要的数学细节反而导致令人费解。这篇博文虽然也会介绍一些数学细节，但是我会通过图片的形式展现关键的数学表达式，使其更直观易懂。第一部分是介绍一些通泛的卷积概念以及卷积网络。第二部分则是为深度学习研究人员和专家能够加强理解而准备的一些更高级的概念。</p>
<h1 id="什么是卷积？"><a href="#什么是卷积？" class="headerlink" title="什么是卷积？"></a>什么是卷积？</h1><p>整篇文章都是建立在去解答这个问题上，因此首先了解大致的方向是很有帮助的。那么，单纯的卷积说的是什么呢？</p>
<p>你可以想象卷积是混淆信息的方式。想象两个装满信息的桶被按照某种指定的规则被倒入一个桶里进行混合。每一个桶里的内容，都有它自己的关于如何混合其他桶中信息的指导方式。因此，卷积是一个按照指定步骤执行的混合信息的操作。</p>
<p>事实上，卷积和其他数学运算一样也可以被数学定义。尽管卷积操作本身十分的复杂，但是对于复杂的等式，它又可以简化表示。因此，为了简化表达，卷积操作被大量用在了物理学以及工程学上。在第二部分，经过一小段数学证明后。我们会关联和整合科学和深度学习的创意，得到更深层次的关于卷积的理解。但是，我们现在先暂时关注卷积在实际中的应用。</p>
<h1 id="我们如何对图片做卷积操作？"><a href="#我们如何对图片做卷积操作？" class="headerlink" title="我们如何对图片做卷积操作？"></a>我们如何对图片做卷积操作？</h1><p>当我们对图片做卷积时，我们是对两个维度做了卷积（即图片的宽和高方向）。我们混合两个桶中的内容：第一个桶是输入的图片（可以看作是三个像素矩阵组成，因为图像是由RGB三通道组成的；每个像素矩阵中元素的值：0～255）。第二个桶中是卷积核，一个独立的由浮点数组成的矩阵。（可以将它的大小以及模式看作是一个如何混合两个桶中信息的指导方式）。输出的结果在深度学习中被叫做特征图像(feature map)。每个通道都会产生一个特征图像。<br><img src="https://i1.wp.com/timdettmers.com/wp-content/uploads/2015/03/convolution.png" alt="用一个边缘算子与图像做卷积操作的过程"></p>
<p>现在，我们演示卷积是如何混合两份信息。一种方法是利用输入图像采样一个小块做卷积操作–我们用100X100的图像，以及3X3的核。因此，我们可以同时采样3X3个像素点（和核做点乘）。最终得到的是一个中心值。当采样完一个地方（3X3）就向一个方向移动一个像素点。循环往复。当所有的像素都被计算后操作才停止。下面的动图展示了卷积操作的一个过程。<br><img src="https://i2.wp.com/timdettmers.com/wp-content/uploads/2015/03/aa-convolution-02.gif" alt="目标图片一个像素点的计算过程"><br>如你所见，为了保证与原图像有同样的密度一致性，这里通常还有一个正则化的过程。</p>
<h1 id="为什么作用在图片的卷积操作在机器学习中如此有效？"><a href="#为什么作用在图片的卷积操作在机器学习中如此有效？" class="headerlink" title="为什么作用在图片的卷积操作在机器学习中如此有效？"></a>为什么作用在图片的卷积操作在机器学习中如此有效？</h1><p>在一张图像中有大量的我们不需要的冗余信息。一个很好的例子就是<code>Burda Bootcamp</code>（这是原文作者一个在快速原型生成的马拉松式的学生实验项目中的项目=  =）在一个项目，作者想要搭建一个用于时尚图片搜索深度自编码器：你上传一张关于时尚单品的照片，自编码器会找出与图中的单品包含的相关风格的图片。</p>
<p>现在，如果你想鉴别不同风格的衣服，衣服的颜色不会有什么帮助，类似的还有衣服的商标等。关键的要素是衣服的形状。通常，女士衬衫的形状是异于短袖，夹克或毛衣的。因此，我们需要过滤图像中不必要的信息。通过卷积操作我们可以很容易完成这个需求。</p>
<p>作者的同事Jannek Thomas用Sobel算子（它的定义与前面的那个那个边缘算子差不多）预处理了数据，得到了重要的边缘信息。这也是为什么卷积操作也叫做滤波。边缘信息的提取对于形状信息的获得非常有帮助。<br><img src="https://i1.wp.com/timdettmers.com/wp-content/uploads/2015/03/autoencoder_fashion_features_and_results.png" alt="上面是提取完边缘信息后的图像"></p>
<p>更深入的：很多的核产生很多的特征图像（map）。例如：锐化图像的，模糊图像的。</p>
<p>通过这个过程–输入图像，转化输入，得到转化后的图像将其引入算法中。被成为特征提取工程。特征工程非常困难，拥有的学习资料也非常有限。因此，很少有人能够熟练运用它。有效的特征提取在不同的任务中区别很大。因此，不存在通用的特征。同时，对于时间序列数据，特征几乎收效甚微。识别特征的有效性需要大量的经验。</p>
<p>因此，特征工程非常困难，你必须从零开始一点点去试探。但是，当我们关注图像本身，有什么方法可以自动的找到特征提取的核的吗？</p>
<h1 id="引入卷积网络"><a href="#引入卷积网络" class="headerlink" title="引入卷积网络"></a>引入卷积网络</h1><p>卷积网络就是干这个的。较于固定我们的核，我们指定一组参数然后让网络训练我们的核。当我们训练我们的卷积网络时，核会随着过程学习，过滤得到更有用的信息。这个过程是全自动的，也被叫做特征学习。特征学习自动得到一个任务的特征。我们所需要做的就是训练我们的网络，去找到一个与新的任务相关的filter。这就是为什么卷积网络如此强大的原因–不再为特征的提取而烦恼。</p>
<blockquote>
<p>数据编程的概念</p>
</blockquote>
<p>通常我们在一个卷积网络中，不会只学习一个核。我们同时学到一个组织（hierarchy）的多个核。例如：一个32X16X16的核应用在一张256X256的图像上会产生32个241X241的特征图像。（这是标准大小，实现的不同大小特跟着改变；image size - kernel size +1）。因此我们自动学习得到的32个新特征拥有与我们的任务相关的所有信息。这些特征又为接下来的核计算提供了输入。一旦我们学习完所有的核，我们就将其传入给一个全连接的网络（简单的网络，用作图像的分类。）。这就是卷积网络所有的应该知道的概念（池化的过程也很重要，但是它的内容也够写一篇博文了）。</p>
<h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>放弃了，第二部分还是自己看吧= =翻译的效率实在太低了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;此文为译文，目的是让自己更好的理解卷积操作。原文地址：&lt;a href=&quot;http://timdettmers.com/2015/03/26/convolution-deep-learning/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Understanding Convolution in Deep Learning&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;非常fascinating的是作者关于卷积在卷积网络中的应用。之前从来没有想过，为啥卷积网络就卷积了呢？（不过似乎我一直也都是停留在对全连接网络的学习上= =）&lt;/p&gt;
    
    </summary>
    
      <category term="深度学习" scheme="http://www.cvblogs.cn/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="数学基础" scheme="http://www.cvblogs.cn/tags/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>linux之ssh命令</title>
    <link href="http://www.cvblogs.cn/2017/12/08/%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/linux_ssh%E5%91%BD%E4%BB%A4/"/>
    <id>http://www.cvblogs.cn/2017/12/08/开发学习/linux_ssh命令/</id>
    <published>2017-12-08T12:12:12.000Z</published>
    <updated>2017-12-12T04:42:39.444Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天需要使用ssh的时候发现居然不好使了，原来是自己在电脑上用了lantern之后，ip被改了，不在一个局域网内，无法访问非公网ip。（主要是根本ping不同目的主机= =）<br>于是打算借着机会好好的梳理一下ssh命令。</p>
<a id="more"></a>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="http://blog.csdn.net/pipisorry/article/details/52269785" target="_blank" rel="external">ssh用法及命令</a></p>
<h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>为什么这篇文章的结束语这么靠前，是因为，我在看完大段的内容之后依旧无法弄清楚。如果我要将远端的8000端口映射到本地的8888端口我该用什么命令。感觉这样子陈列知识点真的很糟糕。还是应该以具体的应用来说比较好。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ssh -L 8888:localhost:8000 remote<span class="comment">#remote是远端主机名</span></div><div class="line">ssh -p 8888 localhost<span class="comment">#此时ssh登陆本机8888端口就相当于登陆了remote了，稍后可以一试：）</span></div></pre></td></tr></table></figure></p>
<h1 id="什么是SSH"><a href="#什么是SSH" class="headerlink" title="什么是SSH"></a>什么是SSH</h1><p>首先，需要明确的是：SSH是一种网络协议，用于计算机之间的加密登录。目前已经成为Linux系统的标准配置。</p>
<p>SSH只是一种协议，存在多种实现，既有商业实现，也有开源实现。本文针对的实现是OpenSSH，它是自由软件，应用非常广泛。这里只讨论SSH在Linux Shell中的用法。如果要在Windows系统中使用SSH，会用到另一种软件PuTTY。</p>
<blockquote>
<p>注解：SSH只是一种协议，而我们所用的SSH命令则是基于该工具封装的一种命令行工具（linux shell）。<br>PuTTY是一个实现这些协议的图形化工具（它支持的协议不止有SSH）</p>
</blockquote>
<h1 id="SSH原理"><a href="#SSH原理" class="headerlink" title="SSH原理"></a>SSH原理</h1><p>SSH之所以能够保证安全，原因在于它采用了公钥加密。整个过程是这样的：<br>（1）远程主机收到用户的登录请求，把自己的公钥发给用户。<br>（2）用户使用这个公钥，将登录密码加密后，发送回来。<br>（3）远程主机用自己的私钥，解密登录密码，如果密码正确，就同意用户登录。</p>
<blockquote>
<p>不像https协议，SSH协议的公钥是没有证书中心（CA）公证的，也就是说，都是自己签发的。</p>
</blockquote>
<h2 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h2><p>可以设想，如果攻击者插在用户与远程主机之间（比如在公共的wifi区域），用伪造的公钥，获取用户的登录密码。再用这个密码登录远程主机，那么SSH的安全机制就荡然无存了。这种风险就是著名的”中间人攻击”（Man-in-the-middle attack）</p>
<h1 id="SSH基本用法"><a href="#SSH基本用法" class="headerlink" title="SSH基本用法"></a>SSH基本用法</h1><h2 id="SSH远程登录"><a href="#SSH远程登录" class="headerlink" title="SSH远程登录"></a>SSH远程登录</h2><p>口令登录<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#假定你要以用户名user，登录远程主机host，只要一条简单命令就可以了。</span></div><div class="line">$ ssh user@host  如：ssh pika@192.168.0.111</div><div class="line"><span class="comment">#如果本地用户名与远程用户名一致，登录时可以省略用户名。</span></div><div class="line">$ ssh host</div><div class="line"><span class="comment">#SSH的默认端口是22，也就是说，你的登录请求会送进远程主机的22端口。使用p参数，可以修改这个端口</span></div><div class="line">$ ssh -p 2222 user@host</div></pre></td></tr></table></figure></p>
<h2 id="公钥登录"><a href="#公钥登录" class="headerlink" title="公钥登录"></a>公钥登录</h2><p>所谓”公钥登录”，原理很简单，就是用户将自己的公钥储存在远程主机上。登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录shell，不再要求密码。<br><strong>这种方法要求用户必须提供自己的公钥。如果没有现成的，可以直接用ssh-keygen生成一个</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ ssh-keygen</div><div class="line"><span class="comment"># 运行结束以后，在$HOME/.ssh/目录下，会新生成两个文件：id_rsa.pub和id_rsa。前者是你的公钥，后者是你的私钥。</span></div><div class="line"></div><div class="line"><span class="comment"># 这时再输入下面的命令，将公钥传送到远程主机host上面：</span></div><div class="line">$ ssh-copy-id user@host</div></pre></td></tr></table></figure></p>
<h2 id="使用ssh在远程后台不中断地跑程序"><a href="#使用ssh在远程后台不中断地跑程序" class="headerlink" title="使用ssh在远程后台不中断地跑程序"></a>使用ssh在远程后台不中断地跑程序</h2><p>使用nohup命令让程序在关闭窗口（切换SSH连接）的时候程序还能继续在后台运行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nohup python3 a.py &amp;</div></pre></td></tr></table></figure></p>
<h1 id="SSH远程操作"><a href="#SSH远程操作" class="headerlink" title="SSH远程操作"></a>SSH远程操作</h1><h2 id="SSH数据传输"><a href="#SSH数据传输" class="headerlink" title="SSH数据传输"></a>SSH数据传输</h2><p>SSH不仅可以用于远程主机登录，还可以直接在远程主机上执行操作。<br>SSH可以在用户和远程主机之间，建立命令和数据的传输通道，因此很多事情都可以通过SSH来完成。</p>
<h2 id="scp-跨机远程拷贝"><a href="#scp-跨机远程拷贝" class="headerlink" title="scp 跨机远程拷贝"></a>scp 跨机远程拷贝</h2><p>scp是secure copy的简写，用于在Linux下进行远程拷贝文件的命令，和它类似的命令有cp，不过cp只是在本机进行拷贝不能跨服务器，而且scp传输是加密的。可能会稍微影响一下速度。<br><strong>两台主机之间复制文件必需得同时有两台主机的复制执行帐号和操作权限</strong>。</p>
<blockquote>
<p>注解：建议使用scp进行远程copy</p>
</blockquote>
<h2 id="绑定本地端口"><a href="#绑定本地端口" class="headerlink" title="绑定本地端口"></a>绑定本地端口</h2><p>可以让那些不加密的网络连接，全部改走SSH连接，从而提高安全性。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#假定我们要让8080端口的数据，都通过SSH传向远程主机，命令就这样写：</span></div><div class="line">$ ssh -D 8080 user@host</div></pre></td></tr></table></figure></p>
<blockquote>
<p>SSH会建立一个socket，去监听本地的8080端口。一旦有数据传向那个端口，就自动把它转移到SSH连接上面，发往远程主机。<br>可以想象，如果8080端口原来是一个不加密端口，现在将变成一个加密端口。</p>
</blockquote>
<h2 id="本地端口转发"><a href="#本地端口转发" class="headerlink" title="本地端口转发"></a>本地端口转发</h2><p>有时，绑定本地端口还不够，还必须指定数据传送的目标主机，从而形成<strong>点对点的”端口转发”</strong>。<br>为了区别后文的”远程端口转发”，我们把这种情况称为”本地端口转发”（Local forwarding）</p>
<h2 id="远程端口转发"><a href="#远程端口转发" class="headerlink" title="远程端口转发"></a>远程端口转发</h2><p>既然”本地端口转发”是指绑定本地端口的转发，那么”远程端口转发”（remote forwarding）当然是指绑定远程端口的转发。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;今天需要使用ssh的时候发现居然不好使了，原来是自己在电脑上用了lantern之后，ip被改了，不在一个局域网内，无法访问非公网ip。（主要是根本ping不同目的主机= =）&lt;br&gt;于是打算借着机会好好的梳理一下ssh命令。&lt;/p&gt;
    
    </summary>
    
      <category term="网页开发" scheme="http://www.cvblogs.cn/categories/%E7%BD%91%E9%A1%B5%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Linux" scheme="http://www.cvblogs.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>metadata元数据</title>
    <link href="http://www.cvblogs.cn/2017/12/08/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/metadata%E5%85%83%E6%95%B0%E6%8D%AE/"/>
    <id>http://www.cvblogs.cn/2017/12/08/理论学习/metadata元数据/</id>
    <published>2017-12-08T11:00:26.000Z</published>
    <updated>2017-12-12T04:40:39.283Z</updated>
    
    <content type="html"><![CDATA[<h1 id="metadata-元数据"><a href="#metadata-元数据" class="headerlink" title="metadata 元数据"></a>metadata 元数据</h1><p>一直以来有一个困惑，为什么机器学习的数据集中经常会需要一个metadata的东西（也被叫做元数据）。实在是费解，于是今天忍不住百度了一下。算是解开了疑惑。<br>按照原文的意思，元数据应该被翻译做中间数据而不是元数据。这个翻译容易混淆视听。因此，元数据还有其它名称，中介数据，中继数据。</p>
<a id="more"></a>
<blockquote>
<p>注解：这里，我的直观感受是元数据相当于文件系统中的目录表。因为我们需要的数据太大了。如果只是一张表通过数据字典映射是表示不了的。因此将其再细分，也便于管理。（应该可以这么理解吧= =）这也就解释了为什么一些大的数据集都有一个metadata（是这样吧 = =）</p>
</blockquote>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="http://blog.csdn.net/l294265421/article/details/50539506" target="_blank" rel="external">通过metadata认识元数据</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;metadata-元数据&quot;&gt;&lt;a href=&quot;#metadata-元数据&quot; class=&quot;headerlink&quot; title=&quot;metadata 元数据&quot;&gt;&lt;/a&gt;metadata 元数据&lt;/h1&gt;&lt;p&gt;一直以来有一个困惑，为什么机器学习的数据集中经常会需要一个metadata的东西（也被叫做元数据）。实在是费解，于是今天忍不住百度了一下。算是解开了疑惑。&lt;br&gt;按照原文的意思，元数据应该被翻译做中间数据而不是元数据。这个翻译容易混淆视听。因此，元数据还有其它名称，中介数据，中继数据。&lt;/p&gt;
    
    </summary>
    
      <category term="图像处理" scheme="http://www.cvblogs.cn/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
    
      <category term="基础概念" scheme="http://www.cvblogs.cn/tags/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>Django之表单</title>
    <link href="http://www.cvblogs.cn/2017/12/08/%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/django_%E8%A1%A8%E5%8D%95/"/>
    <id>http://www.cvblogs.cn/2017/12/08/开发学习/django_表单/</id>
    <published>2017-12-08T10:15:18.000Z</published>
    <updated>2017-12-10T13:31:29.114Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>HTML表单是网站交互性的经典方式。有必要区别与表格Table。这两个，本质上有很大的差别。</p>
<a id="more"></a>
<blockquote>
<p>注解：<br>表格Table用于展示数据<br>表单Form则用于提交数据等</p>
</blockquote>
<h1 id="HTTP请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求"></a>HTTP请求</h1><p>HTTP协议以”请求－回复”的方式工作。客户发送请求时，<strong>可以在请求中附加数据</strong>。服务器通过解析请求，就可以获得客户传来的数据，并根据URL来提供特定的服务。</p>
<h2 id="GET-方法"><a href="#GET-方法" class="headerlink" title="GET 方法"></a>GET 方法</h2><p>创建一个 search.py 文件，用于接收用户的请求。记得一定要将自己定义的路由处理函数在<code>urls.py</code>中定义的正则路由对应起来。</p>
<blockquote>
<p>注解：此处将视图显示和请求处理分成两个函数处理。</p>
</blockquote>
<h2 id="POST-方法"><a href="#POST-方法" class="headerlink" title="POST 方法"></a>POST 方法</h2><p>提交数据时更常用POST方法。<br><strong>用一个URL和处理函数，同时显示视图和处理请求。</strong><br>注意：csrf 全称是 Cross Site Request Forgery。这是Django提供的防止伪装提交请求的功能。POST 方法提交的表格，必须有此标签。</p>
<h1 id="Request-对象"><a href="#Request-对象" class="headerlink" title="Request 对象"></a>Request 对象</h1><p><strong>每个<code>view</code> 函数的第一个参数是一个 <code>HttpRequest</code> 对象</strong><br>注意：不能使用语句if request.POST来判断是否使用HTTP POST方法；应该使用if request.method == “POST” 。</p>
<h1 id="QueryDict对象"><a href="#QueryDict对象" class="headerlink" title="QueryDict对象"></a>QueryDict对象</h1><p>在HttpRequest对象中, GET和POST属性是django.http.QueryDict类的实例。<br>QueryDict类似字典的自定义类，用来处理单键对应多值的情况。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;HTML表单是网站交互性的经典方式。有必要区别与表格Table。这两个，本质上有很大的差别。&lt;/p&gt;
    
    </summary>
    
      <category term="网页开发" scheme="http://www.cvblogs.cn/categories/%E7%BD%91%E9%A1%B5%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Django" scheme="http://www.cvblogs.cn/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>Django之数据库</title>
    <link href="http://www.cvblogs.cn/2017/12/08/%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/django%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://www.cvblogs.cn/2017/12/08/开发学习/django之数据库/</id>
    <published>2017-12-08T09:56:10.000Z</published>
    <updated>2017-12-10T13:20:47.385Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>关于在Django框架中如何使用数据库。</p>
<a id="more"></a>
<h1 id="数据库的使用"><a href="#数据库的使用" class="headerlink" title="数据库的使用"></a>数据库的使用</h1><h2 id="定义模型"><a href="#定义模型" class="headerlink" title="定义模型"></a>定义模型</h2><h3 id="创建-APP"><a href="#创建-APP" class="headerlink" title="创建 APP"></a>创建 APP</h3><p>Django规定，如果要使用模型，必须要创建一个app。修改对应App目录下的<code>models.py</code>文件。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># models.py</span></div><div class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</div><div class="line"> </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span><span class="params">(models.Model)</span>:</span></div><div class="line">    name = models.CharField(max_length=<span class="number">20</span>)</div></pre></td></tr></table></figure></p>
<blockquote>
<p>注解：类名代表了数据库表名，继承了<code>models.Model</code>。<br>类里面的字段代表数据表中的字段(name)<br>数据类型则由CharField（相当于varchar）、DateField（相当于datetime）<br>max_length 参数限定长度。</p>
</blockquote>
<h3 id="在命令行中运行"><a href="#在命令行中运行" class="headerlink" title="在命令行中运行"></a>在命令行中运行</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">python manage.py migrate   <span class="comment"># 创建表结构</span></div><div class="line">python manage.py makemigrations TestModel  <span class="comment"># 让 Django 知道我们在我们的模型有一些变更</span></div><div class="line">python manage.py migrate TestModel   <span class="comment"># 创建表结构</span></div></pre></td></tr></table></figure>
<p>表名组成结构为：<strong>应用名_类名</strong>（如：<code>TestModel_test</code>）。</p>
<p><strong> 注意：尽管我们没有在models给表设置主键，但是Django会自动添加一个id作为主键。</strong></p>
<h2 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h2><p>在 HelloWorld(所创建的App)目录中添加 testdb.py 文件（下面介绍），并修改 urls.py</p>
<blockquote>
<p>注解：此处只要在对应App目录下创建好操作数据库的文件，以及在urls.py中处理好对应的路由转发规则即可。并不强制要求一定是这样。但是路由的映射一定要对应上。</p>
</blockquote>
<h3 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h3><p>添加数据需要先创建对象，然后再执行 save 函数，相当于SQL中的<code>INSERT</code><br><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div><div class="line"> </div><div class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse    <span class="comment">#因为是处理客户端http请求，因此需要引入该模块</span></div><div class="line"> </div><div class="line"><span class="keyword">from</span> TestModel.models <span class="keyword">import</span> Test    <span class="comment">#该模块中定义了我们的表结构（模型），可以理解为是一个类（自定义的数据类型）</span></div><div class="line"> </div><div class="line"><span class="comment"># 数据库操作</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">testdb</span><span class="params">(request)</span>:</span>    <span class="comment">#此处对应urls.py中的路由处理函数，一定要对应上</span></div><div class="line">    test1 = Test(name=<span class="string">'runoob'</span>)    <span class="comment">#创建了一个实例对象</span></div><div class="line">    test1.save()    <span class="comment">#将实例对象保存（可以看作是SQL中的INSERT操作）</span></div><div class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">"&lt;p&gt;数据添加成功！&lt;/p&gt;"</span>)    <span class="comment">#如只是用HttpResponse则无需在参数中添加request。如果是render等则需要带上</span></div></pre></td></tr></table></figure></p>
<h3 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h3><p>通过objects这个模型管理器来进行完成对应的操作<br>all()获得所有数据行，相当于SQL中的SELECT * FROM<br>filter相当于SQL中的WHERE，可设置条件过滤结果<br>objects.get(id=1)获取单个对象<br>objects.order_by(‘name’)[0:2]限制返回的数据 相当于 SQL 中的 OFFSET 0 LIMIT 2;<br>objects.order_by(“id”)数据排序<br>上面的方法可以连锁使用</p>
<h3 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h3><p>修改数据可以使用 save() 或 update()</p>
<blockquote>
<p>save()和update都得针对已经有的数据进行操作</p>
</blockquote>
<h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><p>删除数据库中的对象只需调用该对象的delete()方法即可</p>
<h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>Django中的数据库操作还是挺简单的，但是封装感觉会是一个问题，单纯的利用框架提供的这个似乎解耦等不会很好，有待继续学习。</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="http://www.runoob.com/django/django-model.html" target="_blank" rel="external">http://www.runoob.com/django/django-model.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;关于在Django框架中如何使用数据库。&lt;/p&gt;
    
    </summary>
    
      <category term="网页开发" scheme="http://www.cvblogs.cn/categories/%E7%BD%91%E9%A1%B5%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Django" scheme="http://www.cvblogs.cn/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>python之数据结构</title>
    <link href="http://www.cvblogs.cn/2017/12/08/%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/python_python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://www.cvblogs.cn/2017/12/08/开发学习/python_python数据结构/</id>
    <published>2017-12-08T09:26:06.000Z</published>
    <updated>2017-12-12T04:41:50.627Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本章是关于python中基本数据结构知识的一些梳理。</p>
<a id="more"></a>
<h1 id="Python-列表-List"><a href="#Python-列表-List" class="headerlink" title="Python 列表(List)"></a>Python 列表(List)</h1><blockquote>
<p>可以这么说是，用<code>[</code>与<code>]</code>将元素圈起来- -</p>
</blockquote>
<p>序列中的每个元素都分配一个数字 - 它的位置，或索引，第一个索引是0，第二个索引是1，依此类推。<br>Python有6个序列的内置类型，但最常见的是列表和元组。<br>序列都可以进行的操作包括索引，切片，<strong>加</strong>，<strong>乘</strong>，<strong>检查成员</strong>。<br>Python已经内置确定序列的长度以及确定最大和最小的元素的方法。</p>
<p>列表是最常用的Python数据类型，它可以作为<strong>一个方括号内的逗号分隔值出现</strong>。<br>创建一个列表，只要把逗号分隔的不同的数据项使用方括号括起来即可。与字符串的索引一样，列表索引从0开始。列表可以进行截取、组合等。</p>
<h2 id="删除列表元素"><a href="#删除列表元素" class="headerlink" title="删除列表元素"></a>删除列表元素</h2><p><code>del</code>语句来删除列表的的元素。</p>
<h2 id="Python列表脚本操作符"><a href="#Python列表脚本操作符" class="headerlink" title="Python列表脚本操作符"></a>Python列表脚本操作符</h2><p>列表对 + 和 <em> 的操作符与字符串相似。+ 号用于组合列表，</em> 号用于重复列表。</p>
<h1 id="Python-元祖-Tuple"><a href="#Python-元祖-Tuple" class="headerlink" title="Python 元祖(Tuple)"></a>Python 元祖(Tuple)</h1><p><strong>元组与列表类似，不同之处在于元组的元素不能修改。</strong><br><strong>元组使用小括号，列表使用方括号。</strong><br>元组创建很简单，只需要在括号中添加元素，并使用逗号隔开即可。<br><strong>元组中只包含一个元素时，需要在元素后面添加逗号</strong><br>元组与字符串类似，下标索引从0开始，可以进行截取，组合等。<br>将列表转换为元组:<strong>tuple(seq)</strong></p>
<h1 id="Python-字典-Dictionary"><a href="#Python-字典-Dictionary" class="headerlink" title="Python 字典(Dictionary)"></a>Python 字典(Dictionary)</h1><p>字典是另一种可变容器模型，且可存储任意类型对象。<br>字典的每个键值(key=&gt;value)对用冒号(:)分割，每个对之间用逗号(,)分割，整个字典包括在花括号({})中。键必须是唯一的，但值则不必。键必须是不可变的，如字符串，数字或元组。</p>
<h2 id="删除字典元素"><a href="#删除字典元素" class="headerlink" title="删除字典元素"></a>删除字典元素</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">del</span> dict[<span class="string">'Name'</span>]; <span class="comment"># 删除键是'Name'的条目</span></div><div class="line">dict.clear();     <span class="comment"># 清空词典所有条目</span></div><div class="line"><span class="keyword">del</span> dict ;        <span class="comment"># 删除词典</span></div></pre></td></tr></table></figure>
<h2 id="字典键的特性"><a href="#字典键的特性" class="headerlink" title="字典键的特性"></a>字典键的特性</h2><p>字典值可以没有限制地取任何<code>python</code>对象，既可以是标准的对象，也可以是用户定义的，但键不行。</p>
<ol>
<li>不允许同一个键出现两次。创建时如果同一个键被赋值两次，后一个值会被记住。</li>
<li>键必须不可变，所以可以用数字，字符串或元组充当，所以用列表就不行。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本章是关于python中基本数据结构知识的一些梳理。&lt;/p&gt;
    
    </summary>
    
      <category term="网页开发" scheme="http://www.cvblogs.cn/categories/%E7%BD%91%E9%A1%B5%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Python" scheme="http://www.cvblogs.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>python之读取数据的方式</title>
    <link href="http://www.cvblogs.cn/2017/12/08/%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/python_python%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE%E7%9A%84%E6%96%B9%E5%BC%8F/"/>
    <id>http://www.cvblogs.cn/2017/12/08/开发学习/python_python读取数据的方式/</id>
    <published>2017-12-08T09:01:01.000Z</published>
    <updated>2017-12-12T04:42:05.586Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python读取数据的方式"><a href="#Python读取数据的方式" class="headerlink" title="Python读取数据的方式"></a>Python读取数据的方式</h1><p>在文本处理的过程中，将文件加载内存中是第一步，这就涉及到<strong>怎样将文件中的某一列映射到具体的变量的过程</strong>。<br>推荐两种优雅的方式来读取数据，都是先配置字段模式，然后按照模式读取，而模式则有字典模式和列表模式两种形式；</p>
<a id="more"></a>
<h2 id="读取文件，按照分隔符分割成字段数据列表"><a href="#读取文件，按照分隔符分割成字段数据列表" class="headerlink" title="读取文件，按照分隔符分割成字段数据列表"></a>读取文件，按照分隔符分割成字段<code>数据列表</code></h2><p>使用<code>yield</code>关键字，每次抛出单个行的分割数据，这样在调度程序中可以用<code>for fields in read_file_data(fpath)</code>的方式读取每一行。</p>
<h3 id="使用配置好的字典模式，装配读取的数据列表"><a href="#使用配置好的字典模式，装配读取的数据列表" class="headerlink" title="使用配置好的字典模式，装配读取的数据列表"></a>使用配置好的<code>字典模式</code>，装配读取的数据列表</h3><p>这种方法配置一个{“字段名”: 字段位置}的字典作为数据模式，然后按照该模式装配读取的列表数据，最后实现用字典的方式访问数据。</p>
<h3 id="使用配置好的列表模式，装配读取的数据列表"><a href="#使用配置好的列表模式，装配读取的数据列表" class="headerlink" title="使用配置好的列表模式，装配读取的数据列表"></a>使用配置好的<code>列表模式</code>，装配读取的数据列表</h3><p>如果需要读取文件所有列，或者前面的一些列，那么配置字典模式优点复杂，因为需要给每个字段配置索引位置，并且这些位置是从0开始完后数的，属于低级劳动，需要消灭。</p>
<h2 id="按列表模式读"><a href="#按列表模式读" class="headerlink" title="按列表模式读"></a>按<code>列表模式</code>读</h2><p>列表模式应命运而生，先将配置好的列表模式转换成字典模式，然后按字典加载就可以实现。<br>使用的时候，可以用列表的形式配置模式，不需要配置索引更加简洁</p>
<h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><blockquote>
<p>尚未理解透彻数据处理中的<code>字典模式</code>与<code>列表模式</code>。</p>
</blockquote>
<h1 id="引用链接"><a href="#引用链接" class="headerlink" title="引用链接"></a>引用链接</h1><p><a href="http://www.crazyant.net/1707.html" target="_blank" rel="external">Python使用list字段模式或者dict字段模式读取文件的方法</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python读取数据的方式&quot;&gt;&lt;a href=&quot;#Python读取数据的方式&quot; class=&quot;headerlink&quot; title=&quot;Python读取数据的方式&quot;&gt;&lt;/a&gt;Python读取数据的方式&lt;/h1&gt;&lt;p&gt;在文本处理的过程中，将文件加载内存中是第一步，这就涉及到&lt;strong&gt;怎样将文件中的某一列映射到具体的变量的过程&lt;/strong&gt;。&lt;br&gt;推荐两种优雅的方式来读取数据，都是先配置字段模式，然后按照模式读取，而模式则有字典模式和列表模式两种形式；&lt;/p&gt;
    
    </summary>
    
      <category term="网页开发" scheme="http://www.cvblogs.cn/categories/%E7%BD%91%E9%A1%B5%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Python" scheme="http://www.cvblogs.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>linux之软链接与硬链接</title>
    <link href="http://www.cvblogs.cn/2017/12/08/%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/linux_%E8%BD%AF%E9%93%BE%E6%8E%A5%E4%B8%8E%E7%A1%AC%E9%93%BE%E6%8E%A5/"/>
    <id>http://www.cvblogs.cn/2017/12/08/开发学习/linux_软链接与硬链接/</id>
    <published>2017-12-08T07:18:22.000Z</published>
    <updated>2017-12-10T12:56:53.806Z</updated>
    
    <content type="html"><![CDATA[<h1 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h1><p>称之为符号连接（Symbolic Link）。类似于Windows的快捷方式，在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。</p>
<a id="more"></a>
<blockquote>
<p>注解：此处说的一个文本文件包含另一文件的位置信息，可以将其看作指针。因此每次打开软链接的文件都会定位到源文件目录所在的位置。</p>
</blockquote>
<p>软链接的缺点在于：因为链接文件包含有原文件的路径信息，所以当原文件从一个目录下移到其他目录中，再访问链接文件，系统就找不到了，而硬链接就没有这个缺陷，你想怎么移就怎么移；还有它要系统分配额外的空间用于建立新的索引节点和保存原文件的路径。</p>
<h1 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h1><p>通过索引节点来进行连接。保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Index)。允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。<br>只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。</p>
<blockquote>
<p>注解：好比C++中，为一个内存区域创建了多个别名。</p>
</blockquote>
<!-- more -->
<h2 id="硬链接文件有两个限制"><a href="#硬链接文件有两个限制" class="headerlink" title="硬链接文件有两个限制"></a>硬链接文件有两个限制</h2><ol>
<li>不允许给目录创建硬链接；</li>
<li>只有在同一文件系统中的文件之间才能创建链接，而且只有超级用户才有建立硬链接权限。<blockquote>
<p>对硬链接文件进行读写和删除操作时候，结果和软链接相同。但如果我们删除硬链接文件的源文件，硬链接文件仍然存在，而且保留了愿有的内容。</p>
</blockquote>
</li>
</ol>
<p>软链接没有硬链接以上的两个限制，因而现在更为广泛使用，它具有更大的灵活性，甚至可以跨越不同机器、不同网络对文件进行链接。</p>
<h1 id="创建命令"><a href="#创建命令" class="headerlink" title="创建命令"></a>创建命令</h1><p><code>ln -s</code>创建软链接</p>
<p><code>ln</code>创建硬链接</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://www.cnblogs.com/kex1n/p/5193826.html" target="_blank" rel="external">linux 创建连接命令 ln -s 软链接</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;软链接&quot;&gt;&lt;a href=&quot;#软链接&quot; class=&quot;headerlink&quot; title=&quot;软链接&quot;&gt;&lt;/a&gt;软链接&lt;/h1&gt;&lt;p&gt;称之为符号连接（Symbolic Link）。类似于Windows的快捷方式，在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。&lt;/p&gt;
    
    </summary>
    
      <category term="网页开发" scheme="http://www.cvblogs.cn/categories/%E7%BD%91%E9%A1%B5%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Linux" scheme="http://www.cvblogs.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>python之编码规范笔记</title>
    <link href="http://www.cvblogs.cn/2017/12/08/%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/python_%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    <id>http://www.cvblogs.cn/2017/12/08/开发学习/python_编码规范/</id>
    <published>2017-12-08T05:21:01.000Z</published>
    <updated>2017-12-12T04:43:44.241Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>主要是python中基础结构及对应容易被我忘记的编码建议的笔记梳理。</p>
<a id="more"></a>
<h1 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h1><ol>
<li>模块：小写、可以有下划线</li>
<li>包：小写、无下划线</li>
<li>类：<code>CapWords</code>(驼峰式命名)</li>
<li>函数命名：小写，可以有下划线</li>
<li>常量命名：大写，可以有下划线</li>
<li>类的属性：小写，前缀下划线</li>
<li>类的方法第一个参数必须是<code>self</code>，静态方法第一个参数必须是<code>cls</code></li>
</ol>
<h1 id="编码建议"><a href="#编码建议" class="headerlink" title="编码建议"></a>编码建议</h1><ol>
<li>尽可能使用<code>‘is’</code>,<code>‘is not’</code>取代<code>‘==’</code>，比如<code>if x is not None</code> 要优于<code>if x</code>。</li>
<li>使用<code>isinstance()</code>比较对象的类型</li>
<li>使用<code>startswith()</code> and <code>endswith()</code>代替切片进行序列前缀或后缀的检查</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;主要是python中基础结构及对应容易被我忘记的编码建议的笔记梳理。&lt;/p&gt;
    
    </summary>
    
      <category term="网页开发" scheme="http://www.cvblogs.cn/categories/%E7%BD%91%E9%A1%B5%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Python" scheme="http://www.cvblogs.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>git利用https无法push解决方法</title>
    <link href="http://www.cvblogs.cn/2017/12/08/%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/git%E7%9A%84https%E6%97%A0%E6%B3%95push%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>http://www.cvblogs.cn/2017/12/08/开发学习/git的https无法push解决方法/</id>
    <published>2017-12-08T02:22:26.000Z</published>
    <updated>2017-12-12T04:44:27.656Z</updated>
    
    <content type="html"><![CDATA[<h4 id="错误信息：fatal-Unable-to-find-remote-helper-for-39-https-39"><a href="#错误信息：fatal-Unable-to-find-remote-helper-for-39-https-39" class="headerlink" title="错误信息：fatal: Unable to find remote helper for &#39;https&#39;"></a>错误信息：<code>fatal: Unable to find remote helper for &#39;https&#39;</code></h4><p>昨天想要提交代码的时候，死活无法<code>push</code>，稍晚的时候才想起来原来是自己太着急了，代码都没有<code>commit</code>，那么何谈<code>push</code>呢。</p>
<a id="more"></a>
<blockquote>
<p>切记本地与远端的区别。远端只需要将它看作是一个存储数据作备份的地方。真正的内容其实是需要在本地完成的。而<code>git</code>这个工具的本质就是，先<code>add</code>修改（如果是对已有文件作修改则只需要用<code>commit -am</code>提交修改信息。<code>git</code>会保存所有的提交版本记录。）</p>
</blockquote>
<p>另外，由于用<code>conda</code>进入了虚拟环境，导致<code>push</code>的时候依旧报错。报错信息是<code>fatal: Unable to find remote helper for &#39;https&#39;</code>。上网查找的时候说是我没有安装<code>curl</code>等（但是其实根据一个正常工作的<code>git config --list</code>信息对比，我的<code>git</code>及<code>curl</code>是可以正常用的）。</p>
<blockquote>
<p>最后，其实是因为我进入了<code>conda</code>的环境。退出来虚拟环境，就可以正常提交了。</p>
</blockquote>
<h4 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h4><p>还是环境变量的问题。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;错误信息：fatal-Unable-to-find-remote-helper-for-39-https-39&quot;&gt;&lt;a href=&quot;#错误信息：fatal-Unable-to-find-remote-helper-for-39-https-39&quot; class=&quot;headerlink&quot; title=&quot;错误信息：fatal: Unable to find remote helper for &amp;#39;https&amp;#39;&quot;&gt;&lt;/a&gt;错误信息：&lt;code&gt;fatal: Unable to find remote helper for &amp;#39;https&amp;#39;&lt;/code&gt;&lt;/h4&gt;&lt;p&gt;昨天想要提交代码的时候，死活无法&lt;code&gt;push&lt;/code&gt;，稍晚的时候才想起来原来是自己太着急了，代码都没有&lt;code&gt;commit&lt;/code&gt;，那么何谈&lt;code&gt;push&lt;/code&gt;呢。&lt;/p&gt;
    
    </summary>
    
      <category term="网页开发" scheme="http://www.cvblogs.cn/categories/%E7%BD%91%E9%A1%B5%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="测试" scheme="http://www.cvblogs.cn/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Django之基础概念学习</title>
    <link href="http://www.cvblogs.cn/2017/12/07/%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/django_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E5%AD%A6%E4%B9%A0/"/>
    <id>http://www.cvblogs.cn/2017/12/07/开发学习/django_基础概念学习/</id>
    <published>2017-12-07T04:47:10.000Z</published>
    <updated>2017-12-12T04:44:45.655Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近需要学习Django框架。笔记备忘。其实学习一个框架，莫过于自己动手从零开始搭建。亲身去体会这个框架。这样学习才能事半功倍。神奇的发现hexo的文件里不可以有那个跨站点的token标签= =</p>
<a id="more"></a>
<h1 id="引用链接"><a href="#引用链接" class="headerlink" title="引用链接"></a>引用链接</h1><p><a href="https://www.cnblogs.com/feixuelove1009/p/5823135.html" target="_blank" rel="external">https://www.cnblogs.com/feixuelove1009/p/5823135.html</a><br><a href="http://www.runoob.com/django/django-first-app.html" target="_blank" rel="external">http://www.runoob.com/django/django-first-app.html</a></p>
<h1 id="Web框架介绍"><a href="#Web框架介绍" class="headerlink" title="Web框架介绍"></a>Web框架介绍</h1><p><img src="http://images2015.cnblogs.com/blog/948404/201608/948404-20160830212049246-1153317231.jpg" alt="一般的web框架"><br>其它基于python的web框架，如tornado、flask、webpy都是在这个范围内进行增删裁剪的。例如tornado用的是自己的异步非阻塞“wsgi”，flask则只提供了最精简和基本的框架。Django则是直接使用了WSGI，并实现了大部分功能</p>
<h1 id="MVC-MTV介绍"><a href="#MVC-MTV介绍" class="headerlink" title="MVC/MTV介绍"></a>MVC/MTV介绍</h1><p>模型(model)：定义数据库相关的内容，一般放在models.py文件中。<br>视图(view)：定义HTML等静态网页文件相关，也就是那些html、css、js等前端的东西。<br>控制器(controller)：定义业务逻辑相关，就是你的主要代码。<br>MTV: 有些WEB框架觉得MVC的字面意思很别扭，就给它改了一下。view不再是HTML相关，而是主业务逻辑了，相当于控制器。html被放在Templates中，称作模板，于是MVC就变成了MTV。这其实就是一个文字游戏，和MVC本质上是一样的，换了个名字和叫法而已，换汤不换药。</p>
<h1 id="Django模型组织"><a href="#Django模型组织" class="headerlink" title="Django模型组织"></a>Django模型组织</h1><p><img src="http://images2015.cnblogs.com/blog/948404/201609/948404-20160903111840215-2065765780.jpg" alt="Django模型组织"></p>
<h2 id="我们学Django学的是什么？"><a href="#我们学Django学的是什么？" class="headerlink" title="我们学Django学的是什么？"></a>我们学Django学的是什么？</h2><ol>
<li><p>目录结构规范</p>
</li>
<li><p>urls路由方式</p>
</li>
<li><p>settings配置</p>
</li>
<li><p>ORM操作</p>
</li>
<li><p>模板渲染</p>
</li>
<li><p>其它</p>
</li>
</ol>
<h1 id="Django项目目录结构"><a href="#Django项目目录结构" class="headerlink" title="Django项目目录结构"></a>Django项目目录结构</h1><p><img src="./xiaogu_django项目结构.png" alt="xiaogu_django项目结构.png"><br><img src="http://images2015.cnblogs.com/blog/948404/201608/948404-20160830222155746-982749621.png" alt="目录结构"><br><strong>所有的APP共享项目资源</strong><br>在每个django项目中可以包含多个APP，相当于一个大型项目中的分系统、子模块、功能部件等等，相互之间比较独立，但也有联系。<br><strong>编写路由</strong><br>路由都在urls.py文件里，它将浏览器输入的url映射到相应的业务处理逻辑</p>
<blockquote>
<p>此处尚未理解透彻</p>
</blockquote>
<p><strong>业务处理逻辑</strong><br>业务处理逻辑都在views.py文件里。通过上面两个步骤，我们将urls.py中的index这个url指向了views.py里的index（）函数，它接收用户请求request，并返回一个“hello world”字符串。实际上这肯定不行，通常我们都是将html文件返回给用户。</p>
<p><strong>返回HTML文件</strong><br>写这么一个index.html文件,再修改一下views文件。为了让django知道我们的html文件在哪里，需要修改settings.py文件的相应内容。但默认情况下，它正好适用，你无需修改。</p>
<blockquote>
<p>注：这里有个小技巧，在多次频繁重启服务时，由于端口未释放的原因，容易启动不了服务，修改一下端口就OK了。</p>
</blockquote>
<p><strong>使用静态文件</strong><br>我们已经可以将html文件返还给用户了，但是还不够，前端三大块，html、css、js还有各种插件，它们齐全才是一个完整的页面。<br>在django中，一般将静态文件放在static目录中。你的CSS,JS和各种插件都可以放置在这个目录里。为了让django找到这个目录，依然需要对settings进行配置。<br>同样，在index.html文件中，可以引入js文件了。</p>
<p><strong>接收用户发送的数据</strong><br>我们将一个要素齐全的html文件返还给了用户浏览器。但这还不够，因为web服务器和用户之间没有动态交互。</p>
<p>下面我们设计一个表单，让用户输入用户名和密码，提交给index这个url，服务器将接收到这些数据。<br><strong>注意：跨站保护机制</strong><br>django有一个csrf跨站请求保护机制，我们暂时在settings文件中将它关闭，或者在form表单里添加一个标签。</p>
<p><strong>返回动态页面</strong><br>我们收到了用户的数据，但返回给用户的依然是个静态页面，通常我们会根据用户的数据，进行处理后在返回给用户。</p>
<p>这时候，django采用自己的模板语言，类似jinja2，根据提供的数据，替换掉html中的相应部分，详细语法入门后再深入学习</p>
<p><strong>使用数据库</strong><br>流程走到这里，django的MTV框架基本已经浮出水面了，只剩下最后的数据库部分了。<br>django通过自带的ORM框架操作数据库，并且自带轻量级的sqlite3数据库。</p>
<ol>
<li>在settings.py里注册你的app(不注册它，你的数据库就不知道该给哪个app创建表)</li>
<li>然后我们在settings中，配置数据库相关的参数，如果使用自带的sqlite，不需要修改。</li>
<li>再编辑models.py文件，也就是MTV中的M。</li>
<li><p>接下来要在pycharm的teminal中通过命令创建数据库的表</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">python manage.py makemigrations</div><div class="line">python manage.py migrate</div></pre></td></tr></table></figure>
</li>
<li><p>修改views.py中的业务逻辑</p>
</li>
<li>重启web服务后，刷新浏览器页面，之后和用户交互的数据都能保存到数据库中。任何时候都可以从数据库中读取数据，展示到页面上。</li>
</ol>
<h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>关于学习方法的建议：学习任何东西，不要直接扎入细节，应该先了解它的外围知识，看看它的整体架构，再学习它的基本内容，然后才是深入学习，打磨技巧！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近需要学习Django框架。笔记备忘。其实学习一个框架，莫过于自己动手从零开始搭建。亲身去体会这个框架。这样学习才能事半功倍。神奇的发现hexo的文件里不可以有那个跨站点的token标签= =&lt;/p&gt;
    
    </summary>
    
      <category term="网页开发" scheme="http://www.cvblogs.cn/categories/%E7%BD%91%E9%A1%B5%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Django" scheme="http://www.cvblogs.cn/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>深度学习框架</title>
    <link href="http://www.cvblogs.cn/2017/12/05/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/"/>
    <id>http://www.cvblogs.cn/2017/12/05/理论学习/深度学习框架/</id>
    <published>2017-12-05T02:57:10.000Z</published>
    <updated>2017-12-10T12:55:52.794Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PyTorch"><a href="#PyTorch" class="headerlink" title="PyTorch"></a>PyTorch</h1><p><code>PyTorch</code>准备数据有很多灵活的方式，在最后能够将数据转为<code>Numpy</code>数组即可，通过<code>Numpy</code>数据可以转化为<code>PyTorch</code>所需的<code>Tensor</code>。</p>
<ul>
<li>对于图像数据，可以直接通过opencv，Pillow等做处理；</li>
<li>语音数据可以通过scipy和librosa来处理成numpy；</li>
<li>文本数据可以通过CNTK之类的自然语言处理库处理成numpy数组。<a id="more"></a>
<h1 id="SKImage"><a href="#SKImage" class="headerlink" title="SKImage"></a>SKImage</h1>| 子模块名称        | 主要实现功能                           |<br>| ———— | ——————————– |<br>| io           | 读取、保存和显示图片或视频                    |<br>| data         | 提供一些测试图片和样本数据                    |<br>| color        | 颜色空间变换                           |<br>| filters      | 图像增强、边缘检测、排序滤波器、自动阈值等            |<br>| draw         | 操作于numpy数组上的基本图形绘制，包括线条、矩形、圆和文本等 |<br>| transform    | 几何变换或其它变换，如旋转、拉伸和拉东变换等           |<br>| morphology   | 形态学操作，如开闭运算、骨架提取等                |<br>| exposure     | 图片强度调整，如亮度调整、直方图均衡等              |<br>| feature      | 特征检测与提取等                         |<br>| measure      | 图像属性的测量，如相似性或等高线等                |<br>| segmentation | 图像分割                             |<br>| restoration  | 图像恢复                             |<br>| util         | 通用函数                             |</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;PyTorch&quot;&gt;&lt;a href=&quot;#PyTorch&quot; class=&quot;headerlink&quot; title=&quot;PyTorch&quot;&gt;&lt;/a&gt;PyTorch&lt;/h1&gt;&lt;p&gt;&lt;code&gt;PyTorch&lt;/code&gt;准备数据有很多灵活的方式，在最后能够将数据转为&lt;code&gt;Numpy&lt;/code&gt;数组即可，通过&lt;code&gt;Numpy&lt;/code&gt;数据可以转化为&lt;code&gt;PyTorch&lt;/code&gt;所需的&lt;code&gt;Tensor&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于图像数据，可以直接通过opencv，Pillow等做处理；&lt;/li&gt;
&lt;li&gt;语音数据可以通过scipy和librosa来处理成numpy；&lt;/li&gt;
&lt;li&gt;文本数据可以通过CNTK之类的自然语言处理库处理成numpy数组。
    
    </summary>
    
      <category term="深度学习" scheme="http://www.cvblogs.cn/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="基础概念" scheme="http://www.cvblogs.cn/tags/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>计算架构之CPU与GPU</title>
    <link href="http://www.cvblogs.cn/2017/11/29/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9E%B6%E6%9E%84%E4%B9%8BCPU%E4%B8%8EGPU/"/>
    <id>http://www.cvblogs.cn/2017/11/29/理论学习/计算架构之CPU与GPU/</id>
    <published>2017-11-29T09:38:10.000Z</published>
    <updated>2017-12-10T13:12:50.244Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>日益复杂的3D图形图像时就会常常出现显卡等待CPU数据的情况</p>
<a id="more"></a>
<h1 id="CUDA介绍"><a href="#CUDA介绍" class="headerlink" title="CUDA介绍"></a>CUDA介绍</h1><p>CUDA是计算统一设备构架（Compute Unified Device Architecture）的缩写。<br>CUDA和GPU之间的关系十分重要。<br>CUDA在编程基础上实现GPU的性能。<br>CUDA：软件<br>GPU：硬件</p>
<h1 id="发展历程"><a href="#发展历程" class="headerlink" title="发展历程"></a>发展历程</h1><p>GPGPU-&gt;CUDA-&gt;GPU</p>
<h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>CUDA只是一种并行计算架构，相关的概念还有OpenCL、OpenMP等</p>
<h1 id="SSL-Semi-Supervised-Learning"><a href="#SSL-Semi-Supervised-Learning" class="headerlink" title="SSL:Semi-Supervised Learning"></a>SSL:Semi-Supervised Learning</h1><ol>
<li>期望最大算法(Expectation Maximum，EM)</li>
<li>高斯混合模型(Gaussian Mixture Model，GMM)</li>
<li>最小割法(Mincut):首次将图论应用于解决SSL问题</li>
<li>调和函数法(Harmonic Function)将预测函数从离散形式扩展到连续形式</li>
<li>流形正则化法(Manifold Regularization)将流形学习的思想用于SSL场景</li>
<li>用于聚类的半监督距离度量学习方法，学习一种距离度量。</li>
<li>将EM和朴素贝叶斯结合，通过引入加权系数动态调整无类标签的样例的影响提高了分类准确度，建立每类中具有多个混合部分的模型，使贝叶斯偏差减小。</li>
<li>协同训练改进算法，不需要充分冗余的视图，而利用两个不同类型的分类器来完成学习</li>
<li>同时解决有类标签样本稀疏和具有附加无类标签样例成对约束的问题</li>
</ol>
<h1 id="三个常用基本假设"><a href="#三个常用基本假设" class="headerlink" title="三个常用基本假设"></a>三个常用基本假设</h1><p>基于一个事实：未标记样本虽未直接包含标记信息，但若它们与有标记信息样本是从同样的数据源独立同分布采样而来，则它们所包含的关于数据分布的信息对建立模型是有帮助的。<br>利用好未标记样本来提升模型泛化能力，就是半监督学习研究的重点。<br>在半监督学习中有三个常用的基本假设来建立预测样例和学习目标之间的关系：<br>（1）平滑假设(Smoothness Assumption)：位于稠密数据区域的两个距离很近的样例的类标签相似，也就是说，当两个样例被稠密数据区域中的边连接时，它们在很大的概率下有相同的类标签；相反地，当两个样例被稀疏数据区域分开时，它们的类标签趋于不同。<br>（2）聚类假设(Cluster Assumption)：当两个样例位于同一聚类簇时，它们在很大的概率下有相同的类标签。这个假设的等价定义为低密度分离假设(Low Sensity Separation Assumption)，即分类决策边界应该穿过稀疏数据区域，而避免将稠密数据区域的样例分到决策边界两侧。<br>（3）流形假设(Manifold Assumption)：将高维数据嵌入到低维流形中，当两个样例位于低维流形中的一个小局部邻域内时，它们具有相似的类标签。</p>
<h1 id="四大类学习场景"><a href="#四大类学习场景" class="headerlink" title="四大类学习场景"></a>四大类学习场景</h1><p>半监督学习可进一步划分为纯(pure)半监督学习和直推学习（transductive learning）：纯半监督学习假定训练数据中的未标记样本并非待预测数据；而直推学习假定学习过程中所考虑的未标记样本恰是待预测数据，学习的目的就是在未标记样本上获得最优泛化性能。<br>纯半监督学习是基于开放世界的假设，希望学得的模型能适用于训练过程中未观察到的数据；而直推学习是基于封闭世界假设，仅试图对学习过程中观察到的未标记数据进行预测。<br>从不同的学习场景看，SSL可分为四大类：</p>
<h2 id="半监督分类"><a href="#半监督分类" class="headerlink" title="半监督分类"></a>半监督分类</h2><p>半监督分类(Semi-Supervised Classification)：是在无类标签的样例的帮助下训练有类标签的样本，获得比只用有类标签的样本训练得到的分类器性能更优的分类器，弥补有类标签的样本不足的缺陷，其中类标签yi取<strong>有限离散值</strong>。</p>
<h2 id="半监督回归"><a href="#半监督回归" class="headerlink" title="半监督回归"></a>半监督回归</h2><p>半监督回归(Semi-Supervised Regression)：在无输出的输入的帮助下训练有输出的输入，获得比只用有输出的输入训练得到的回归器性能更好的回归器，其中输出yi取<strong>连续值</strong>；</p>
<h2 id="半监督聚类"><a href="#半监督聚类" class="headerlink" title="半监督聚类"></a>半监督聚类</h2><p>半监督聚类(Semi-Supervised Clustering)：在有类标签的样本的信息帮助下获得比只用无类标签的样例得到的结果更好的簇，提高聚类方法的精度；</p>
<h2 id="半监督降维"><a href="#半监督降维" class="headerlink" title="半监督降维"></a>半监督降维</h2><p>半监督降维(Semi-Supervised Dimensionality Reduction)：在有类标签的样本的信息帮助下找到高维输入数据的低维结构，同时保持原始高维数据和成对约束(Pair-Wise Constraints)的结构不变，即在高维空间中满足正约束(Must-Link Constraints)的样例在低维空间中相距很近，在高维空间中满足负约束(Cannot-Link Constraints)的样例在低维空间中距离很远。</p>
<h1 id="未来的研究方向包括以下一些内容"><a href="#未来的研究方向包括以下一些内容" class="headerlink" title="未来的研究方向包括以下一些内容"></a>未来的研究方向包括以下一些内容</h1><h3 id="理论分析"><a href="#理论分析" class="headerlink" title="理论分析"></a>理论分析</h3><h3 id="抗干扰性与可靠性"><a href="#抗干扰性与可靠性" class="headerlink" title="抗干扰性与可靠性"></a>抗干扰性与可靠性</h3><h3 id="训练样例与参数的选取"><a href="#训练样例与参数的选取" class="headerlink" title="训练样例与参数的选取"></a>训练样例与参数的选取</h3><h3 id="优化求解"><a href="#优化求解" class="headerlink" title="优化求解"></a>优化求解</h3><p>从各种SSL算法的实现过程可以看出，SSL问题大多为非凸、非平滑问题，或整数规划和组合优化问题，存在多个局部最优解，例如求解SSL产生式方法目标函数的EM算法只能得到局部极大值目前主要采用各种放松方法把目标函数近似转化为凸或连续最优化问题，不易得到全局最优解，算法的时空复杂性很高，问题的求解依赖于最优化理论的突破，未来需要研究新的算法求解全局最优解。</p>
<h3 id="研究拓展"><a href="#研究拓展" class="headerlink" title="研究拓展"></a>研究拓展</h3><p>SSL从产生以来，主要用于实验室中处理人工合成数据，未来的研究一方而需要讨论SSL可以显著提高哪些学习任务的性能，拓展SSL在现实领域的实际应用，另一方而需要制定出一个统一的令人信服的SSL方法的使用规程。此外，目前有许多的半监督分类方法，而对半监督回归问题的研究比较有限。未来有待继续研究半监督分类和半监督回归之间的关系，并提出其他半监督回归方法。</p>
<h1 id="Active-Learning-主动学习"><a href="#Active-Learning-主动学习" class="headerlink" title="Active Learning:主动学习"></a>Active Learning:主动学习</h1><p>主动学习就是要引入专家知识，通过与外部交互来将部分未标记样本转变为有标记样本。如果不通过外部标记，还可以利用未标记样本，就是半监督学习的研发范围</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;日益复杂的3D图形图像时就会常常出现显卡等待CPU数据的情况&lt;/p&gt;
    
    </summary>
    
      <category term="深度学习" scheme="http://www.cvblogs.cn/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="基础概念" scheme="http://www.cvblogs.cn/tags/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>web开发之内存泄漏</title>
    <link href="http://www.cvblogs.cn/2017/11/12/%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/web%E5%BC%80%E5%8F%91_%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    <id>http://www.cvblogs.cn/2017/11/12/开发学习/web开发_内存泄漏/</id>
    <published>2017-11-12T14:31:10.000Z</published>
    <updated>2017-12-12T04:45:36.658Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>以下文章内容大都摘自<a href="http://www.ruanyifeng.com/blog/2017/04/memory-leak.html" target="_blank" rel="external">阮一峰的网络博客JavaScript 内存泄漏教程篇</a>,仅作个人学习笔记备记。<br>本来不想记的，因为对于只是在本地写<code>hello world</code>的我来说，内存管理似乎从来不是一件必要的事情。<br>但是，突然想到，内存的管理对于部署在服务器上的或者说生产环境中的应用是多么的重要。<br>想象一下，要是一个需要7/24运行的web应用内存泄漏了：）简直就是一场灾难。服务器怠机则无法提供服务。</p>
<a id="more"></a>
<h1 id="什么是内存泄漏"><a href="#什么是内存泄漏" class="headerlink" title="什么是内存泄漏"></a>什么是内存泄漏</h1><p>对于持续运行的服务进程（daemon），必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。<br>不再用到的内存，没有及时释放，就叫做内存泄漏（memory leak）。<br>有些语言（比如 C 语言）必须手动释放内存，程序员负责内存管理。这很麻烦，所以大多数语言提供自动内存管理，减轻程序员的负担，这被称为”垃圾回收机制”（garbage collector）。</p>
<h1 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h1><p>最常使用的方法叫做”引用计数”（<code>reference counting</code>）：语言引擎有一张”引用表”，保存了内存里面所有的资源（通常是各种值）的引用次数。如果一个值的引用次数是0，就表示这个值不再用到了，因此可以将这块内存释放。<br>但是，并不是说有了垃圾回收机制，程序员就轻松了。你还是需要关注内存占用：那些很占空间的值，一旦不再用到，你必须检查是否还存在对它们的引用。如果是的话，就必须手动解除引用。</p>
<h1 id="内存泄漏的识别方法"><a href="#内存泄漏的识别方法" class="headerlink" title="内存泄漏的识别方法"></a>内存泄漏的识别方法</h1><p>经验法则是，如果连续<code>五次垃圾回收</code>之后，内存占用一次比一次大，就有内存泄漏。这就要求<code>实时查看内存占用</code>。</p>
<h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><p>Chrome 浏览器查看内存占用，按照以下步骤操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1. 打开开发者工具，选择 Timeline 面板</div><div class="line">2. 在顶部的Capture字段里面勾选 Memory</div><div class="line">3. 点击左上角的录制按钮。</div><div class="line">4. 在页面上进行各种操作，模拟用户的使用情况。</div><div class="line">5. 一段时间后，点击对话框的 stop 按钮，面板上就会显示这段时间的内存占用情况。</div></pre></td></tr></table></figure></p>
<p>如果内存占用基本平稳，接近水平，就说明不存在内存泄漏。<br>反之，就是内存泄漏了。</p>
<h2 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h2><p>命令行可以使用<code>Node</code> 提供的<code>process.memoryUsage</code>方法。<br><code>process.memoryUsage</code>返回一个<code>对象</code>，包含了 <code>Node</code>进程的内存占用信息。该对象包含<code>四个字段</code>，单位是<code>字节</code>。判断内存泄漏，以<code>heapUsed字段</code>为准。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">rss（resident set size）：所有内存占用，包括指令区和堆栈。</div><div class="line">heapTotal：&quot;堆&quot;占用的内存，包括用到的和没用到的。</div><div class="line">heapUsed：用到的堆的部分。</div><div class="line">external： V8 引擎内部的 C++ 对象占用的内存。</div></pre></td></tr></table></figure></p>
<h1 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h1><p>ES6 考虑到了这一点，推出了两种新的数据结构：<code>WeakSet</code> 和 <code>WeakMap</code>。它们对于值的引用都是不计入垃圾回收机制的，所以名字里面才会有一个”Weak”，表示这是弱引用。</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="http://www.ruanyifeng.com/blog/2017/04/memory-leak.html" target="_blank" rel="external">JavaScript 内存泄漏教程</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;以下文章内容大都摘自&lt;a href=&quot;http://www.ruanyifeng.com/blog/2017/04/memory-leak.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;阮一峰的网络博客JavaScript 内存泄漏教程篇&lt;/a&gt;,仅作个人学习笔记备记。&lt;br&gt;本来不想记的，因为对于只是在本地写&lt;code&gt;hello world&lt;/code&gt;的我来说，内存管理似乎从来不是一件必要的事情。&lt;br&gt;但是，突然想到，内存的管理对于部署在服务器上的或者说生产环境中的应用是多么的重要。&lt;br&gt;想象一下，要是一个需要7/24运行的web应用内存泄漏了：）简直就是一场灾难。服务器怠机则无法提供服务。&lt;/p&gt;
    
    </summary>
    
      <category term="网页开发" scheme="http://www.cvblogs.cn/categories/%E7%BD%91%E9%A1%B5%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Node.js" scheme="http://www.cvblogs.cn/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>web开发之LiveServer使用</title>
    <link href="http://www.cvblogs.cn/2017/11/12/%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/web%E5%BC%80%E5%8F%91_LiveServer%E4%BD%BF%E7%94%A8/"/>
    <id>http://www.cvblogs.cn/2017/11/12/开发学习/web开发_LiveServer使用/</id>
    <published>2017-11-12T14:15:10.000Z</published>
    <updated>2017-12-10T13:11:05.104Z</updated>
    
    <content type="html"><![CDATA[<h1 id="live-server模块的作用"><a href="#live-server模块的作用" class="headerlink" title="live-server模块的作用"></a>live-server模块的作用</h1><ol>
<li>实现热插拔<code>hot socketing</code>(修改文件之后，浏览器能够自动刷新)</li>
<li>当服务启动时，自动打开所在的项目。(实现<code>opener</code>的功能)</li>
<li>快速搭建临时的web服务。（实现<code>http-server</code>的功能）<a id="more"></a>
我们主要使用1与2，3用express或者其他web框架。<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1>可以直接使用全局安装的方法<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -g live-server</div></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>在<code>package.json</code>的<code>script</code>下添加一个<code>server</code>字段的<code>npm 脚本</code>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="string">"scripts"</span>: &#123;</div><div class="line">  <span class="string">"server"</span>: <span class="string">"live-server ./ --port=9090"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用<code>npm run server</code>执行。等待一会之后，浏览器会自动打开。<br>这样当你修改本地任何文件，浏览器都会自动立即同步（在内存层面，如果你想要发布代码，还是需要再次编译，否则修改之后的一些代码不会被改变！）。</p>
<h1 id="继续学习"><a href="#继续学习" class="headerlink" title="继续学习"></a>继续学习</h1><p><a href="https://www.npmjs.com/package/live-server" target="_blank" rel="external">官方链接https://www.npmjs.com/package/live-server</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;live-server模块的作用&quot;&gt;&lt;a href=&quot;#live-server模块的作用&quot; class=&quot;headerlink&quot; title=&quot;live-server模块的作用&quot;&gt;&lt;/a&gt;live-server模块的作用&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;实现热插拔&lt;code&gt;hot socketing&lt;/code&gt;(修改文件之后，浏览器能够自动刷新)&lt;/li&gt;
&lt;li&gt;当服务启动时，自动打开所在的项目。(实现&lt;code&gt;opener&lt;/code&gt;的功能)&lt;/li&gt;
&lt;li&gt;快速搭建临时的web服务。（实现&lt;code&gt;http-server&lt;/code&gt;的功能）
    
    </summary>
    
      <category term="网页开发" scheme="http://www.cvblogs.cn/categories/%E7%BD%91%E9%A1%B5%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Node.js" scheme="http://www.cvblogs.cn/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>web开发之性能分析火焰图</title>
    <link href="http://www.cvblogs.cn/2017/11/12/%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/web%E5%BC%80%E5%8F%91_%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E7%81%AB%E7%84%B0%E5%9B%BE/"/>
    <id>http://www.cvblogs.cn/2017/11/12/开发学习/web开发_性能分析火焰图/</id>
    <published>2017-11-12T14:05:10.000Z</published>
    <updated>2017-12-12T04:45:52.592Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>以下内容基本摘自<a href="http://www.ruanyifeng.com/blog/2017/09/flame-graph.html" target="_blank" rel="external">阮一峰的网络博客-如何读懂火焰图篇</a>，只做个人学习笔记用。</p>
<a id="more"></a>
<h1 id="perf命令"><a href="#perf命令" class="headerlink" title="perf命令"></a><code>perf</code>命令</h1><p>Linux 系统原生提供的性能分析工具，会返回 CPU 正在执行的函数名以及调用栈（stack）。<br>通常，它的执行频率是 99Hz（每秒99次），如果99次都返回同一个函数名，那就说明 CPU 这一秒钟都在执行同一个函数，可能存在性能问题。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo perf record -F 99 -p 13204 -g -- sleep 30</div></pre></td></tr></table></figure></p>
<p>上面的代码中，<code>perf record</code>表示记录，<code>-F 99</code>表示每秒99次，<code>-p 13204</code>是进程号，即对哪个进程进行分析，<code>-g</code>表示记录调用栈，<code>sleep 30</code>则是持续30秒。<br>运行后会产生一个庞大的文本文件。如果一台服务器有16个 CPU，每秒抽样99次，持续30秒，就得到 47,520 个调用栈，长达几十万甚至上百万行。<br>为了便于阅读，<code>perf record</code>命令可以统计每个调用栈出现的百分比，然后从高到低排列。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo perf report -n --stdio</div></pre></td></tr></table></figure></p>
<p>由于是文本文件极其不易阅读所以才有了火焰图。</p>
<h1 id="火焰图"><a href="#火焰图" class="headerlink" title="火焰图"></a>火焰图</h1><p>火焰图是基于 <code>perf</code> 结果产生的 SVG 图片，用来展示 CPU 的调用栈。<br><code>y 轴</code>表示调用栈，每一层都是一个函数。调用栈越深，火焰就越高，顶部就是正在执行的函数，下方都是它的父函数。<br><code>x 轴</code>表示抽样数，如果一个函数在 x 轴占据的宽度越宽，就表示它被抽到的次数多，即执行的时间长。<br><strong>注意，x 轴不代表时间，而是所有的调用栈合并后，按字母顺序排列的。</strong></p>
<p><strong>火焰图就是看顶层的哪个函数占据的宽度最大。只要有”平顶”（plateaus），就表示该函数可能存在性能问题。</strong></p>
<h1 id="Node-应用的火焰图"><a href="#Node-应用的火焰图" class="headerlink" title="Node 应用的火焰图"></a><code>Node 应用</code>的火焰图</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perf record -F 99 -p `pgrep -n node` -g -- sleep 30</div></pre></td></tr></table></figure>
<p><a href="http://www.brendangregg.com/blog/2014-09-17/node-flame-graphs-on-linux.html" target="_blank" rel="external">具体的操作过程参考此教程</a></p>
<h1 id="浏览器的火焰图"><a href="#浏览器的火焰图" class="headerlink" title="浏览器的火焰图"></a>浏览器的火焰图</h1><p>Chrome 浏览器可以生成页面脚本的火焰图，用来进行 CPU 分析。<br>打开开发者工具，切换到 <code>Performance 面板</code>。然后，点击<code>&quot;录制&quot;按钮</code>，开始记录数据。这时，可以在页面进行各种操作，然后<code>停止&quot;录制&quot;</code>。<br>浏览器的火焰图与标准火焰图有两点差异：</p>
<ol>
<li>它是倒置的（即调用栈最顶端的函数在最下方）；</li>
<li>x 轴是时间轴，而不是抽样次数。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;以下内容基本摘自&lt;a href=&quot;http://www.ruanyifeng.com/blog/2017/09/flame-graph.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;阮一峰的网络博客-如何读懂火焰图篇&lt;/a&gt;，只做个人学习笔记用。&lt;/p&gt;
    
    </summary>
    
      <category term="网页开发" scheme="http://www.cvblogs.cn/categories/%E7%BD%91%E9%A1%B5%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Node.js" scheme="http://www.cvblogs.cn/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>错误修改profile文件引起的重复登录问题解决方法</title>
    <link href="http://www.cvblogs.cn/2017/11/10/%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/%E9%94%99%E8%AF%AF%E4%BF%AE%E6%94%B9profile%E6%96%87%E4%BB%B6%E5%BC%95%E8%B5%B7%E7%9A%84%E9%87%8D%E5%A4%8D%E7%99%BB%E5%BD%95%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>http://www.cvblogs.cn/2017/11/10/开发学习/错误修改profile文件引起的重复登录问题解决方法/</id>
    <published>2017-11-10T14:15:26.000Z</published>
    <updated>2017-12-12T04:46:01.357Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天为了安装<code>go</code>错误修改了<code>/etc/profile</code>文件，导致<code>reboot</code>的时候一直循环登录。最终通过搜索解决了问题。这里记录一下。</p>
<a id="more"></a>
<h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>整个问题的关键是利用超级管理员权限进行修改前面被我修改错的的<code>etc/profile</code>文件。但是我的用户是普通用户根本就切换不了。<code>su</code>命令是报一堆错误。正确的做法如下：</p>
<ol>
<li><code>alt+ctl+shft+f1-6</code>进入<code>tty</code>界面</li>
<li>用普通用户账号登录(我的是普通用户，如果是<code>root</code>账号则直接进入步骤4)</li>
<li>执行<code>export PATH=/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin</code></li>
<li>正常用<code>vim</code>修改<code>/etc/profile</code>，完整命令如下：<code>sudo vim /etc/profile</code></li>
<li>使之起效<code>source /etc/profile</code></li>
<li>最后用<code>alt+ctl+shft+f7</code>命令回到图形化界面，正常登录。</li>
</ol>
<h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>操作系统真有趣：）</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;今天为了安装&lt;code&gt;go&lt;/code&gt;错误修改了&lt;code&gt;/etc/profile&lt;/code&gt;文件，导致&lt;code&gt;reboot&lt;/code&gt;的时候一直循环登录。最终通过搜索解决了问题。这里记录一下。&lt;/p&gt;
    
    </summary>
    
      <category term="网页开发" scheme="http://www.cvblogs.cn/categories/%E7%BD%91%E9%A1%B5%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Linux" scheme="http://www.cvblogs.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>解决Mackeeper流氓软件引起的Chrome广告弹窗</title>
    <link href="http://www.cvblogs.cn/2017/11/10/%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/%E8%A7%A3%E5%86%B3Mackeeper%E6%B5%81%E6%B0%93%E8%BD%AF%E4%BB%B6%E5%BC%95%E8%B5%B7%E7%9A%84Chrome%E5%B9%BF%E5%91%8A%E5%BC%B9%E7%AA%97/"/>
    <id>http://www.cvblogs.cn/2017/11/10/开发学习/解决Mackeeper流氓软件引起的Chrome广告弹窗/</id>
    <published>2017-11-10T09:27:26.000Z</published>
    <updated>2017-12-12T04:46:12.836Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>昨天，准确说应该是今早一点多的时候。不知道是怎么了，在下了<code>YouTube</code>一个推荐高效率<code>App</code>的视频中的软件之后，<code>Chrome</code>总是在我使用过程中弹窗<code>MacKeeper</code>的病毒广告。（主要下载了视频中推荐的几个软件：<code>Hidden Me</code>以及另外一个忘记了叫什么的管理<code>Display</code>的…发现并不好用，尽管他说的多么的好。其实自己用脚本完全能写的出来。这里暂且不表：）。然后，今天在使用过程中实在是不能忍了，于是乎。就上网查了一下。发现果然是中了套路，貌似还有点深。于是乎，就将自己解决的过程记录一下。并且调整了我解决问题的过程。我认为最关键的步骤被提前了。我始终认为是那几个步骤奏效的。</p>
<a id="more"></a>
<h2 id="更新方法"><a href="#更新方法" class="headerlink" title="更新方法"></a>更新方法</h2><p>发现下面的内容并不能根本解决问题，最后禁用了几个插件才解决了。以及删除了<code>/Library/</code>下的一些内容。</p>
<h2 id="删除最近下载的软件"><a href="#删除最近下载的软件" class="headerlink" title="删除最近下载的软件"></a>删除最近下载的软件</h2><p>不管问题是不是它引起的。反正我已经不打算用了。猎奇心理害死人啊。也有说是<code>Lantern</code>的问题。反正我也关了….</p>
<h2 id="删除启动项"><a href="#删除启动项" class="headerlink" title="删除启动项"></a>删除启动项</h2><p>命令行打开启动项所在的两个目录：<code>open /Library/LaunchDaemons</code>以及<code>open /Library/LaunchAgents</code>删除掉近期的项目。我记得我主要是删除了一个<code>com.pandasmite.plist</code>的文件。起初用文本编辑器打开时，觉得还挺正常的。记得用一个字段是设置了一个<code>3600</code>。现在怀疑是脚本开启的间隔…（我也不想复现了…）。<br>我是在执行了这些之后才不再弹窗的。<br>顺便，你还可以删除其他一些你不想看到的开机自启动项目。比在<code>用户和群组</code>中管理自启动项目要方便一些。有的时候一些自启动项目并不在那里！</p>
<h2 id="应用商店下载EasyFind"><a href="#应用商店下载EasyFind" class="headerlink" title="应用商店下载EasyFind"></a>应用商店下载EasyFind</h2><p>这是知乎上推荐的一个全盘搜索的软件，搜<code>MacKeeper</code>，不用区分大小写。果然找到两个，删除掉。顺便清空垃圾箱。</p>
<h2 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h2><p>感觉解决这个问题，我电脑重启了四五次。感觉把这么久以来所有的重启次数都用完了！中间以为自己成功却没有的感觉真的是让人崩溃：）流氓软件真的可怕。</p>
<h2 id="结束语：一些思考"><a href="#结束语：一些思考" class="headerlink" title="结束语：一些思考"></a>结束语：一些思考</h2><p>有说其利用的是<code>DNS劫持</code>。比较同意这个观点。它发起的第一个请求的网址似乎是一个<code>app.yyys.com</code>之类的，然后会定向到另一个网站，最后再定向到广告页面。<br>其实说是<code>lantern</code>搞得鬼，我觉得也有可能。但是我之前用似乎都是好好的。反正现在已经不用烦恼了。<br>话说，<code>Mac</code>系统不需要担心病毒却要担心流氓软件。好多人都是安装<code>XPlayer</code>的时候中招。幸亏我当时是安装的<code>Moivst</code>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;昨天，准确说应该是今早一点多的时候。不知道是怎么了，在下了&lt;code&gt;YouTube&lt;/code&gt;一个推荐高效率&lt;code&gt;App&lt;/code&gt;的视频中的软件之后，&lt;code&gt;Chrome&lt;/code&gt;总是在我使用过程中弹窗&lt;code&gt;MacKeeper&lt;/code&gt;的病毒广告。（主要下载了视频中推荐的几个软件：&lt;code&gt;Hidden Me&lt;/code&gt;以及另外一个忘记了叫什么的管理&lt;code&gt;Display&lt;/code&gt;的…发现并不好用，尽管他说的多么的好。其实自己用脚本完全能写的出来。这里暂且不表：）。然后，今天在使用过程中实在是不能忍了，于是乎。就上网查了一下。发现果然是中了套路，貌似还有点深。于是乎，就将自己解决的过程记录一下。并且调整了我解决问题的过程。我认为最关键的步骤被提前了。我始终认为是那几个步骤奏效的。&lt;/p&gt;
    
    </summary>
    
      <category term="网页开发" scheme="http://www.cvblogs.cn/categories/%E7%BD%91%E9%A1%B5%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="测试" scheme="http://www.cvblogs.cn/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
</feed>
