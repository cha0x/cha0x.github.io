<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CVBlogs</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.cvblogs.cn/"/>
  <updated>2018-01-01T15:11:33.545Z</updated>
  <id>http://www.cvblogs.cn/</id>
  
  <author>
    <name>Zhong Qin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>为什么张口闭口都先提贝叶斯和马尔可夫？</title>
    <link href="http://www.cvblogs.cn/2017/12/30/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%A0%E5%8F%A3%E9%97%AD%E5%8F%A3%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%92%8C%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB/"/>
    <id>http://www.cvblogs.cn/2017/12/30/理论学习/为什么张口闭口贝叶斯和马尔可夫/</id>
    <published>2017-12-30T12:51:45.000Z</published>
    <updated>2018-01-01T15:11:33.545Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>作为一个机器学习萌新，体系结构还未完善的建立起来。在与大牛的交谈过程中，经常他们讨论一个问题的解决方案时候，经常能听到是用”贝叶斯网络”和”马尔可夫链”？。起始时非常不解，就我本人而言，似乎机器学习 == 神经网络（= =，JS中的双等）。因此每当别人提到这两个名词的时候内心都非常的疑惑，为什么要提这两个而不具体的讲到底是用了什么方法呢？直到最近又重新看了一遍西瓜书之后才重新审视了自己的偏见，也借着梳理的机会分享一下（大部分还是摘录笔记）。强烈建议自己看看西瓜书第7章和第14章。</p><a id="more"></a><h1 id="机器学习模型分几类？"><a href="#机器学习模型分几类？" class="headerlink" title="机器学习模型分几类？"></a>机器学习模型分几类？</h1><p>也许你也像我一样，目前似乎已经懂了一些机器学习的相关概念。例如什么是样本（测试、训练）以及标签，什么是特征或维度即与它们相关的一些专有名词（特征提取、降维等），什么是模型表示，什么是目标函数评价，什么是优化= =。以及对应的经典的算法的专有名词表示（例如：SVM、NN、CNN、RNN；MSE；SGD）。（好吧，似乎目前我学的最多的就是NN相关的一些内容…）<br>忽略以上这些，一定要明白的大局观念就是：学习 = 表示 + 评价 + 优化<br>可以梳理成下面这个表格：</p><table><thead><tr><th>表示</th><th>评价</th><th>优化</th></tr></thead><tbody><tr><td>基于实例的方法</td><td>准确/错误比率</td><td>组合优化</td></tr><tr><td>近邻方法</td><td>精确率和召回率</td><td>贪心搜索</td></tr><tr><td>支持向量机</td><td>平方误差</td><td>柱搜索</td></tr><tr><td>超平面方法</td><td>似然(likelihood)</td><td>分支限界法</td></tr><tr><td>朴素贝叶斯</td><td>后验概率</td><td>连续优化</td></tr><tr><td>逻辑斯蒂回归</td><td>信息增益</td><td>无约束</td></tr><tr><td>决策树方法</td><td>K-L距离</td><td>梯度下降</td></tr><tr><td>规则集的方法</td><td>成本/效用</td><td>共轭梯度</td></tr><tr><td>命题规则</td><td>利润</td><td>拟牛顿法</td></tr><tr><td>逻辑程序</td><td></td><td>有约束</td></tr><tr><td>神经网络</td><td></td><td>线性规划</td></tr><tr><td>图模型</td><td></td><td>二次规划</td></tr><tr><td>贝叶斯网络</td><td></td><td></td></tr><tr><td>条件随机场</td><td></td></tr></tbody></table><p>另外还有必要再确认一下机器学习模型到底分几类？传统的分类方式是按照训练数据集是否有标签分成：有监督（数据集带标签）、无监督（数据集不带标签）、半监督（大部分数据集不带标签少部分带标签）<br>更具体的，却一般将其分成两种：生成式模型（Generative Model）与鉴别式模型（Discriminative Model），这两类也是贝叶斯和马尔可夫分别的代表，一个基于统计，一个基于概率。</p><h2 id="生成式模型"><a href="#生成式模型" class="headerlink" title="生成式模型"></a>生成式模型</h2><p>对于输入x，类别标签y，产生式模型估计它们的联合概率分布P(x,y)。产生式模型可以根据贝叶斯公式得到判别式模型，但反过来不行。</p><h3 id="产生式模型常见的主要有："><a href="#产生式模型常见的主要有：" class="headerlink" title="产生式模型常见的主要有："></a>产生式模型常见的主要有：</h3><ul><li>Gaussians</li><li>Naive Bayes</li><li>Mixtures of Multinomials</li><li>Mixtures of Gaussians</li><li>Mixtures of Experts</li><li>HMMs（隐马尔可夫模型）</li><li>Sigmoidal Belief Networks, Bayesian Networks</li><li>Markov Random Fields</li><li>Latent Dirichlet Allocation<h2 id="鉴别式模型"><a href="#鉴别式模型" class="headerlink" title="鉴别式模型"></a>鉴别式模型</h2>对于输入x，类别标签y，判别式模型估计条件概率分布P(y|x)<h3 id="判别式模型常见的主要有"><a href="#判别式模型常见的主要有" class="headerlink" title="判别式模型常见的主要有"></a>判别式模型常见的主要有</h3></li><li>Logistic Regression</li><li>SVM</li><li>Traditional Neural Networks</li><li>Nearest Neighbor</li><li>CRF</li><li>Linear Discriminant Analysis</li><li>Boosting</li><li>Linear Regression</li></ul><h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>当我们打开任何一个机器学习的网络视频时，不论是AndrewNg还是李宏毅老师的视频，总是从最简单的线性分类器讲起。接着会讲到如何衡量一个机器学习算法的好坏？接着就是巴拉巴拉一堆数学理论。以至于每次我看完都总觉得：哇，这都讲了啥啊= =，这也就导致了至今为止尚未完全的能够理解这个过程对应的编码过程。毕竟Linus大神有言”Talk is cheap，show me the code”。与计算机专业相关的任何内容的学习最终都离不开需要编程实现。于是我至今都不认为自己已经入门机器学习。但是一方面，我似乎又学习了很长时间的理论。大有种”我要这铁棒有何用”的无奈= =。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;作为一个机器学习萌新，体系结构还未完善的建立起来。在与大牛的交谈过程中，经常他们讨论一个问题的解决方案时候，经常能听到是用”贝叶斯网络”和”马尔可夫链”？。起始时非常不解，就我本人而言，似乎机器学习 == 神经网络（= =，JS中的双等）。因此每当别人提到这两个名词的时候内心都非常的疑惑，为什么要提这两个而不具体的讲到底是用了什么方法呢？直到最近又重新看了一遍西瓜书之后才重新审视了自己的偏见，也借着梳理的机会分享一下（大部分还是摘录笔记）。强烈建议自己看看西瓜书第7章和第14章。&lt;/p&gt;
    
    </summary>
    
      <category term="机器学习" scheme="http://www.cvblogs.cn/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="基础概念" scheme="http://www.cvblogs.cn/tags/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>机器学习基础概念再梳理</title>
    <link href="http://www.cvblogs.cn/2017/12/28/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E5%86%8D%E6%A2%B3%E7%90%86/"/>
    <id>http://www.cvblogs.cn/2017/12/28/理论学习/机器学习基础概念再梳理/</id>
    <published>2017-12-28T15:35:45.000Z</published>
    <updated>2017-12-28T16:32:03.282Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近真的是被毕设的东西搞疯了。一直以为自己遇到毕设的问题应该是非常容易的。没想到最终却是崩溃了…发现很多知识都不会，或者说根本就不理解。<br>直到我找到了这篇文章，感觉自己瞬间被打通了任督二脉。不过还是推荐有一点经验的同学自己去看原文<a href="http://www.360doc.com/content/13/1020/18/7673502_322833764.shtml" target="_blank" rel="noopener">原文地址</a>。<br>接下来的内容只是我摘录的一些原文以及穿插个人的笔记。</p><a id="more"></a><h1 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h1><p>何谓学习？<br><strong>学习=表示+评价+优化</strong></p><table><thead><tr><th>表示</th><th>评价</th><th>优化</th></tr></thead><tbody><tr><td>基于实例的方法</td><td>准确/错误比率</td><td>组合优化</td></tr><tr><td>近邻方法</td><td>精确率和召回率</td><td>贪心搜索</td></tr><tr><td>支持向量机</td><td>平方误差</td><td>柱搜索</td></tr><tr><td>超平面方法</td><td>似然(likelihood)</td><td>分支限界法</td></tr><tr><td>朴素贝叶斯</td><td>后验概率</td><td>连续优化</td></tr><tr><td>逻辑斯蒂回归</td><td>信息增益</td><td>无约束</td></tr><tr><td>决策树方法</td><td>K-L距离</td><td>梯度下降</td></tr><tr><td>规则集的方法</td><td>成本/效用</td><td>共轭梯度</td></tr><tr><td>命题规则</td><td>利润</td><td>拟牛顿法</td></tr><tr><td>逻辑程序</td><td></td><td>有约束</td></tr><tr><td>神经网络</td><td></td><td>线性规划</td></tr><tr><td>图模型</td><td></td><td>二次规划</td></tr><tr><td>贝叶斯网络</td><td></td><td></td></tr><tr><td>条件随机场</td><td></td></tr></tbody></table><h1 id="泛化-Generalization"><a href="#泛化-Generalization" class="headerlink" title="泛化(Generalization)"></a>泛化(Generalization)</h1><p>基本目标是对训练集合中样例的泛化。机器学习初学者最常犯的错误就是在训练数据上做测试，从而产生胜利的错觉。<br><strong>交叉验证（Cross Validation）</strong>将训练数据随机地等分为若干份，其中的每一份均可用做测试，而剩下的数据用作训练，然后将每个学习的分类器在它没见过的样例上进行测试，将测试结果取平均后，就可用来评价不同参数设置的性能。</p><h1 id="过拟合（Overfitting）"><a href="#过拟合（Overfitting）" class="headerlink" title="过拟合（Overfitting）"></a>过拟合（Overfitting）</h1><p>当你的分类器在训练数据上准确率为100%，而在测试数据上仅有50%的时候，说明这个分类器发生过拟合。<br>常见误解是认为其由噪音造成的。<br>一种理解过拟合的方式是将泛化误差分解为偏置（bias）和方差（variance）。<strong>偏置</strong>度量了学习器倾向于一直学习相同错误的程度。<strong>方差</strong>则度量了学习器倾向于忽略真实信号、学习随机食物的程度。</p><h2 id="避免过拟合的方法"><a href="#避免过拟合的方法" class="headerlink" title="避免过拟合的方法"></a>避免过拟合的方法</h2><p>交叉验证是一种方法。然而最常用的方法是对评价函数增加一个正则项（regularization term）。另外还有卡方测试等统计显著性检测。</p><h2 id="欠拟合（Underfitting）"><a href="#欠拟合（Underfitting）" class="headerlink" title="欠拟合（Underfitting）"></a>欠拟合（Underfitting）</h2><p>为了避免过拟合（方差）时很容易陷入欠拟合（偏置）问题中。</p><h1 id="维度灾难"><a href="#维度灾难" class="headerlink" title="维度灾难"></a>维度灾难</h1><p>“非均匀性的祝福”可以抵消维度灾难。</p><h1 id="特征工程"><a href="#特征工程" class="headerlink" title="特征工程"></a>特征工程</h1><p>现在经常采用的一种方式是先自动产生大量的候选特征，然后根据它们与分类类别的信息增益等方法来选取最好的特征。</p><h1 id="大数据带来的问题"><a href="#大数据带来的问题" class="headerlink" title="大数据带来的问题"></a>大数据带来的问题</h1><p><strong>可扩展性</strong><br>时间和内存的资源有限。<br>作为一条规则，首先应该在logistics回归之前尝试朴素贝叶斯，在支持向量机之前先尝试近邻。</p><h1 id="模型集成"><a href="#模型集成" class="headerlink" title="模型集成"></a>模型集成</h1><p>最简单的集成技术是bagging。另外还有一个是boosting。</p><h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>感觉自己对于学习时间的把控是自从十月答应和曹老师做医学影像以来就被浪费算起（感觉自己真的是疯了才会去学一些乱七八糟的：）。接着十一月去了公司实习，然后十二月的时候又执着于自己的一些事情。真的是感觉自己要炸了。留给毕设的时间真的是少的可怜。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近真的是被毕设的东西搞疯了。一直以为自己遇到毕设的问题应该是非常容易的。没想到最终却是崩溃了…发现很多知识都不会，或者说根本就不理解。&lt;br&gt;直到我找到了这篇文章，感觉自己瞬间被打通了任督二脉。不过还是推荐有一点经验的同学自己去看原文&lt;a href=&quot;http://www.360doc.com/content/13/1020/18/7673502_322833764.shtml&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文地址&lt;/a&gt;。&lt;br&gt;接下来的内容只是我摘录的一些原文以及穿插个人的笔记。&lt;/p&gt;
    
    </summary>
    
      <category term="机器学习" scheme="http://www.cvblogs.cn/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="基础概念" scheme="http://www.cvblogs.cn/tags/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>前端学习教程资源及经验分享</title>
    <link href="http://www.cvblogs.cn/2017/12/26/%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/web%E5%BC%80%E5%8F%91_%E6%95%99%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"/>
    <id>http://www.cvblogs.cn/2017/12/26/开发学习/web开发_教程学习经验分享/</id>
    <published>2017-12-25T18:09:04.000Z</published>
    <updated>2017-12-26T10:47:39.759Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从八月心血来潮搭个人博客到从九月开始自己学习Web开发，老实说看了很多教程。从中学习到了很多。特别是通过一些项目得到了很大的锻炼。这里简单的对自己说学习过的教程资源做一个总结。</p><a id="more"></a><h1 id="学完"><a href="#学完" class="headerlink" title="学完"></a>学完</h1><h2 id="Wes-Bos大神的ES6-for-Everyone"><a href="#Wes-Bos大神的ES6-for-Everyone" class="headerlink" title="Wes Bos大神的ES6 for Everyone"></a>Wes Bos大神的ES6 for Everyone</h2><p><a href="https://www.bilibili.com/video/av8498402/" target="_blank" rel="noopener">Bilibili视频地址</a><br>推荐指数：非常推荐<br>之前一直对JavaScript并不是很上心，可能是和一开始的语言偏见有关。在学习和实践之后发现绕来绕去还是回到语法的学习。</p><h2 id="Node-Authentication-Tutorial-with-Passport-js"><a href="#Node-Authentication-Tutorial-with-Passport-js" class="headerlink" title="Node Authentication Tutorial with Passport.js"></a>Node Authentication Tutorial with Passport.js</h2><p><a href="https://www.bilibili.com/video/av11730340/" target="_blank" rel="noopener">Bilibili视频地址</a><br>推荐指数：非常推荐<br>不建议一开始就学习这个。这个教程主要讲的是登陆验证。能让你明白Node中是如何组合Request、Response以及Session的运用。</p><h2 id="Semantic-UI-In-60-Minutes"><a href="#Semantic-UI-In-60-Minutes" class="headerlink" title="Semantic UI In 60 Minutes"></a>Semantic UI In 60 Minutes</h2><p><a href="https://www.bilibili.com/video/av15347497/" target="_blank" rel="noopener">Bilibili视频地址</a><br>虽然看完了但是感觉还是啥都没学会，也许是因为文档是英文的（虽然也有中文的文档，但是体验不好）。总觉得自己是没有掌握前段样式框架的学习套路导致的学习转换率太低了。</p><h2 id="前端工程师必备的PS技能——切图篇"><a href="#前端工程师必备的PS技能——切图篇" class="headerlink" title="前端工程师必备的PS技能——切图篇"></a>前端工程师必备的PS技能——切图篇</h2><p><a href="https://www.imooc.com/learn/506" target="_blank" rel="noopener">慕课教程地址</a><br>学习了一个很有用的工具！真的很有趣。不过作为偏后端编程的我们还是以后会少用= =</p><h2 id="创业公司的Nodejs工程师"><a href="#创业公司的Nodejs工程师" class="headerlink" title="创业公司的Nodejs工程师"></a>创业公司的Nodejs工程师</h2><p><a href="https://www.imooc.com/learn/728" target="_blank" rel="noopener">慕课教程地址</a><br>真正学习Node之前，建议学习一下这个课程，喝完鸡汤好上路：）</p><h2 id="进击Node-js基础（一）"><a href="#进击Node-js基础（一）" class="headerlink" title="进击Node.js基础（一）"></a>进击Node.js基础（一）</h2><p><a href="https://www.imooc.com/learn/348" target="_blank" rel="noopener">慕课教程地址</a><br>由于课程都较短，当时是一口气学完的，值得一学。</p><h2 id="快乐的sublime编辑器"><a href="#快乐的sublime编辑器" class="headerlink" title="快乐的sublime编辑器"></a>快乐的sublime编辑器</h2><p><a href="https://www.imooc.com/learn/333" target="_blank" rel="noopener">慕课教程地址</a><br>在学习前端课程中，会发现Sublime的出现率真的很高！这个教程算是不错的。</p><h2 id="IntelliJ-IDEA神器使用技巧"><a href="#IntelliJ-IDEA神器使用技巧" class="headerlink" title="IntelliJ IDEA神器使用技巧"></a>IntelliJ IDEA神器使用技巧</h2><p><a href="https://www.imooc.com/learn/924" target="_blank" rel="noopener">慕课教程地址</a><br>很值得学习的一门课，至少对于自己一直需要使用的IDE还是需要熟悉的。正所谓”工欲善其事必先利其器”。最关键的是教程是免费的。</p><h2 id="Handlebars模板引擎"><a href="#Handlebars模板引擎" class="headerlink" title="Handlebars模板引擎"></a>Handlebars模板引擎</h2><p><a href="https://www.imooc.com/learn/859" target="_blank" rel="noopener">慕课教程地址</a><br>自己学习的第一个模版引擎，对于前后端分离的趋势。掌握一个模版引擎之后上手其他模版引擎真的非常快！</p><h1 id="一半或更少"><a href="#一半或更少" class="headerlink" title="一半或更少"></a>一半或更少</h1><h2 id="传智播客Node-js"><a href="#传智播客Node-js" class="headerlink" title="传智播客Node.js"></a>传智播客Node.js</h2><p><a href="https://www.bilibili.com/video/av14169969/" target="_blank" rel="noopener">Bilibili视频地址</a><br>课程时长：5Days<br>老师讲的不错，讲的比较细致而全面，学完这个的话就能够掌握Node.js开发的核心所在了（如什么是异步编程以及模块的概念等）。特别重要的是如何Debug，之前有点不以为然，但是几天前，因为一直以来都没有debugger的习惯，导致使用<code>console.log()</code>异常痛苦实在是要了老血命了。但是当时也许是自己比较笨，或者是懒得学（教程实在是觉得很拖沓，总共有五天的教程量），大概就只是学了一点点。</p><h2 id="传智播客AJAX"><a href="#传智播客AJAX" class="headerlink" title="传智播客AJAX"></a>传智播客AJAX</h2><p><a href="https://www.bilibili.com/video/av14332834/" target="_blank" rel="noopener">Bilibili视频地址</a><br>课程时长：4Days<br>同属于传智Web开发套餐，这个教程里学到了很重要的关于网络协议的一些理论知识。很形象。比起我校网络老师只会念PPT和讲自己的成年旧事不知道强到哪里去。但是因为实在是一些知识点讲的太细了，最终还是没能坚持下来。</p><h2 id="传智播客JQuery"><a href="#传智播客JQuery" class="headerlink" title="传智播客JQuery"></a>传智播客JQuery</h2><p><a href="https://www.bilibili.com/video/av14216482/" target="_blank" rel="noopener">Bilibili视频地址</a><br>课程时长：4Days<br>基本上没怎么学，当时并不是很上心。不过看评价很不错。</p><h2 id="Grunt-beginner前端自动化工具"><a href="#Grunt-beginner前端自动化工具" class="headerlink" title="Grunt-beginner前端自动化工具"></a>Grunt-beginner前端自动化工具</h2><p><a href="https://www.imooc.com/learn/30" target="_blank" rel="noopener">慕课教程地址</a><br>记得当时学习这个是因为要修改一个hexo主题，但是最终也没有学会。作为自动化工具。Grunt似乎已经被Gulp拍死在了沙滩上…</p><h1 id="淘沙在学"><a href="#淘沙在学" class="headerlink" title="淘沙在学"></a>淘沙在学</h1><h2 id="Wes-Bos-React-For-Beginners"><a href="#Wes-Bos-React-For-Beginners" class="headerlink" title="Wes Bos - React For Beginners"></a>Wes Bos - React For Beginners</h2><p><a href="https://www.bilibili.com/video/av8567329/" target="_blank" rel="noopener">Bilibili视频地址</a><br>课程时长：2.5h/29Lessons<br>其实并不适合从零开始学习，还是需要从实践中找到自己去发现自己欠缺的地方，这样子回头再去学的话就能够有的放矢，学习效率也更高。</p><h2 id="传智播客混合APP开发基础"><a href="#传智播客混合APP开发基础" class="headerlink" title="传智播客混合APP开发基础"></a>传智播客混合APP开发基础</h2><p><a href="https://www.bilibili.com/video/av14358701/" target="_blank" rel="noopener">Bilibili视频地址</a><br>课程时长：5Days<br>老实说我就看了第一天的内容。</p><h2 id="Redux-React-Tutorial"><a href="#Redux-React-Tutorial" class="headerlink" title="Redux-React Tutorial"></a>Redux-React Tutorial</h2><p><a href="https://www.bilibili.com/video/av11530583/" target="_blank" rel="noopener">Bilibili视频地址</a><br>关于React、Redux还是不是很熟悉</p><h1 id="一点心得与体会"><a href="#一点心得与体会" class="headerlink" title="一点心得与体会"></a>一点心得与体会</h1><p>初次接触Web开发（很惭愧，之前的大作业都是用的别人的代码，验收的时候，跑起来就OK，导致根本就没往心里去学。所以基本上可以说是从0开始的。<br>其实在接触Web开发之前，我对写网页（特别是前端开发）抱有很大的偏见。总觉得其不过尔尔，但是真要我自己真的动手去做却又做不出来。我觉得这可能也是一部分人的傲慢与偏见。<br>从一开始的HTML到CSS最后到最原始的JavaScript语法再到后来的Node.js以及React.js，学习过程中很多时候只是看视频里的人敲而已。真正自己写代码还是借着走项目的机会。从0开始自己一点点的实现内容。中间学习到了很多东西。有的时候还是挺有成就感的。但是当我的舍友让我向其展示我所做的内容我却感觉自己拿不出一个抓眼的东西。总觉得自己好像一直在coding，GitHub的主页颜色也好看。但是真正能够给别人看的项目却是少之又少。所以革命尚未成功，还需努力。<br>虽然目前也只是学习了一个皮毛，却是想要借着空闲将我目前学习的Web开发过程中的一些教程资源做一个简单的汇总整理。也希望自己重新从里头再找找看当时因为各种原因弃坑的那些教程中有没有可以再学习的！<br>因为老师们讲课一般较慢，建议学习的时候1.5X播放。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;从八月心血来潮搭个人博客到从九月开始自己学习Web开发，老实说看了很多教程。从中学习到了很多。特别是通过一些项目得到了很大的锻炼。这里简单的对自己说学习过的教程资源做一个总结。&lt;/p&gt;
    
    </summary>
    
      <category term="网页开发" scheme="http://www.cvblogs.cn/categories/%E7%BD%91%E9%A1%B5%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="课程总结" scheme="http://www.cvblogs.cn/tags/%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>mxnet之简单线性回归源码解读</title>
    <link href="http://www.cvblogs.cn/2017/12/12/%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/mxnet-%E7%AE%80%E5%8D%95%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    <id>http://www.cvblogs.cn/2017/12/12/开发学习/mxnet-简单线性回归源码解读/</id>
    <published>2017-12-12T02:40:21.000Z</published>
    <updated>2017-12-12T04:36:49.789Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>此篇博文相关：<a href="http://zh.gluon.ai/chapter_supervised-learning/linear-regression-gluon.html" target="_blank" rel="noopener">线性回归 — 使用Gluon</a>中源码的解读。<br><a id="more"></a></p><h1 id="源码及注释解析"><a href="#源码及注释解析" class="headerlink" title="源码及注释解析"></a>源码及注释解析</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 设置迭代次数5次，每次迭代都完整取所有数据</span></div><div class="line">epochs = <span class="number">5</span></div><div class="line"><span class="comment"># 设置每次取数据的batch = 10，如例子中数据集是1000，则每次迭代都取100次数据，每次都取10个数据</span></div><div class="line">batch_size = <span class="number">10</span></div><div class="line"><span class="comment"># for循环迭代：共5次，range(epochs)模拟0，1，2，3，4</span></div><div class="line"><span class="keyword">for</span> e <span class="keyword">in</span> range(epochs):</div><div class="line">    <span class="comment">#每次迭代，初始的损失置为0</span></div><div class="line">    total_loss = <span class="number">0</span></div><div class="line">    <span class="comment"># 从data_iter迭代器中取数据，data_iter = gluon.data.Dataloader(dataset,batch_size,shuffle=True)</span></div><div class="line">    <span class="comment"># 上诉dataset = gluon.data.ArrayDataset(X,y)即由数据集X和其对应的标签y组成的数据集合</span></div><div class="line">    <span class="comment"># 因此，data_iter迭代器每次取出的data和label即batch_size个数据集对：X'和y'，直到取完所有数据，结束循环（1000/10=100次）</span></div><div class="line">    <span class="keyword">for</span> data, label <span class="keyword">in</span> data_iter:</div><div class="line">        <span class="comment"># 利用autograd.record()API自动记录梯度</span></div><div class="line">        <span class="keyword">with</span> autograd.record():</div><div class="line">            <span class="comment"># 输出等于将数据X传入你定义的模型net（可以这么理解：线性模型即是y'关于x的函数）</span></div><div class="line">            output = net(data)</div><div class="line">            <span class="comment"># 这里定义的损失函数是衡量真值label与有你的模型产生的预测值之间的误差。此处使用的是均方误差，你也可以换成你自己定义的其他损失函数</span></div><div class="line">            loss = square_loss(output, label)</div><div class="line">        <span class="comment"># 反向传播误差，这里可以将这个动作看作是一个信号，损失反向了，但是真正利用损失反向传播的却是接下来的trainer</span></div><div class="line">        loss.backward()</div><div class="line">        <span class="comment"># 传播了误差之后，我们还需要利用一些更新参数的方法对参数进行更新</span></div><div class="line">        <span class="comment"># 注意这里使用的是gluon提供的API:gluon.Trainer(net.collect_params,'使用的更新模型参数的方法名：如随机梯度下降',&#123;指定的学习率learning_rate:0.1是一个字典&#125;)</span></div><div class="line">        <span class="comment"># 如：trainer = gluon.Trainer(net.collect_params(),'sgd', &#123;'learning_rate': 0.1&#125;)</span></div><div class="line">        <span class="comment"># 最后利用trainer.step(batch_size)API反向更新模型参数w,b</span></div><div class="line">        trainer.step(batch_size)</div><div class="line">        <span class="comment"># 将每次训练的损失加入总损失（一共要加100次，直到迭代完成）。由于每次循环得到的是一个长度为batch_size的一维向量，但是总损失是标量。因此得利用asscalar()转化为标量进行操作</span></div><div class="line">        total_loss += nd.sum(loss).asscalar()</div><div class="line">    <span class="comment"># 打印出一次迭代的平均误差=总误差/样本数</span></div><div class="line">    print(<span class="string">"Epoch %d, average loss: %f"</span> % (e, total_loss/num_examples))</div></pre></td></tr></table></figure><h1 id="一些易混淆的名词"><a href="#一些易混淆的名词" class="headerlink" title="一些易混淆的名词"></a>一些易混淆的名词</h1><h2 id="模型定义"><a href="#模型定义" class="headerlink" title="模型定义"></a>模型定义</h2><p>可以这么通俗的理解：模型即是你定义的一个由数据集生成预测值的函数。在训练过程中，我们往模型中传入训练数据集得到的是一个预测值。我们无法知道这个预测值到底是对是错是好是坏。它只是单纯的对预测值的一个刻画。</p><h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><p>那么我们如何描述我们的模型是好是坏呢？这里就必须引入损失这个概念。所谓损失，单纯来讲就是预测值与真实值之间的误差。理想情况下，我们希望我们的损失是0或者接近于0。</p><h2 id="初始化模型参数"><a href="#初始化模型参数" class="headerlink" title="初始化模型参数"></a>初始化模型参数</h2><p>其实当我们在说模型的时候，我们通常不能很完整的说出：我们的模型具体是什么（我在想这可能是由于我们维度限制了我们的想象力= =）。也就是大部分模型无法解释清楚的。不像线性模型：我们可以这么定义：$y^’=wx+b$，然后我们可以这么解释：例如，w是斜率而b是截距。但是对于一些非线性的模型，里头的参数不再具有可解释性质。<br>因此，一般情况下，我们说我训练一个模型指的就是我训练了模型中的参数。例如：w和b就是我们通过训练线性模型得到的参数。<br>但是，想象一下，最初的时候，我们手上只有一些数据，以及数据对应的标签（真实值）。还是以线性模型为例子：我们定义了一个模型$y^’=wx+b$(目前，在不对w和b初始化的情况下，这两个也是变量)。因此，我们的模型就有了三个变量。但是我们只希望在给模型传入一个数据x的时候得到的是一个预测值$y^’$。<br>因此，我们就需要初始化我们的模型参数w和b。我们可以随机对其初始化，也可以指定一个参数（可能是从其他地方迁移学习过来的：其实就是按照数据集的关系的相似性，衡量照抄它的参数= =）。</p><h2 id="模型参数更新策略（优化）"><a href="#模型参数更新策略（优化）" class="headerlink" title="模型参数更新策略（优化）"></a>模型参数更新策略（优化）</h2><p>现在，我们的模型中只剩下一个变量$y^’$，我们可以输入一个数据得到一个预测值。我们通过比较预测值和真实值得到损失。但是，我们要如何更新我们的参数使得我们的模型在每一次迭代完所有数据之后。根据损失，能够调整模型参数！实现利用<strong>数据编程</strong>！<br>这里就有了反向传播以及随机梯度下降等的概念。反向传播传播的是损失（也叫残差），随机梯度中就是利用损失的反向梯度，往回走batch_size个样本损失的距离，使得参数得到更新。<code>param[:] = param - lr * param.grad</code>。这里lr就是学习率。<br>这样在进行下一次循环（此时还是在一次迭代，100次循环里头）的时候，我们的参数能够有所改进，使模型更拟合真实数据。也就是说话我们共循环更新了5*1000/10=500次参数！</p><h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>尽管不知道已经花了多少时间和精力取学习了多少机器学习相关的东西，但是感觉自己对于理论或者说这些专有名词，永远都不上心的样子。但是这样子真的是百害而无一利。直到我遇到了李沐老师团队的MXNet= =。决定一定要沉心静气学好理论并且动手实践！</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;此篇博文相关：&lt;a href=&quot;http://zh.gluon.ai/chapter_supervised-learning/linear-regression-gluon.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;线性回归 — 使用Gluon&lt;/a&gt;中源码的解读。&lt;br&gt;
    
    </summary>
    
      <category term="机器学习" scheme="http://www.cvblogs.cn/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="MXNet" scheme="http://www.cvblogs.cn/tags/MXNet/"/>
    
  </entry>
  
  <entry>
    <title>python之高级语言特性：切片</title>
    <link href="http://www.cvblogs.cn/2017/12/11/%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/python-%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/"/>
    <id>http://www.cvblogs.cn/2017/12/11/开发学习/python-高级语言特性/</id>
    <published>2017-12-11T15:19:34.000Z</published>
    <updated>2017-12-12T04:39:54.535Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>由于最近大都使用Python作为主要的开发语言，并且以后也将长期使用（用于编程科学计算相关的内容）等。决定还是好好学习一下python。<br>以下内容是学习<a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431756919644a792ee4ead724ef7afab3f7f771b04f5000" target="_blank" rel="noopener">廖雪峰Python教程-切片</a>的笔记梳理。</p><a id="more"></a><h1 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h1><p>对这种经常取指定索引范围的操作，用循环十分繁琐，因此，Python提供了切片（Slice）操作符，能大大简化这种操作。<br><code>L[0:3]</code>表示，从索引<code>0</code>开始取，直到索引<code>3</code>为止，但<strong>不包括索引<code>3</code></strong>。即索引<code>0</code>，<code>1</code>，<code>2</code>，正好是<code>3</code>个元素。<br>如果第一个索引是<code>0</code>，还可以省略：<code>L[:3]</code><br>类似的，既然Python支持<code>L[-1]</code>取倒数第一个元素，那么它同样<strong>支持倒数切片</strong>:<code>L[-2:]</code>。记住倒数第一个元素的索引是<code>-1</code>。<br>什么都不写，只写<code>[:]</code>就可以原样复制一个<code>list</code><br>tuple也是一种list，唯一区别是tuple不可变。因此，tuple也可以用切片操作，只是操作的结果仍是tuple。<br>Python没有针对字符串的截取函数，只需要切片一个操作就可以完成，非常简单。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>切片利用的是<code>[(起始位置，如果是0可以被省略):(切片结束位置，如果是全部可以被省略):(截取数据的步长，如果不指定，连同前面的</code>:<code>可以被省略)]</code>。</p><h1 id="多维数组的切片"><a href="#多维数组的切片" class="headerlink" title="多维数组的切片"></a>多维数组的切片</h1><p>由于python不支持多维列表这一说（我们无法利用列表来模拟多维数组），因此我们得引入<code>numpy</code>进行转化。<br>也是前几个冒号组成范围，最后一个冒号是步长。如果省略则为1。</p><h1 id="引用链接"><a href="#引用链接" class="headerlink" title="引用链接"></a>引用链接</h1><p><a href="http://blog.csdn.net/lanchunhui/article/details/49493633" target="_blank" rel="noopener">Python 基础——range() 与 np.arange()</a><br><a href="http://old.sebug.net/paper/books/scipydoc/numpy_intro.html" target="_blank" rel="noopener">http://old.sebug.net/paper/books/scipydoc/numpy_intro.html</a><br><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431756919644a792ee4ead724ef7afab3f7f771b04f5000" target="_blank" rel="noopener">廖雪峰Python教程-切片</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;由于最近大都使用Python作为主要的开发语言，并且以后也将长期使用（用于编程科学计算相关的内容）等。决定还是好好学习一下python。&lt;br&gt;以下内容是学习&lt;a href=&quot;https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431756919644a792ee4ead724ef7afab3f7f771b04f5000&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;廖雪峰Python教程-切片&lt;/a&gt;的笔记梳理。&lt;/p&gt;
    
    </summary>
    
      <category term="网页开发" scheme="http://www.cvblogs.cn/categories/%E7%BD%91%E9%A1%B5%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Python" scheme="http://www.cvblogs.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>翻译：理解深度学习中的卷积操作</title>
    <link href="http://www.cvblogs.cn/2017/12/10/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/%E7%90%86%E8%A7%A3%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E5%8D%B7%E7%A7%AF%E6%93%8D%E4%BD%9C/"/>
    <id>http://www.cvblogs.cn/2017/12/10/理论学习/理解深度学习中的卷积操作/</id>
    <published>2017-12-09T17:18:18.000Z</published>
    <updated>2017-12-10T12:48:24.408Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>此文为译文，目的是让自己更好的理解卷积操作。原文地址：<a href="http://timdettmers.com/2015/03/26/convolution-deep-learning/" target="_blank" rel="noopener">Understanding Convolution in Deep Learning</a></p><p>非常fascinating的是作者关于卷积在卷积网络中的应用。之前从来没有想过，为啥卷积网络就卷积了呢？（不过似乎我一直也都是停留在对全连接网络的学习上= =）</p><a id="more"></a><h1 id="译文"><a href="#译文" class="headerlink" title="译文"></a>译文</h1><p>如今，卷积可能是深度学习中最重要的一个概念。卷积操作及卷积网络使深度学习在机器学习任务中表现靠前。但是，什么使得卷积操作如此强大呢？在这篇文章中我会解释卷积操作以及关联它的相关概念帮助你更完全的理解卷积。</p><p>虽然已有大量介绍卷积相关的深度学习的博文，但是我发现他们大都因为介绍了过多的不必要的数学细节反而导致令人费解。这篇博文虽然也会介绍一些数学细节，但是我会通过图片的形式展现关键的数学表达式，使其更直观易懂。第一部分是介绍一些通泛的卷积概念以及卷积网络。第二部分则是为深度学习研究人员和专家能够加强理解而准备的一些更高级的概念。</p><h1 id="什么是卷积？"><a href="#什么是卷积？" class="headerlink" title="什么是卷积？"></a>什么是卷积？</h1><p>整篇文章都是建立在去解答这个问题上，因此首先了解大致的方向是很有帮助的。那么，单纯的卷积说的是什么呢？</p><p>你可以想象卷积是混淆信息的方式。想象两个装满信息的桶被按照某种指定的规则被倒入一个桶里进行混合。每一个桶里的内容，都有它自己的关于如何混合其他桶中信息的指导方式。因此，卷积是一个按照指定步骤执行的混合信息的操作。</p><p>事实上，卷积和其他数学运算一样也可以被数学定义。尽管卷积操作本身十分的复杂，但是对于复杂的等式，它又可以简化表示。因此，为了简化表达，卷积操作被大量用在了物理学以及工程学上。在第二部分，经过一小段数学证明后。我们会关联和整合科学和深度学习的创意，得到更深层次的关于卷积的理解。但是，我们现在先暂时关注卷积在实际中的应用。</p><h1 id="我们如何对图片做卷积操作？"><a href="#我们如何对图片做卷积操作？" class="headerlink" title="我们如何对图片做卷积操作？"></a>我们如何对图片做卷积操作？</h1><p>当我们对图片做卷积时，我们是对两个维度做了卷积（即图片的宽和高方向）。我们混合两个桶中的内容：第一个桶是输入的图片（可以看作是三个像素矩阵组成，因为图像是由RGB三通道组成的；每个像素矩阵中元素的值：0～255）。第二个桶中是卷积核，一个独立的由浮点数组成的矩阵。（可以将它的大小以及模式看作是一个如何混合两个桶中信息的指导方式）。输出的结果在深度学习中被叫做特征图像(feature map)。每个通道都会产生一个特征图像。<br><img src="https://i1.wp.com/timdettmers.com/wp-content/uploads/2015/03/convolution.png" alt="用一个边缘算子与图像做卷积操作的过程"></p><p>现在，我们演示卷积是如何混合两份信息。一种方法是利用输入图像采样一个小块做卷积操作–我们用100X100的图像，以及3X3的核。因此，我们可以同时采样3X3个像素点（和核做点乘）。最终得到的是一个中心值。当采样完一个地方（3X3）就向一个方向移动一个像素点。循环往复。当所有的像素都被计算后操作才停止。下面的动图展示了卷积操作的一个过程。<br><img src="https://i2.wp.com/timdettmers.com/wp-content/uploads/2015/03/aa-convolution-02.gif" alt="目标图片一个像素点的计算过程"><br>如你所见，为了保证与原图像有同样的密度一致性，这里通常还有一个正则化的过程。</p><h1 id="为什么作用在图片的卷积操作在机器学习中如此有效？"><a href="#为什么作用在图片的卷积操作在机器学习中如此有效？" class="headerlink" title="为什么作用在图片的卷积操作在机器学习中如此有效？"></a>为什么作用在图片的卷积操作在机器学习中如此有效？</h1><p>在一张图像中有大量的我们不需要的冗余信息。一个很好的例子就是<code>Burda Bootcamp</code>（这是原文作者一个在快速原型生成的马拉松式的学生实验项目中的项目=  =）在一个项目，作者想要搭建一个用于时尚图片搜索深度自编码器：你上传一张关于时尚单品的照片，自编码器会找出与图中的单品包含的相关风格的图片。</p><p>现在，如果你想鉴别不同风格的衣服，衣服的颜色不会有什么帮助，类似的还有衣服的商标等。关键的要素是衣服的形状。通常，女士衬衫的形状是异于短袖，夹克或毛衣的。因此，我们需要过滤图像中不必要的信息。通过卷积操作我们可以很容易完成这个需求。</p><p>作者的同事Jannek Thomas用Sobel算子（它的定义与前面的那个那个边缘算子差不多）预处理了数据，得到了重要的边缘信息。这也是为什么卷积操作也叫做滤波。边缘信息的提取对于形状信息的获得非常有帮助。<br><img src="https://i1.wp.com/timdettmers.com/wp-content/uploads/2015/03/autoencoder_fashion_features_and_results.png" alt="上面是提取完边缘信息后的图像"></p><p>更深入的：很多的核产生很多的特征图像（map）。例如：锐化图像的，模糊图像的。</p><p>通过这个过程–输入图像，转化输入，得到转化后的图像将其引入算法中。被成为特征提取工程。特征工程非常困难，拥有的学习资料也非常有限。因此，很少有人能够熟练运用它。有效的特征提取在不同的任务中区别很大。因此，不存在通用的特征。同时，对于时间序列数据，特征几乎收效甚微。识别特征的有效性需要大量的经验。</p><p>因此，特征工程非常困难，你必须从零开始一点点去试探。但是，当我们关注图像本身，有什么方法可以自动的找到特征提取的核的吗？</p><h1 id="引入卷积网络"><a href="#引入卷积网络" class="headerlink" title="引入卷积网络"></a>引入卷积网络</h1><p>卷积网络就是干这个的。较于固定我们的核，我们指定一组参数然后让网络训练我们的核。当我们训练我们的卷积网络时，核会随着过程学习，过滤得到更有用的信息。这个过程是全自动的，也被叫做特征学习。特征学习自动得到一个任务的特征。我们所需要做的就是训练我们的网络，去找到一个与新的任务相关的filter。这就是为什么卷积网络如此强大的原因–不再为特征的提取而烦恼。</p><blockquote><p>数据编程的概念</p></blockquote><p>通常我们在一个卷积网络中，不会只学习一个核。我们同时学到一个组织（hierarchy）的多个核。例如：一个32X16X16的核应用在一张256X256的图像上会产生32个241X241的特征图像。（这是标准大小，实现的不同大小特跟着改变；image size - kernel size +1）。因此我们自动学习得到的32个新特征拥有与我们的任务相关的所有信息。这些特征又为接下来的核计算提供了输入。一旦我们学习完所有的核，我们就将其传入给一个全连接的网络（简单的网络，用作图像的分类。）。这就是卷积网络所有的应该知道的概念（池化的过程也很重要，但是它的内容也够写一篇博文了）。</p><h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>放弃了，第二部分还是自己看吧= =翻译的效率实在太低了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;此文为译文，目的是让自己更好的理解卷积操作。原文地址：&lt;a href=&quot;http://timdettmers.com/2015/03/26/convolution-deep-learning/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Understanding Convolution in Deep Learning&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;非常fascinating的是作者关于卷积在卷积网络中的应用。之前从来没有想过，为啥卷积网络就卷积了呢？（不过似乎我一直也都是停留在对全连接网络的学习上= =）&lt;/p&gt;
    
    </summary>
    
      <category term="深度学习" scheme="http://www.cvblogs.cn/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="数学基础" scheme="http://www.cvblogs.cn/tags/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>linux之ssh命令</title>
    <link href="http://www.cvblogs.cn/2017/12/08/%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/linux_ssh%E5%91%BD%E4%BB%A4/"/>
    <id>http://www.cvblogs.cn/2017/12/08/开发学习/linux_ssh命令/</id>
    <published>2017-12-08T12:12:12.000Z</published>
    <updated>2017-12-12T04:42:39.444Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天需要使用ssh的时候发现居然不好使了，原来是自己在电脑上用了lantern之后，ip被改了，不在一个局域网内，无法访问非公网ip。（主要是根本ping不同目的主机= =）<br>于是打算借着机会好好的梳理一下ssh命令。</p><a id="more"></a><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="http://blog.csdn.net/pipisorry/article/details/52269785" target="_blank" rel="noopener">ssh用法及命令</a></p><h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>为什么这篇文章的结束语这么靠前，是因为，我在看完大段的内容之后依旧无法弄清楚。如果我要将远端的8000端口映射到本地的8888端口我该用什么命令。感觉这样子陈列知识点真的很糟糕。还是应该以具体的应用来说比较好。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ssh -L 8888:localhost:8000 remote<span class="comment">#remote是远端主机名</span></div><div class="line">ssh -p 8888 localhost<span class="comment">#此时ssh登陆本机8888端口就相当于登陆了remote了，稍后可以一试：）</span></div></pre></td></tr></table></figure></p><h1 id="什么是SSH"><a href="#什么是SSH" class="headerlink" title="什么是SSH"></a>什么是SSH</h1><p>首先，需要明确的是：SSH是一种网络协议，用于计算机之间的加密登录。目前已经成为Linux系统的标准配置。</p><p>SSH只是一种协议，存在多种实现，既有商业实现，也有开源实现。本文针对的实现是OpenSSH，它是自由软件，应用非常广泛。这里只讨论SSH在Linux Shell中的用法。如果要在Windows系统中使用SSH，会用到另一种软件PuTTY。</p><blockquote><p>注解：SSH只是一种协议，而我们所用的SSH命令则是基于该工具封装的一种命令行工具（linux shell）。<br>PuTTY是一个实现这些协议的图形化工具（它支持的协议不止有SSH）</p></blockquote><h1 id="SSH原理"><a href="#SSH原理" class="headerlink" title="SSH原理"></a>SSH原理</h1><p>SSH之所以能够保证安全，原因在于它采用了公钥加密。整个过程是这样的：<br>（1）远程主机收到用户的登录请求，把自己的公钥发给用户。<br>（2）用户使用这个公钥，将登录密码加密后，发送回来。<br>（3）远程主机用自己的私钥，解密登录密码，如果密码正确，就同意用户登录。</p><blockquote><p>不像https协议，SSH协议的公钥是没有证书中心（CA）公证的，也就是说，都是自己签发的。</p></blockquote><h2 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h2><p>可以设想，如果攻击者插在用户与远程主机之间（比如在公共的wifi区域），用伪造的公钥，获取用户的登录密码。再用这个密码登录远程主机，那么SSH的安全机制就荡然无存了。这种风险就是著名的”中间人攻击”（Man-in-the-middle attack）</p><h1 id="SSH基本用法"><a href="#SSH基本用法" class="headerlink" title="SSH基本用法"></a>SSH基本用法</h1><h2 id="SSH远程登录"><a href="#SSH远程登录" class="headerlink" title="SSH远程登录"></a>SSH远程登录</h2><p>口令登录<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#假定你要以用户名user，登录远程主机host，只要一条简单命令就可以了。</span></div><div class="line">$ ssh user@host  如：ssh pika@192.168.0.111</div><div class="line"><span class="comment">#如果本地用户名与远程用户名一致，登录时可以省略用户名。</span></div><div class="line">$ ssh host</div><div class="line"><span class="comment">#SSH的默认端口是22，也就是说，你的登录请求会送进远程主机的22端口。使用p参数，可以修改这个端口</span></div><div class="line">$ ssh -p 2222 user@host</div></pre></td></tr></table></figure></p><h2 id="公钥登录"><a href="#公钥登录" class="headerlink" title="公钥登录"></a>公钥登录</h2><p>所谓”公钥登录”，原理很简单，就是用户将自己的公钥储存在远程主机上。登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录shell，不再要求密码。<br><strong>这种方法要求用户必须提供自己的公钥。如果没有现成的，可以直接用ssh-keygen生成一个</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ ssh-keygen</div><div class="line"><span class="comment"># 运行结束以后，在$HOME/.ssh/目录下，会新生成两个文件：id_rsa.pub和id_rsa。前者是你的公钥，后者是你的私钥。</span></div><div class="line"></div><div class="line"><span class="comment"># 这时再输入下面的命令，将公钥传送到远程主机host上面：</span></div><div class="line">$ ssh-copy-id user@host</div></pre></td></tr></table></figure></p><h2 id="使用ssh在远程后台不中断地跑程序"><a href="#使用ssh在远程后台不中断地跑程序" class="headerlink" title="使用ssh在远程后台不中断地跑程序"></a>使用ssh在远程后台不中断地跑程序</h2><p>使用nohup命令让程序在关闭窗口（切换SSH连接）的时候程序还能继续在后台运行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nohup python3 a.py &amp;</div></pre></td></tr></table></figure></p><h1 id="SSH远程操作"><a href="#SSH远程操作" class="headerlink" title="SSH远程操作"></a>SSH远程操作</h1><h2 id="SSH数据传输"><a href="#SSH数据传输" class="headerlink" title="SSH数据传输"></a>SSH数据传输</h2><p>SSH不仅可以用于远程主机登录，还可以直接在远程主机上执行操作。<br>SSH可以在用户和远程主机之间，建立命令和数据的传输通道，因此很多事情都可以通过SSH来完成。</p><h2 id="scp-跨机远程拷贝"><a href="#scp-跨机远程拷贝" class="headerlink" title="scp 跨机远程拷贝"></a>scp 跨机远程拷贝</h2><p>scp是secure copy的简写，用于在Linux下进行远程拷贝文件的命令，和它类似的命令有cp，不过cp只是在本机进行拷贝不能跨服务器，而且scp传输是加密的。可能会稍微影响一下速度。<br><strong>两台主机之间复制文件必需得同时有两台主机的复制执行帐号和操作权限</strong>。</p><blockquote><p>注解：建议使用scp进行远程copy</p></blockquote><h2 id="绑定本地端口"><a href="#绑定本地端口" class="headerlink" title="绑定本地端口"></a>绑定本地端口</h2><p>可以让那些不加密的网络连接，全部改走SSH连接，从而提高安全性。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#假定我们要让8080端口的数据，都通过SSH传向远程主机，命令就这样写：</span></div><div class="line">$ ssh -D 8080 user@host</div></pre></td></tr></table></figure></p><blockquote><p>SSH会建立一个socket，去监听本地的8080端口。一旦有数据传向那个端口，就自动把它转移到SSH连接上面，发往远程主机。<br>可以想象，如果8080端口原来是一个不加密端口，现在将变成一个加密端口。</p></blockquote><h2 id="本地端口转发"><a href="#本地端口转发" class="headerlink" title="本地端口转发"></a>本地端口转发</h2><p>有时，绑定本地端口还不够，还必须指定数据传送的目标主机，从而形成<strong>点对点的”端口转发”</strong>。<br>为了区别后文的”远程端口转发”，我们把这种情况称为”本地端口转发”（Local forwarding）</p><h2 id="远程端口转发"><a href="#远程端口转发" class="headerlink" title="远程端口转发"></a>远程端口转发</h2><p>既然”本地端口转发”是指绑定本地端口的转发，那么”远程端口转发”（remote forwarding）当然是指绑定远程端口的转发。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;今天需要使用ssh的时候发现居然不好使了，原来是自己在电脑上用了lantern之后，ip被改了，不在一个局域网内，无法访问非公网ip。（主要是根本ping不同目的主机= =）&lt;br&gt;于是打算借着机会好好的梳理一下ssh命令。&lt;/p&gt;
    
    </summary>
    
      <category term="网页开发" scheme="http://www.cvblogs.cn/categories/%E7%BD%91%E9%A1%B5%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Linux" scheme="http://www.cvblogs.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>metadata元数据</title>
    <link href="http://www.cvblogs.cn/2017/12/08/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/metadata%E5%85%83%E6%95%B0%E6%8D%AE/"/>
    <id>http://www.cvblogs.cn/2017/12/08/理论学习/metadata元数据/</id>
    <published>2017-12-08T11:00:26.000Z</published>
    <updated>2017-12-12T04:40:39.283Z</updated>
    
    <content type="html"><![CDATA[<h1 id="metadata-元数据"><a href="#metadata-元数据" class="headerlink" title="metadata 元数据"></a>metadata 元数据</h1><p>一直以来有一个困惑，为什么机器学习的数据集中经常会需要一个metadata的东西（也被叫做元数据）。实在是费解，于是今天忍不住百度了一下。算是解开了疑惑。<br>按照原文的意思，元数据应该被翻译做中间数据而不是元数据。这个翻译容易混淆视听。因此，元数据还有其它名称，中介数据，中继数据。</p><a id="more"></a><blockquote><p>注解：这里，我的直观感受是元数据相当于文件系统中的目录表。因为我们需要的数据太大了。如果只是一张表通过数据字典映射是表示不了的。因此将其再细分，也便于管理。（应该可以这么理解吧= =）这也就解释了为什么一些大的数据集都有一个metadata（是这样吧 = =）</p></blockquote><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="http://blog.csdn.net/l294265421/article/details/50539506" target="_blank" rel="noopener">通过metadata认识元数据</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;metadata-元数据&quot;&gt;&lt;a href=&quot;#metadata-元数据&quot; class=&quot;headerlink&quot; title=&quot;metadata 元数据&quot;&gt;&lt;/a&gt;metadata 元数据&lt;/h1&gt;&lt;p&gt;一直以来有一个困惑，为什么机器学习的数据集中经常会需要一个metadata的东西（也被叫做元数据）。实在是费解，于是今天忍不住百度了一下。算是解开了疑惑。&lt;br&gt;按照原文的意思，元数据应该被翻译做中间数据而不是元数据。这个翻译容易混淆视听。因此，元数据还有其它名称，中介数据，中继数据。&lt;/p&gt;
    
    </summary>
    
      <category term="图像处理" scheme="http://www.cvblogs.cn/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
    
      <category term="基础概念" scheme="http://www.cvblogs.cn/tags/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>Django之表单</title>
    <link href="http://www.cvblogs.cn/2017/12/08/%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/django_%E8%A1%A8%E5%8D%95/"/>
    <id>http://www.cvblogs.cn/2017/12/08/开发学习/django_表单/</id>
    <published>2017-12-08T10:15:18.000Z</published>
    <updated>2017-12-10T13:31:29.114Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>HTML表单是网站交互性的经典方式。有必要区别与表格Table。这两个，本质上有很大的差别。</p><a id="more"></a><blockquote><p>注解：<br>表格Table用于展示数据<br>表单Form则用于提交数据等</p></blockquote><h1 id="HTTP请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求"></a>HTTP请求</h1><p>HTTP协议以”请求－回复”的方式工作。客户发送请求时，<strong>可以在请求中附加数据</strong>。服务器通过解析请求，就可以获得客户传来的数据，并根据URL来提供特定的服务。</p><h2 id="GET-方法"><a href="#GET-方法" class="headerlink" title="GET 方法"></a>GET 方法</h2><p>创建一个 search.py 文件，用于接收用户的请求。记得一定要将自己定义的路由处理函数在<code>urls.py</code>中定义的正则路由对应起来。</p><blockquote><p>注解：此处将视图显示和请求处理分成两个函数处理。</p></blockquote><h2 id="POST-方法"><a href="#POST-方法" class="headerlink" title="POST 方法"></a>POST 方法</h2><p>提交数据时更常用POST方法。<br><strong>用一个URL和处理函数，同时显示视图和处理请求。</strong><br>注意：csrf 全称是 Cross Site Request Forgery。这是Django提供的防止伪装提交请求的功能。POST 方法提交的表格，必须有此标签。</p><h1 id="Request-对象"><a href="#Request-对象" class="headerlink" title="Request 对象"></a>Request 对象</h1><p><strong>每个<code>view</code> 函数的第一个参数是一个 <code>HttpRequest</code> 对象</strong><br>注意：不能使用语句if request.POST来判断是否使用HTTP POST方法；应该使用if request.method == “POST” 。</p><h1 id="QueryDict对象"><a href="#QueryDict对象" class="headerlink" title="QueryDict对象"></a>QueryDict对象</h1><p>在HttpRequest对象中, GET和POST属性是django.http.QueryDict类的实例。<br>QueryDict类似字典的自定义类，用来处理单键对应多值的情况。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;HTML表单是网站交互性的经典方式。有必要区别与表格Table。这两个，本质上有很大的差别。&lt;/p&gt;
    
    </summary>
    
      <category term="网页开发" scheme="http://www.cvblogs.cn/categories/%E7%BD%91%E9%A1%B5%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Django" scheme="http://www.cvblogs.cn/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>Django之数据库</title>
    <link href="http://www.cvblogs.cn/2017/12/08/%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/django%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://www.cvblogs.cn/2017/12/08/开发学习/django之数据库/</id>
    <published>2017-12-08T09:56:10.000Z</published>
    <updated>2017-12-10T13:20:47.385Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>关于在Django框架中如何使用数据库。</p><a id="more"></a><h1 id="数据库的使用"><a href="#数据库的使用" class="headerlink" title="数据库的使用"></a>数据库的使用</h1><h2 id="定义模型"><a href="#定义模型" class="headerlink" title="定义模型"></a>定义模型</h2><h3 id="创建-APP"><a href="#创建-APP" class="headerlink" title="创建 APP"></a>创建 APP</h3><p>Django规定，如果要使用模型，必须要创建一个app。修改对应App目录下的<code>models.py</code>文件。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># models.py</span></div><div class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</div><div class="line"> </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span><span class="params">(models.Model)</span>:</span></div><div class="line">    name = models.CharField(max_length=<span class="number">20</span>)</div></pre></td></tr></table></figure></p><blockquote><p>注解：类名代表了数据库表名，继承了<code>models.Model</code>。<br>类里面的字段代表数据表中的字段(name)<br>数据类型则由CharField（相当于varchar）、DateField（相当于datetime）<br>max_length 参数限定长度。</p></blockquote><h3 id="在命令行中运行"><a href="#在命令行中运行" class="headerlink" title="在命令行中运行"></a>在命令行中运行</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">python manage.py migrate   <span class="comment"># 创建表结构</span></div><div class="line">python manage.py makemigrations TestModel  <span class="comment"># 让 Django 知道我们在我们的模型有一些变更</span></div><div class="line">python manage.py migrate TestModel   <span class="comment"># 创建表结构</span></div></pre></td></tr></table></figure><p>表名组成结构为：<strong>应用名_类名</strong>（如：<code>TestModel_test</code>）。</p><p><strong> 注意：尽管我们没有在models给表设置主键，但是Django会自动添加一个id作为主键。</strong></p><h2 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h2><p>在 HelloWorld(所创建的App)目录中添加 testdb.py 文件（下面介绍），并修改 urls.py</p><blockquote><p>注解：此处只要在对应App目录下创建好操作数据库的文件，以及在urls.py中处理好对应的路由转发规则即可。并不强制要求一定是这样。但是路由的映射一定要对应上。</p></blockquote><h3 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h3><p>添加数据需要先创建对象，然后再执行 save 函数，相当于SQL中的<code>INSERT</code><br><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div><div class="line"> </div><div class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse    <span class="comment">#因为是处理客户端http请求，因此需要引入该模块</span></div><div class="line"> </div><div class="line"><span class="keyword">from</span> TestModel.models <span class="keyword">import</span> Test    <span class="comment">#该模块中定义了我们的表结构（模型），可以理解为是一个类（自定义的数据类型）</span></div><div class="line"> </div><div class="line"><span class="comment"># 数据库操作</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">testdb</span><span class="params">(request)</span>:</span>    <span class="comment">#此处对应urls.py中的路由处理函数，一定要对应上</span></div><div class="line">    test1 = Test(name=<span class="string">'runoob'</span>)    <span class="comment">#创建了一个实例对象</span></div><div class="line">    test1.save()    <span class="comment">#将实例对象保存（可以看作是SQL中的INSERT操作）</span></div><div class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">"&lt;p&gt;数据添加成功！&lt;/p&gt;"</span>)    <span class="comment">#如只是用HttpResponse则无需在参数中添加request。如果是render等则需要带上</span></div></pre></td></tr></table></figure></p><h3 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h3><p>通过objects这个模型管理器来进行完成对应的操作<br>all()获得所有数据行，相当于SQL中的SELECT * FROM<br>filter相当于SQL中的WHERE，可设置条件过滤结果<br>objects.get(id=1)获取单个对象<br>objects.order_by(‘name’)[0:2]限制返回的数据 相当于 SQL 中的 OFFSET 0 LIMIT 2;<br>objects.order_by(“id”)数据排序<br>上面的方法可以连锁使用</p><h3 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h3><p>修改数据可以使用 save() 或 update()</p><blockquote><p>save()和update都得针对已经有的数据进行操作</p></blockquote><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><p>删除数据库中的对象只需调用该对象的delete()方法即可</p><h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>Django中的数据库操作还是挺简单的，但是封装感觉会是一个问题，单纯的利用框架提供的这个似乎解耦等不会很好，有待继续学习。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="http://www.runoob.com/django/django-model.html" target="_blank" rel="noopener">http://www.runoob.com/django/django-model.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;关于在Django框架中如何使用数据库。&lt;/p&gt;
    
    </summary>
    
      <category term="网页开发" scheme="http://www.cvblogs.cn/categories/%E7%BD%91%E9%A1%B5%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Django" scheme="http://www.cvblogs.cn/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>python之数据结构</title>
    <link href="http://www.cvblogs.cn/2017/12/08/%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/python_python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://www.cvblogs.cn/2017/12/08/开发学习/python_python数据结构/</id>
    <published>2017-12-08T09:26:06.000Z</published>
    <updated>2017-12-12T04:41:50.627Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本章是关于python中基本数据结构知识的一些梳理。</p><a id="more"></a><h1 id="Python-列表-List"><a href="#Python-列表-List" class="headerlink" title="Python 列表(List)"></a>Python 列表(List)</h1><blockquote><p>可以这么说是，用<code>[</code>与<code>]</code>将元素圈起来- -</p></blockquote><p>序列中的每个元素都分配一个数字 - 它的位置，或索引，第一个索引是0，第二个索引是1，依此类推。<br>Python有6个序列的内置类型，但最常见的是列表和元组。<br>序列都可以进行的操作包括索引，切片，<strong>加</strong>，<strong>乘</strong>，<strong>检查成员</strong>。<br>Python已经内置确定序列的长度以及确定最大和最小的元素的方法。</p><p>列表是最常用的Python数据类型，它可以作为<strong>一个方括号内的逗号分隔值出现</strong>。<br>创建一个列表，只要把逗号分隔的不同的数据项使用方括号括起来即可。与字符串的索引一样，列表索引从0开始。列表可以进行截取、组合等。</p><h2 id="删除列表元素"><a href="#删除列表元素" class="headerlink" title="删除列表元素"></a>删除列表元素</h2><p><code>del</code>语句来删除列表的的元素。</p><h2 id="Python列表脚本操作符"><a href="#Python列表脚本操作符" class="headerlink" title="Python列表脚本操作符"></a>Python列表脚本操作符</h2><p>列表对 + 和 <em> 的操作符与字符串相似。+ 号用于组合列表，</em> 号用于重复列表。</p><h1 id="Python-元祖-Tuple"><a href="#Python-元祖-Tuple" class="headerlink" title="Python 元祖(Tuple)"></a>Python 元祖(Tuple)</h1><p><strong>元组与列表类似，不同之处在于元组的元素不能修改。</strong><br><strong>元组使用小括号，列表使用方括号。</strong><br>元组创建很简单，只需要在括号中添加元素，并使用逗号隔开即可。<br><strong>元组中只包含一个元素时，需要在元素后面添加逗号</strong><br>元组与字符串类似，下标索引从0开始，可以进行截取，组合等。<br>将列表转换为元组:<strong>tuple(seq)</strong></p><h1 id="Python-字典-Dictionary"><a href="#Python-字典-Dictionary" class="headerlink" title="Python 字典(Dictionary)"></a>Python 字典(Dictionary)</h1><p>字典是另一种可变容器模型，且可存储任意类型对象。<br>字典的每个键值(key=&gt;value)对用冒号(:)分割，每个对之间用逗号(,)分割，整个字典包括在花括号({})中。键必须是唯一的，但值则不必。键必须是不可变的，如字符串，数字或元组。</p><h2 id="删除字典元素"><a href="#删除字典元素" class="headerlink" title="删除字典元素"></a>删除字典元素</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">del</span> dict[<span class="string">'Name'</span>]; <span class="comment"># 删除键是'Name'的条目</span></div><div class="line">dict.clear();     <span class="comment"># 清空词典所有条目</span></div><div class="line"><span class="keyword">del</span> dict ;        <span class="comment"># 删除词典</span></div></pre></td></tr></table></figure><h2 id="字典键的特性"><a href="#字典键的特性" class="headerlink" title="字典键的特性"></a>字典键的特性</h2><p>字典值可以没有限制地取任何<code>python</code>对象，既可以是标准的对象，也可以是用户定义的，但键不行。</p><ol><li>不允许同一个键出现两次。创建时如果同一个键被赋值两次，后一个值会被记住。</li><li>键必须不可变，所以可以用数字，字符串或元组充当，所以用列表就不行。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本章是关于python中基本数据结构知识的一些梳理。&lt;/p&gt;
    
    </summary>
    
      <category term="网页开发" scheme="http://www.cvblogs.cn/categories/%E7%BD%91%E9%A1%B5%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Python" scheme="http://www.cvblogs.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>python之读取数据的方式</title>
    <link href="http://www.cvblogs.cn/2017/12/08/%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/python_python%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE%E7%9A%84%E6%96%B9%E5%BC%8F/"/>
    <id>http://www.cvblogs.cn/2017/12/08/开发学习/python_python读取数据的方式/</id>
    <published>2017-12-08T09:01:01.000Z</published>
    <updated>2017-12-12T04:42:05.586Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python读取数据的方式"><a href="#Python读取数据的方式" class="headerlink" title="Python读取数据的方式"></a>Python读取数据的方式</h1><p>在文本处理的过程中，将文件加载内存中是第一步，这就涉及到<strong>怎样将文件中的某一列映射到具体的变量的过程</strong>。<br>推荐两种优雅的方式来读取数据，都是先配置字段模式，然后按照模式读取，而模式则有字典模式和列表模式两种形式；</p><a id="more"></a><h2 id="读取文件，按照分隔符分割成字段数据列表"><a href="#读取文件，按照分隔符分割成字段数据列表" class="headerlink" title="读取文件，按照分隔符分割成字段数据列表"></a>读取文件，按照分隔符分割成字段<code>数据列表</code></h2><p>使用<code>yield</code>关键字，每次抛出单个行的分割数据，这样在调度程序中可以用<code>for fields in read_file_data(fpath)</code>的方式读取每一行。</p><h3 id="使用配置好的字典模式，装配读取的数据列表"><a href="#使用配置好的字典模式，装配读取的数据列表" class="headerlink" title="使用配置好的字典模式，装配读取的数据列表"></a>使用配置好的<code>字典模式</code>，装配读取的数据列表</h3><p>这种方法配置一个{“字段名”: 字段位置}的字典作为数据模式，然后按照该模式装配读取的列表数据，最后实现用字典的方式访问数据。</p><h3 id="使用配置好的列表模式，装配读取的数据列表"><a href="#使用配置好的列表模式，装配读取的数据列表" class="headerlink" title="使用配置好的列表模式，装配读取的数据列表"></a>使用配置好的<code>列表模式</code>，装配读取的数据列表</h3><p>如果需要读取文件所有列，或者前面的一些列，那么配置字典模式优点复杂，因为需要给每个字段配置索引位置，并且这些位置是从0开始完后数的，属于低级劳动，需要消灭。</p><h2 id="按列表模式读"><a href="#按列表模式读" class="headerlink" title="按列表模式读"></a>按<code>列表模式</code>读</h2><p>列表模式应命运而生，先将配置好的列表模式转换成字典模式，然后按字典加载就可以实现。<br>使用的时候，可以用列表的形式配置模式，不需要配置索引更加简洁</p><h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><blockquote><p>尚未理解透彻数据处理中的<code>字典模式</code>与<code>列表模式</code>。</p></blockquote><h1 id="引用链接"><a href="#引用链接" class="headerlink" title="引用链接"></a>引用链接</h1><p><a href="http://www.crazyant.net/1707.html" target="_blank" rel="noopener">Python使用list字段模式或者dict字段模式读取文件的方法</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python读取数据的方式&quot;&gt;&lt;a href=&quot;#Python读取数据的方式&quot; class=&quot;headerlink&quot; title=&quot;Python读取数据的方式&quot;&gt;&lt;/a&gt;Python读取数据的方式&lt;/h1&gt;&lt;p&gt;在文本处理的过程中，将文件加载内存中是第一步，这就涉及到&lt;strong&gt;怎样将文件中的某一列映射到具体的变量的过程&lt;/strong&gt;。&lt;br&gt;推荐两种优雅的方式来读取数据，都是先配置字段模式，然后按照模式读取，而模式则有字典模式和列表模式两种形式；&lt;/p&gt;
    
    </summary>
    
      <category term="网页开发" scheme="http://www.cvblogs.cn/categories/%E7%BD%91%E9%A1%B5%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Python" scheme="http://www.cvblogs.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>linux之软链接与硬链接</title>
    <link href="http://www.cvblogs.cn/2017/12/08/%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/linux_%E8%BD%AF%E9%93%BE%E6%8E%A5%E4%B8%8E%E7%A1%AC%E9%93%BE%E6%8E%A5/"/>
    <id>http://www.cvblogs.cn/2017/12/08/开发学习/linux_软链接与硬链接/</id>
    <published>2017-12-08T07:18:22.000Z</published>
    <updated>2017-12-10T12:56:53.806Z</updated>
    
    <content type="html"><![CDATA[<h1 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h1><p>称之为符号连接（Symbolic Link）。类似于Windows的快捷方式，在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。</p><a id="more"></a><blockquote><p>注解：此处说的一个文本文件包含另一文件的位置信息，可以将其看作指针。因此每次打开软链接的文件都会定位到源文件目录所在的位置。</p></blockquote><p>软链接的缺点在于：因为链接文件包含有原文件的路径信息，所以当原文件从一个目录下移到其他目录中，再访问链接文件，系统就找不到了，而硬链接就没有这个缺陷，你想怎么移就怎么移；还有它要系统分配额外的空间用于建立新的索引节点和保存原文件的路径。</p><h1 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h1><p>通过索引节点来进行连接。保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Index)。允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。<br>只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。</p><blockquote><p>注解：好比C++中，为一个内存区域创建了多个别名。</p></blockquote><!-- more --><h2 id="硬链接文件有两个限制"><a href="#硬链接文件有两个限制" class="headerlink" title="硬链接文件有两个限制"></a>硬链接文件有两个限制</h2><ol><li>不允许给目录创建硬链接；</li><li>只有在同一文件系统中的文件之间才能创建链接，而且只有超级用户才有建立硬链接权限。<blockquote><p>对硬链接文件进行读写和删除操作时候，结果和软链接相同。但如果我们删除硬链接文件的源文件，硬链接文件仍然存在，而且保留了愿有的内容。</p></blockquote></li></ol><p>软链接没有硬链接以上的两个限制，因而现在更为广泛使用，它具有更大的灵活性，甚至可以跨越不同机器、不同网络对文件进行链接。</p><h1 id="创建命令"><a href="#创建命令" class="headerlink" title="创建命令"></a>创建命令</h1><p><code>ln -s</code>创建软链接</p><p><code>ln</code>创建硬链接</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://www.cnblogs.com/kex1n/p/5193826.html" target="_blank" rel="noopener">linux 创建连接命令 ln -s 软链接</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;软链接&quot;&gt;&lt;a href=&quot;#软链接&quot; class=&quot;headerlink&quot; title=&quot;软链接&quot;&gt;&lt;/a&gt;软链接&lt;/h1&gt;&lt;p&gt;称之为符号连接（Symbolic Link）。类似于Windows的快捷方式，在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。&lt;/p&gt;
    
    </summary>
    
      <category term="网页开发" scheme="http://www.cvblogs.cn/categories/%E7%BD%91%E9%A1%B5%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Linux" scheme="http://www.cvblogs.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>python之编码规范笔记</title>
    <link href="http://www.cvblogs.cn/2017/12/08/%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/python_%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    <id>http://www.cvblogs.cn/2017/12/08/开发学习/python_编码规范/</id>
    <published>2017-12-08T05:21:01.000Z</published>
    <updated>2017-12-12T04:43:44.241Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>主要是python中基础结构及对应容易被我忘记的编码建议的笔记梳理。</p><a id="more"></a><h1 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h1><ol><li>模块：小写、可以有下划线</li><li>包：小写、无下划线</li><li>类：<code>CapWords</code>(驼峰式命名)</li><li>函数命名：小写，可以有下划线</li><li>常量命名：大写，可以有下划线</li><li>类的属性：小写，前缀下划线</li><li>类的方法第一个参数必须是<code>self</code>，静态方法第一个参数必须是<code>cls</code></li></ol><h1 id="编码建议"><a href="#编码建议" class="headerlink" title="编码建议"></a>编码建议</h1><ol><li>尽可能使用<code>‘is’</code>,<code>‘is not’</code>取代<code>‘==’</code>，比如<code>if x is not None</code> 要优于<code>if x</code>。</li><li>使用<code>isinstance()</code>比较对象的类型</li><li>使用<code>startswith()</code> and <code>endswith()</code>代替切片进行序列前缀或后缀的检查</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;主要是python中基础结构及对应容易被我忘记的编码建议的笔记梳理。&lt;/p&gt;
    
    </summary>
    
      <category term="网页开发" scheme="http://www.cvblogs.cn/categories/%E7%BD%91%E9%A1%B5%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Python" scheme="http://www.cvblogs.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>git利用https无法push解决方法</title>
    <link href="http://www.cvblogs.cn/2017/12/08/%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/git%E7%9A%84https%E6%97%A0%E6%B3%95push%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>http://www.cvblogs.cn/2017/12/08/开发学习/git的https无法push解决方法/</id>
    <published>2017-12-08T02:22:26.000Z</published>
    <updated>2017-12-12T04:44:27.656Z</updated>
    
    <content type="html"><![CDATA[<h4 id="错误信息：fatal-Unable-to-find-remote-helper-for-39-https-39"><a href="#错误信息：fatal-Unable-to-find-remote-helper-for-39-https-39" class="headerlink" title="错误信息：fatal: Unable to find remote helper for &#39;https&#39;"></a>错误信息：<code>fatal: Unable to find remote helper for &#39;https&#39;</code></h4><p>昨天想要提交代码的时候，死活无法<code>push</code>，稍晚的时候才想起来原来是自己太着急了，代码都没有<code>commit</code>，那么何谈<code>push</code>呢。</p><a id="more"></a><blockquote><p>切记本地与远端的区别。远端只需要将它看作是一个存储数据作备份的地方。真正的内容其实是需要在本地完成的。而<code>git</code>这个工具的本质就是，先<code>add</code>修改（如果是对已有文件作修改则只需要用<code>commit -am</code>提交修改信息。<code>git</code>会保存所有的提交版本记录。）</p></blockquote><p>另外，由于用<code>conda</code>进入了虚拟环境，导致<code>push</code>的时候依旧报错。报错信息是<code>fatal: Unable to find remote helper for &#39;https&#39;</code>。上网查找的时候说是我没有安装<code>curl</code>等（但是其实根据一个正常工作的<code>git config --list</code>信息对比，我的<code>git</code>及<code>curl</code>是可以正常用的）。</p><blockquote><p>最后，其实是因为我进入了<code>conda</code>的环境。退出来虚拟环境，就可以正常提交了。</p></blockquote><h4 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h4><p>还是环境变量的问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;错误信息：fatal-Unable-to-find-remote-helper-for-39-https-39&quot;&gt;&lt;a href=&quot;#错误信息：fatal-Unable-to-find-remote-helper-for-39-https-39&quot; class=&quot;headerlink&quot; title=&quot;错误信息：fatal: Unable to find remote helper for &amp;#39;https&amp;#39;&quot;&gt;&lt;/a&gt;错误信息：&lt;code&gt;fatal: Unable to find remote helper for &amp;#39;https&amp;#39;&lt;/code&gt;&lt;/h4&gt;&lt;p&gt;昨天想要提交代码的时候，死活无法&lt;code&gt;push&lt;/code&gt;，稍晚的时候才想起来原来是自己太着急了，代码都没有&lt;code&gt;commit&lt;/code&gt;，那么何谈&lt;code&gt;push&lt;/code&gt;呢。&lt;/p&gt;
    
    </summary>
    
      <category term="网页开发" scheme="http://www.cvblogs.cn/categories/%E7%BD%91%E9%A1%B5%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="测试" scheme="http://www.cvblogs.cn/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Django之基础概念学习</title>
    <link href="http://www.cvblogs.cn/2017/12/07/%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/django_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E5%AD%A6%E4%B9%A0/"/>
    <id>http://www.cvblogs.cn/2017/12/07/开发学习/django_基础概念学习/</id>
    <published>2017-12-07T04:47:10.000Z</published>
    <updated>2017-12-12T04:44:45.655Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近需要学习Django框架。笔记备忘。其实学习一个框架，莫过于自己动手从零开始搭建。亲身去体会这个框架。这样学习才能事半功倍。神奇的发现hexo的文件里不可以有那个跨站点的token标签= =</p><a id="more"></a><h1 id="引用链接"><a href="#引用链接" class="headerlink" title="引用链接"></a>引用链接</h1><p><a href="https://www.cnblogs.com/feixuelove1009/p/5823135.html" target="_blank" rel="noopener">https://www.cnblogs.com/feixuelove1009/p/5823135.html</a><br><a href="http://www.runoob.com/django/django-first-app.html" target="_blank" rel="noopener">http://www.runoob.com/django/django-first-app.html</a></p><h1 id="Web框架介绍"><a href="#Web框架介绍" class="headerlink" title="Web框架介绍"></a>Web框架介绍</h1><p><img src="http://images2015.cnblogs.com/blog/948404/201608/948404-20160830212049246-1153317231.jpg" alt="一般的web框架"><br>其它基于python的web框架，如tornado、flask、webpy都是在这个范围内进行增删裁剪的。例如tornado用的是自己的异步非阻塞“wsgi”，flask则只提供了最精简和基本的框架。Django则是直接使用了WSGI，并实现了大部分功能</p><h1 id="MVC-MTV介绍"><a href="#MVC-MTV介绍" class="headerlink" title="MVC/MTV介绍"></a>MVC/MTV介绍</h1><p>模型(model)：定义数据库相关的内容，一般放在models.py文件中。<br>视图(view)：定义HTML等静态网页文件相关，也就是那些html、css、js等前端的东西。<br>控制器(controller)：定义业务逻辑相关，就是你的主要代码。<br>MTV: 有些WEB框架觉得MVC的字面意思很别扭，就给它改了一下。view不再是HTML相关，而是主业务逻辑了，相当于控制器。html被放在Templates中，称作模板，于是MVC就变成了MTV。这其实就是一个文字游戏，和MVC本质上是一样的，换了个名字和叫法而已，换汤不换药。</p><h1 id="Django模型组织"><a href="#Django模型组织" class="headerlink" title="Django模型组织"></a>Django模型组织</h1><p><img src="http://images2015.cnblogs.com/blog/948404/201609/948404-20160903111840215-2065765780.jpg" alt="Django模型组织"></p><h2 id="我们学Django学的是什么？"><a href="#我们学Django学的是什么？" class="headerlink" title="我们学Django学的是什么？"></a>我们学Django学的是什么？</h2><ol><li><p>目录结构规范</p></li><li><p>urls路由方式</p></li><li><p>settings配置</p></li><li><p>ORM操作</p></li><li><p>模板渲染</p></li><li><p>其它</p></li></ol><h1 id="Django项目目录结构"><a href="#Django项目目录结构" class="headerlink" title="Django项目目录结构"></a>Django项目目录结构</h1><p><img src="./xiaogu_django项目结构.png" alt="xiaogu_django项目结构.png"><br><img src="http://images2015.cnblogs.com/blog/948404/201608/948404-20160830222155746-982749621.png" alt="目录结构"><br><strong>所有的APP共享项目资源</strong><br>在每个django项目中可以包含多个APP，相当于一个大型项目中的分系统、子模块、功能部件等等，相互之间比较独立，但也有联系。<br><strong>编写路由</strong><br>路由都在urls.py文件里，它将浏览器输入的url映射到相应的业务处理逻辑</p><blockquote><p>此处尚未理解透彻</p></blockquote><p><strong>业务处理逻辑</strong><br>业务处理逻辑都在views.py文件里。通过上面两个步骤，我们将urls.py中的index这个url指向了views.py里的index（）函数，它接收用户请求request，并返回一个“hello world”字符串。实际上这肯定不行，通常我们都是将html文件返回给用户。</p><p><strong>返回HTML文件</strong><br>写这么一个index.html文件,再修改一下views文件。为了让django知道我们的html文件在哪里，需要修改settings.py文件的相应内容。但默认情况下，它正好适用，你无需修改。</p><blockquote><p>注：这里有个小技巧，在多次频繁重启服务时，由于端口未释放的原因，容易启动不了服务，修改一下端口就OK了。</p></blockquote><p><strong>使用静态文件</strong><br>我们已经可以将html文件返还给用户了，但是还不够，前端三大块，html、css、js还有各种插件，它们齐全才是一个完整的页面。<br>在django中，一般将静态文件放在static目录中。你的CSS,JS和各种插件都可以放置在这个目录里。为了让django找到这个目录，依然需要对settings进行配置。<br>同样，在index.html文件中，可以引入js文件了。</p><p><strong>接收用户发送的数据</strong><br>我们将一个要素齐全的html文件返还给了用户浏览器。但这还不够，因为web服务器和用户之间没有动态交互。</p><p>下面我们设计一个表单，让用户输入用户名和密码，提交给index这个url，服务器将接收到这些数据。<br><strong>注意：跨站保护机制</strong><br>django有一个csrf跨站请求保护机制，我们暂时在settings文件中将它关闭，或者在form表单里添加一个标签。</p><p><strong>返回动态页面</strong><br>我们收到了用户的数据，但返回给用户的依然是个静态页面，通常我们会根据用户的数据，进行处理后在返回给用户。</p><p>这时候，django采用自己的模板语言，类似jinja2，根据提供的数据，替换掉html中的相应部分，详细语法入门后再深入学习</p><p><strong>使用数据库</strong><br>流程走到这里，django的MTV框架基本已经浮出水面了，只剩下最后的数据库部分了。<br>django通过自带的ORM框架操作数据库，并且自带轻量级的sqlite3数据库。</p><ol><li>在settings.py里注册你的app(不注册它，你的数据库就不知道该给哪个app创建表)</li><li>然后我们在settings中，配置数据库相关的参数，如果使用自带的sqlite，不需要修改。</li><li>再编辑models.py文件，也就是MTV中的M。</li><li><p>接下来要在pycharm的teminal中通过命令创建数据库的表</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">python manage.py makemigrations</div><div class="line">python manage.py migrate</div></pre></td></tr></table></figure></li><li><p>修改views.py中的业务逻辑</p></li><li>重启web服务后，刷新浏览器页面，之后和用户交互的数据都能保存到数据库中。任何时候都可以从数据库中读取数据，展示到页面上。</li></ol><h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>关于学习方法的建议：学习任何东西，不要直接扎入细节，应该先了解它的外围知识，看看它的整体架构，再学习它的基本内容，然后才是深入学习，打磨技巧！</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近需要学习Django框架。笔记备忘。其实学习一个框架，莫过于自己动手从零开始搭建。亲身去体会这个框架。这样学习才能事半功倍。神奇的发现hexo的文件里不可以有那个跨站点的token标签= =&lt;/p&gt;
    
    </summary>
    
      <category term="网页开发" scheme="http://www.cvblogs.cn/categories/%E7%BD%91%E9%A1%B5%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Django" scheme="http://www.cvblogs.cn/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>深度学习框架</title>
    <link href="http://www.cvblogs.cn/2017/12/05/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/"/>
    <id>http://www.cvblogs.cn/2017/12/05/理论学习/深度学习框架/</id>
    <published>2017-12-05T02:57:10.000Z</published>
    <updated>2017-12-10T12:55:52.794Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PyTorch"><a href="#PyTorch" class="headerlink" title="PyTorch"></a>PyTorch</h1><p><code>PyTorch</code>准备数据有很多灵活的方式，在最后能够将数据转为<code>Numpy</code>数组即可，通过<code>Numpy</code>数据可以转化为<code>PyTorch</code>所需的<code>Tensor</code>。</p><ul><li>对于图像数据，可以直接通过opencv，Pillow等做处理；</li><li>语音数据可以通过scipy和librosa来处理成numpy；</li><li>文本数据可以通过CNTK之类的自然语言处理库处理成numpy数组。<a id="more"></a><h1 id="SKImage"><a href="#SKImage" class="headerlink" title="SKImage"></a>SKImage</h1>| 子模块名称        | 主要实现功能                           |<br>| ———— | ——————————– |<br>| io           | 读取、保存和显示图片或视频                    |<br>| data         | 提供一些测试图片和样本数据                    |<br>| color        | 颜色空间变换                           |<br>| filters      | 图像增强、边缘检测、排序滤波器、自动阈值等            |<br>| draw         | 操作于numpy数组上的基本图形绘制，包括线条、矩形、圆和文本等 |<br>| transform    | 几何变换或其它变换，如旋转、拉伸和拉东变换等           |<br>| morphology   | 形态学操作，如开闭运算、骨架提取等                |<br>| exposure     | 图片强度调整，如亮度调整、直方图均衡等              |<br>| feature      | 特征检测与提取等                         |<br>| measure      | 图像属性的测量，如相似性或等高线等                |<br>| segmentation | 图像分割                             |<br>| restoration  | 图像恢复                             |<br>| util         | 通用函数                             |</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;PyTorch&quot;&gt;&lt;a href=&quot;#PyTorch&quot; class=&quot;headerlink&quot; title=&quot;PyTorch&quot;&gt;&lt;/a&gt;PyTorch&lt;/h1&gt;&lt;p&gt;&lt;code&gt;PyTorch&lt;/code&gt;准备数据有很多灵活的方式，在最后能够将数据转为&lt;code&gt;Numpy&lt;/code&gt;数组即可，通过&lt;code&gt;Numpy&lt;/code&gt;数据可以转化为&lt;code&gt;PyTorch&lt;/code&gt;所需的&lt;code&gt;Tensor&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于图像数据，可以直接通过opencv，Pillow等做处理；&lt;/li&gt;
&lt;li&gt;语音数据可以通过scipy和librosa来处理成numpy；&lt;/li&gt;
&lt;li&gt;文本数据可以通过CNTK之类的自然语言处理库处理成numpy数组。
    
    </summary>
    
      <category term="深度学习" scheme="http://www.cvblogs.cn/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="基础概念" scheme="http://www.cvblogs.cn/tags/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>计算架构之CPU与GPU</title>
    <link href="http://www.cvblogs.cn/2017/11/29/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9E%B6%E6%9E%84%E4%B9%8BCPU%E4%B8%8EGPU/"/>
    <id>http://www.cvblogs.cn/2017/11/29/理论学习/计算架构之CPU与GPU/</id>
    <published>2017-11-29T09:38:10.000Z</published>
    <updated>2017-12-10T13:12:50.244Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>日益复杂的3D图形图像时就会常常出现显卡等待CPU数据的情况</p><a id="more"></a><h1 id="CUDA介绍"><a href="#CUDA介绍" class="headerlink" title="CUDA介绍"></a>CUDA介绍</h1><p>CUDA是计算统一设备构架（Compute Unified Device Architecture）的缩写。<br>CUDA和GPU之间的关系十分重要。<br>CUDA在编程基础上实现GPU的性能。<br>CUDA：软件<br>GPU：硬件</p><h1 id="发展历程"><a href="#发展历程" class="headerlink" title="发展历程"></a>发展历程</h1><p>GPGPU-&gt;CUDA-&gt;GPU</p><h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>CUDA只是一种并行计算架构，相关的概念还有OpenCL、OpenMP等</p><h1 id="SSL-Semi-Supervised-Learning"><a href="#SSL-Semi-Supervised-Learning" class="headerlink" title="SSL:Semi-Supervised Learning"></a>SSL:Semi-Supervised Learning</h1><ol><li>期望最大算法(Expectation Maximum，EM)</li><li>高斯混合模型(Gaussian Mixture Model，GMM)</li><li>最小割法(Mincut):首次将图论应用于解决SSL问题</li><li>调和函数法(Harmonic Function)将预测函数从离散形式扩展到连续形式</li><li>流形正则化法(Manifold Regularization)将流形学习的思想用于SSL场景</li><li>用于聚类的半监督距离度量学习方法，学习一种距离度量。</li><li>将EM和朴素贝叶斯结合，通过引入加权系数动态调整无类标签的样例的影响提高了分类准确度，建立每类中具有多个混合部分的模型，使贝叶斯偏差减小。</li><li>协同训练改进算法，不需要充分冗余的视图，而利用两个不同类型的分类器来完成学习</li><li>同时解决有类标签样本稀疏和具有附加无类标签样例成对约束的问题</li></ol><h1 id="三个常用基本假设"><a href="#三个常用基本假设" class="headerlink" title="三个常用基本假设"></a>三个常用基本假设</h1><p>基于一个事实：未标记样本虽未直接包含标记信息，但若它们与有标记信息样本是从同样的数据源独立同分布采样而来，则它们所包含的关于数据分布的信息对建立模型是有帮助的。<br>利用好未标记样本来提升模型泛化能力，就是半监督学习研究的重点。<br>在半监督学习中有三个常用的基本假设来建立预测样例和学习目标之间的关系：<br>（1）平滑假设(Smoothness Assumption)：位于稠密数据区域的两个距离很近的样例的类标签相似，也就是说，当两个样例被稠密数据区域中的边连接时，它们在很大的概率下有相同的类标签；相反地，当两个样例被稀疏数据区域分开时，它们的类标签趋于不同。<br>（2）聚类假设(Cluster Assumption)：当两个样例位于同一聚类簇时，它们在很大的概率下有相同的类标签。这个假设的等价定义为低密度分离假设(Low Sensity Separation Assumption)，即分类决策边界应该穿过稀疏数据区域，而避免将稠密数据区域的样例分到决策边界两侧。<br>（3）流形假设(Manifold Assumption)：将高维数据嵌入到低维流形中，当两个样例位于低维流形中的一个小局部邻域内时，它们具有相似的类标签。</p><h1 id="四大类学习场景"><a href="#四大类学习场景" class="headerlink" title="四大类学习场景"></a>四大类学习场景</h1><p>半监督学习可进一步划分为纯(pure)半监督学习和直推学习（transductive learning）：纯半监督学习假定训练数据中的未标记样本并非待预测数据；而直推学习假定学习过程中所考虑的未标记样本恰是待预测数据，学习的目的就是在未标记样本上获得最优泛化性能。<br>纯半监督学习是基于开放世界的假设，希望学得的模型能适用于训练过程中未观察到的数据；而直推学习是基于封闭世界假设，仅试图对学习过程中观察到的未标记数据进行预测。<br>从不同的学习场景看，SSL可分为四大类：</p><h2 id="半监督分类"><a href="#半监督分类" class="headerlink" title="半监督分类"></a>半监督分类</h2><p>半监督分类(Semi-Supervised Classification)：是在无类标签的样例的帮助下训练有类标签的样本，获得比只用有类标签的样本训练得到的分类器性能更优的分类器，弥补有类标签的样本不足的缺陷，其中类标签yi取<strong>有限离散值</strong>。</p><h2 id="半监督回归"><a href="#半监督回归" class="headerlink" title="半监督回归"></a>半监督回归</h2><p>半监督回归(Semi-Supervised Regression)：在无输出的输入的帮助下训练有输出的输入，获得比只用有输出的输入训练得到的回归器性能更好的回归器，其中输出yi取<strong>连续值</strong>；</p><h2 id="半监督聚类"><a href="#半监督聚类" class="headerlink" title="半监督聚类"></a>半监督聚类</h2><p>半监督聚类(Semi-Supervised Clustering)：在有类标签的样本的信息帮助下获得比只用无类标签的样例得到的结果更好的簇，提高聚类方法的精度；</p><h2 id="半监督降维"><a href="#半监督降维" class="headerlink" title="半监督降维"></a>半监督降维</h2><p>半监督降维(Semi-Supervised Dimensionality Reduction)：在有类标签的样本的信息帮助下找到高维输入数据的低维结构，同时保持原始高维数据和成对约束(Pair-Wise Constraints)的结构不变，即在高维空间中满足正约束(Must-Link Constraints)的样例在低维空间中相距很近，在高维空间中满足负约束(Cannot-Link Constraints)的样例在低维空间中距离很远。</p><h1 id="未来的研究方向包括以下一些内容"><a href="#未来的研究方向包括以下一些内容" class="headerlink" title="未来的研究方向包括以下一些内容"></a>未来的研究方向包括以下一些内容</h1><h3 id="理论分析"><a href="#理论分析" class="headerlink" title="理论分析"></a>理论分析</h3><h3 id="抗干扰性与可靠性"><a href="#抗干扰性与可靠性" class="headerlink" title="抗干扰性与可靠性"></a>抗干扰性与可靠性</h3><h3 id="训练样例与参数的选取"><a href="#训练样例与参数的选取" class="headerlink" title="训练样例与参数的选取"></a>训练样例与参数的选取</h3><h3 id="优化求解"><a href="#优化求解" class="headerlink" title="优化求解"></a>优化求解</h3><p>从各种SSL算法的实现过程可以看出，SSL问题大多为非凸、非平滑问题，或整数规划和组合优化问题，存在多个局部最优解，例如求解SSL产生式方法目标函数的EM算法只能得到局部极大值目前主要采用各种放松方法把目标函数近似转化为凸或连续最优化问题，不易得到全局最优解，算法的时空复杂性很高，问题的求解依赖于最优化理论的突破，未来需要研究新的算法求解全局最优解。</p><h3 id="研究拓展"><a href="#研究拓展" class="headerlink" title="研究拓展"></a>研究拓展</h3><p>SSL从产生以来，主要用于实验室中处理人工合成数据，未来的研究一方而需要讨论SSL可以显著提高哪些学习任务的性能，拓展SSL在现实领域的实际应用，另一方而需要制定出一个统一的令人信服的SSL方法的使用规程。此外，目前有许多的半监督分类方法，而对半监督回归问题的研究比较有限。未来有待继续研究半监督分类和半监督回归之间的关系，并提出其他半监督回归方法。</p><h1 id="Active-Learning-主动学习"><a href="#Active-Learning-主动学习" class="headerlink" title="Active Learning:主动学习"></a>Active Learning:主动学习</h1><p>主动学习就是要引入专家知识，通过与外部交互来将部分未标记样本转变为有标记样本。如果不通过外部标记，还可以利用未标记样本，就是半监督学习的研发范围</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;日益复杂的3D图形图像时就会常常出现显卡等待CPU数据的情况&lt;/p&gt;
    
    </summary>
    
      <category term="深度学习" scheme="http://www.cvblogs.cn/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="基础概念" scheme="http://www.cvblogs.cn/tags/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>web开发之内存泄漏</title>
    <link href="http://www.cvblogs.cn/2017/11/12/%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/web%E5%BC%80%E5%8F%91_%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    <id>http://www.cvblogs.cn/2017/11/12/开发学习/web开发_内存泄漏/</id>
    <published>2017-11-12T14:31:10.000Z</published>
    <updated>2017-12-12T04:45:36.658Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>以下文章内容大都摘自<a href="http://www.ruanyifeng.com/blog/2017/04/memory-leak.html" target="_blank" rel="noopener">阮一峰的网络博客JavaScript 内存泄漏教程篇</a>,仅作个人学习笔记备记。<br>本来不想记的，因为对于只是在本地写<code>hello world</code>的我来说，内存管理似乎从来不是一件必要的事情。<br>但是，突然想到，内存的管理对于部署在服务器上的或者说生产环境中的应用是多么的重要。<br>想象一下，要是一个需要7/24运行的web应用内存泄漏了：）简直就是一场灾难。服务器怠机则无法提供服务。</p><a id="more"></a><h1 id="什么是内存泄漏"><a href="#什么是内存泄漏" class="headerlink" title="什么是内存泄漏"></a>什么是内存泄漏</h1><p>对于持续运行的服务进程（daemon），必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。<br>不再用到的内存，没有及时释放，就叫做内存泄漏（memory leak）。<br>有些语言（比如 C 语言）必须手动释放内存，程序员负责内存管理。这很麻烦，所以大多数语言提供自动内存管理，减轻程序员的负担，这被称为”垃圾回收机制”（garbage collector）。</p><h1 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h1><p>最常使用的方法叫做”引用计数”（<code>reference counting</code>）：语言引擎有一张”引用表”，保存了内存里面所有的资源（通常是各种值）的引用次数。如果一个值的引用次数是0，就表示这个值不再用到了，因此可以将这块内存释放。<br>但是，并不是说有了垃圾回收机制，程序员就轻松了。你还是需要关注内存占用：那些很占空间的值，一旦不再用到，你必须检查是否还存在对它们的引用。如果是的话，就必须手动解除引用。</p><h1 id="内存泄漏的识别方法"><a href="#内存泄漏的识别方法" class="headerlink" title="内存泄漏的识别方法"></a>内存泄漏的识别方法</h1><p>经验法则是，如果连续<code>五次垃圾回收</code>之后，内存占用一次比一次大，就有内存泄漏。这就要求<code>实时查看内存占用</code>。</p><h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><p>Chrome 浏览器查看内存占用，按照以下步骤操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1. 打开开发者工具，选择 Timeline 面板</div><div class="line">2. 在顶部的Capture字段里面勾选 Memory</div><div class="line">3. 点击左上角的录制按钮。</div><div class="line">4. 在页面上进行各种操作，模拟用户的使用情况。</div><div class="line">5. 一段时间后，点击对话框的 stop 按钮，面板上就会显示这段时间的内存占用情况。</div></pre></td></tr></table></figure></p><p>如果内存占用基本平稳，接近水平，就说明不存在内存泄漏。<br>反之，就是内存泄漏了。</p><h2 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h2><p>命令行可以使用<code>Node</code> 提供的<code>process.memoryUsage</code>方法。<br><code>process.memoryUsage</code>返回一个<code>对象</code>，包含了 <code>Node</code>进程的内存占用信息。该对象包含<code>四个字段</code>，单位是<code>字节</code>。判断内存泄漏，以<code>heapUsed字段</code>为准。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">rss（resident set size）：所有内存占用，包括指令区和堆栈。</div><div class="line">heapTotal：&quot;堆&quot;占用的内存，包括用到的和没用到的。</div><div class="line">heapUsed：用到的堆的部分。</div><div class="line">external： V8 引擎内部的 C++ 对象占用的内存。</div></pre></td></tr></table></figure></p><h1 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h1><p>ES6 考虑到了这一点，推出了两种新的数据结构：<code>WeakSet</code> 和 <code>WeakMap</code>。它们对于值的引用都是不计入垃圾回收机制的，所以名字里面才会有一个”Weak”，表示这是弱引用。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="http://www.ruanyifeng.com/blog/2017/04/memory-leak.html" target="_blank" rel="noopener">JavaScript 内存泄漏教程</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;以下文章内容大都摘自&lt;a href=&quot;http://www.ruanyifeng.com/blog/2017/04/memory-leak.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;阮一峰的网络博客JavaScript 内存泄漏教程篇&lt;/a&gt;,仅作个人学习笔记备记。&lt;br&gt;本来不想记的，因为对于只是在本地写&lt;code&gt;hello world&lt;/code&gt;的我来说，内存管理似乎从来不是一件必要的事情。&lt;br&gt;但是，突然想到，内存的管理对于部署在服务器上的或者说生产环境中的应用是多么的重要。&lt;br&gt;想象一下，要是一个需要7/24运行的web应用内存泄漏了：）简直就是一场灾难。服务器怠机则无法提供服务。&lt;/p&gt;
    
    </summary>
    
      <category term="网页开发" scheme="http://www.cvblogs.cn/categories/%E7%BD%91%E9%A1%B5%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Node.js" scheme="http://www.cvblogs.cn/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>web开发之LiveServer使用</title>
    <link href="http://www.cvblogs.cn/2017/11/12/%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/web%E5%BC%80%E5%8F%91_LiveServer%E4%BD%BF%E7%94%A8/"/>
    <id>http://www.cvblogs.cn/2017/11/12/开发学习/web开发_LiveServer使用/</id>
    <published>2017-11-12T14:15:10.000Z</published>
    <updated>2017-12-26T10:48:13.965Z</updated>
    
    <content type="html"><![CDATA[<h1 id="live-server模块的作用"><a href="#live-server模块的作用" class="headerlink" title="live-server模块的作用"></a>live-server模块的作用</h1><ol><li>实现热插拔<code>hot socketing</code>(修改文件之后，浏览器能够自动刷新)</li><li>当服务启动时，自动打开所在的项目。(实现<code>opener</code>的功能)</li><li>快速搭建临时的web服务。（实现<code>http-server</code>的功能）</li></ol><a id="more"></a><p>我们主要使用1与2，3用express或者其他web框架。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>可以直接使用全局安装的方法<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -g live-server</div></pre></td></tr></table></figure></p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>在<code>package.json</code>的<code>script</code>下添加一个<code>server</code>字段的<code>npm 脚本</code>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="string">"scripts"</span>: &#123;</div><div class="line">  <span class="string">"server"</span>: <span class="string">"live-server ./ --port=9090"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>使用<code>npm run server</code>执行。等待一会之后，浏览器会自动打开。<br>这样当你修改本地任何文件，浏览器都会自动立即同步（在内存层面，如果你想要发布代码，还是需要再次编译，否则修改之后的一些代码不会被改变！）。</p><h1 id="继续学习"><a href="#继续学习" class="headerlink" title="继续学习"></a>继续学习</h1><p><a href="https://www.npmjs.com/package/live-server" target="_blank" rel="noopener">官方链接https://www.npmjs.com/package/live-server</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;live-server模块的作用&quot;&gt;&lt;a href=&quot;#live-server模块的作用&quot; class=&quot;headerlink&quot; title=&quot;live-server模块的作用&quot;&gt;&lt;/a&gt;live-server模块的作用&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;实现热插拔&lt;code&gt;hot socketing&lt;/code&gt;(修改文件之后，浏览器能够自动刷新)&lt;/li&gt;
&lt;li&gt;当服务启动时，自动打开所在的项目。(实现&lt;code&gt;opener&lt;/code&gt;的功能)&lt;/li&gt;
&lt;li&gt;快速搭建临时的web服务。（实现&lt;code&gt;http-server&lt;/code&gt;的功能）&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="网页开发" scheme="http://www.cvblogs.cn/categories/%E7%BD%91%E9%A1%B5%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Node.js" scheme="http://www.cvblogs.cn/tags/Node-js/"/>
    
  </entry>
  
</feed>
